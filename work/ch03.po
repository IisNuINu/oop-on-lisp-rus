#. extracted from ./en/ch03.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 11:03+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch03.md:2
msgid "#  Developing a Simple CLOS Program: Locks"
msgstr "# Разработка простой Программы CLOS: Блокировки(Locks)"

#: ./en/ch03.md:4
msgid ""
"This chapter demonstrates the power of programming with CLOS by following "
"the development of a sample application program. We begin by defining "
"classes and setting up the organization that reflects how the classes are "
"related to one another. Then we define the interface that specifies how "
"clients can create and manipulate objects of these classes. Finally, we "
"define the implementation; this is the Lisp code underlying the interface. "
"The interface is a set of generic functions, and the implementation consists "
"of methods for those generic functions. The interface states what operations "
"you can perform on these objects, and the implementation %states how the "
"operations work internally."
msgstr ""
"В этой главе демонстрируются возможности программирования с помощью CLOS,"
" следуя примеру разработки прикладной программы. Мы начинаем с определения"
" классов и настройки организации, отражающей, как классы связаны друг с"
" другом. Затем мы определяем интерфейс, который определяет, как клиенты могут"
" создавать объекты этих классов и манипулировать ими. Наконец, мы определяем"
" реализацию; это код Lisp, лежащий в основе интерфейса. Интерфейс"
" представляет собой набор обобщеных функций, а реализация состоит из методов"
" для этих обобщенных функций. В интерфейсе указано, какие операции вы можете"
" выполнять с этими объектами, а в реализации указано, как эти операции"
" работают внутри."

#: ./en/ch03.md:6
msgid ""
"In this chapter, we take different points of view on the program: we design "
"and develop it as a programmer does; we use it as a client does; and finally "
"we analyze how its pieces interact, as CLOS itself does."
msgstr ""
"В этой главе мы рассматриваем программу с разных точек зрения: мы проектируем"
" и разрабатываем ее так, как это делает программист; мы используем ее так,"
" как это делает клиент; и, наконец, мы анализируем, как взаимодействуют ее"
" части, как это делает сам CLOS."

#: ./en/ch03.md:8
msgid "## 3.1 OVERVIEW OF LOCKING"
msgstr "## 3.1 ОБЗОР БЛОКИРОВОК(LOCKING)"

#: ./en/ch03.md:10
msgid ""
"The goal of this sample application is to implement locks—objects that are "
"used to control concurrent access to some shared resource. For example, in a "
"meeting it is desirable for only one person to be speaking at any given "
"time. The expression \"Mr. Smith has the floor\" makes it clear that the "
"\"floor\" (a shared resource) is protected against simultaneous use by other "
"people. Throughout this example, we use the term \"seize\" to describe the "
"act of securing or obtaining a lock, and \"release\" to mean giving up a "
"lock."
msgstr ""
"Целью этого примера приложения является реализация объектов-блокировок("
" locks—objects), которые используются для управления параллельным доступом к"
" некоторому общему ресурсу. Например, на собрании желательно, чтобы в любой"
" момент времени выступал только один человек. Выражение \"Слово"
" предоставляется мистеру Смиту\" ясно дает понять, что \"слово\" (общий"
" ресурс) защищено от одновременного использования другими людьми. Во всем"
" этом примере мы используем термин \"захват/seize\" для описания акта"
" закрепления(securing) или получения блокировки(lock), а"
" \"освобождение/release\" означает отказ от блокировки."

#: ./en/ch03.md:12
msgid ""
"Locks are meaningful only in an environment where more than one process can "
"contend for a resource at a given time. Here, processes are defined as "
"multiple independent threads of control within a single Lisp environment. "
"Locks are used to ensure that a shared resource is accessed in a consistent "
"fashion. Before accessing the resource, a process should seize the lock "
"associated with it. When finished, the process should release the lock."
msgstr ""
"Блокировки имеют смысл только в среде, где более одного процесса могут"
" претендовать на ресурс в данный момент времени. Здесь процессы определяются"
" как несколько независимых потоков управления в рамках одной среды Lisp."
" Блокировки используются для обеспечения согласованного доступа к общему"
" ресурсу. Прежде чем получить доступ к ресурсу, процесс должен"
" захватить(seize) связанную с ним блокировку(lock). По завершении процесса"
" блокировка должна быть снята(release)."

#: ./en/ch03.md:14
msgid ""
"We recognize that processes are not part of Common Lisp, and that this "
"sample program would not be meaningful in a Common Lisp implementation that "
"does not have multiple processes. However, our goal is not to develop a "
"program that works in all environments; rather, we want to show a simple "
"example of the object-oriented style. So, even if locks would not be useful "
"in your Common Lisp environment, please read on."
msgstr ""
"Мы признаем, что процессы не являются частью Common Lisp, и что этот пример"
" программы не имел бы смысла в реализации Common Lisp, в которой нет"
" нескольких процессов. Однако наша цель состоит не в том, чтобы разработать"
" программу, которая работает во всех средах; скорее, мы хотим показать"
" простой пример объектно-ориентированного стиля. Итак, даже если блокировки"
" не будут полезны в вашей среде Common Lisp, пожалуйста, читайте дальше."

#: ./en/ch03.md:16
msgid ""
"We call a lock \"busy\" if it has been seized but not yet released, and  "
"\"free\" if it is available to be seized. When a lock is busy, the process "
"that seized it is called its \"owner.\""
msgstr ""
"Мы называем блокировку \"занятой/busy\", если она была захвачена(seized), но"
" еще не освобождена(released), и \"свободной/free\", если она доступна для"
" захвата. Когда блокировка занята, процесс, который ее захватил, называется"
" ее \"владельцем/owner\"."

#: ./en/ch03.md:18
msgid ""
"We shall implement locks as Lisp objects. The interface to locks must "
"include the following operations:"
msgstr ""
"Мы будем реализовывать блокировки как объекты Lisp. Интерфейс к блокировкам"
" должен включать в себя следующие операции:"

#: ./en/ch03.md:20
msgid "\t> Create             Create a new lock. "
msgstr "\t>  Create(Создать)         Создает новую блокировку."

#: ./en/ch03.md:22
msgid ""
"\t> Seize              Seize a lock. When successful, the lock object is the "
"returned value. "
msgstr ""
"\t> Seize(Захватите)        Захватывает блокировку. В случае успешного"
" выполнения возвращаемым значением является объект блокировки."

#: ./en/ch03.md:25
msgid ""
"\t> Release            Release a lock, if it is owned by the same process "
"that is now trying to \n"
"\t>                    release it."
msgstr ""
"\t> Release(Снять)          Снимает блокировку, если она принадлежит тому же"
" процессу, который сейчас пытается \n"
"\t>                                  ее снять."

#: ./en/ch03.md:27
msgid ""
"There are many possible kinds of locks, and we want our locking program to "
"be extensible, since we plan to support more complex types of locks later. "
"For example, we might eventually need a lock that can avoid deadlock "
"situations. (Deadlock happens when one person picks up the butter dish and "
"reaches for the butter knife at the same time that another person has picked "
"up the butter knife and reaches for the butter dish. Neither person can "
"obtain butter until the other has finished.)"
msgstr ""
"Существует много возможных типов блокировок, и мы хотим, чтобы наша программа"
" блокировки была расширяемой, поскольку позже мы планируем поддерживать более"
" сложные типы блокировок. Например, в конечном итоге нам может понадобиться"
" блокировка, которая позволит избежать взаимоблокировок(deadlock situations)."
" (Тупиковая ситуация(deadlock) возникает, когда один человек берет кусок"
" масла  и тянется к ножу для масла в то же время, когда другой человек взял"
" нож для масла и тянется к куску масла. Ни один человек не может получить"
" масло и намазать его на хлеб, пока другой не закончит.)"

#: ./en/ch03.md:29
msgid ""
"We start by defining two elementary kinds of lock, which we can later use as "
"building blocks for other kinds of locks."
msgstr ""
"Мы начнем с определения двух элементарных типов блокировок, которые позже мы"
" можем использовать в качестве строительных блоков для других типов"
" блокировок."

#: ./en/ch03.md:32
msgid ""
"\t> Simple lock        This kind of lock has a name. The lock is either busy "
"or free. If the lock \n"
"\t>                    is busy, it keeps track of its owner, which is a "
"process."
msgstr ""
"\t> Simple lock(Простая блокировка)   У этого вида блокировки есть название."
" Блокировка либо занята, либо свободна.\n "
"\t>                                      Если блокировка занята, она"
" отслеживает своего владельца, котороый является процессом."

#: ./en/ch03.md:41
msgid ""
"\t> Null lock          This kind of lock also has a name, but it does not "
"keep track of whether it \n"
"\t>                    is busy or free. In effect, a null lock is always "
"free. A null lock supports \n"
"\t>                    the normal locking operations without actually "
"protecting itself from being \n"
"\t>                    seized by other owners. This kind of lock allows "
"programs to deal consistently \n"
"\t>                    with resources that sometimes need to be protected "
"against simultaneous access \n"
"\t>                    and sometimes do not. The program goes through all "
"the motions of seizing and \n"
"\t>                    releasing the lock, and the kind of lock (whether "
"null or another kind) controls \n"
"\t>                    whether or not the resource is protected."
msgstr ""
"\t> Null lock(Нулевая блокировка)     У этого вида блокировки также есть имя,"
" \n"
"\t> но она не отслеживает, занята она или свободна. По сути, нулевая"
" блокировка \n"
"\t> всегда свободна. Нулевая блокировка поддерживает обычные операции"
" блокировки, \n"
"\t> фактически не защищая себя от захвата другими владельцами. Этот вид"
" блокировки \n"
"\t> позволяет программам последовательно работать с ресурсами, которые иногда"
" нуждаются \n"
"\t> в защите от одновременного доступа, а иногда и нет. Программа выполняет"
" все действия \n"
"\t> по захвату и снятию блокировки, и тип блокировки (будь то нулевой или"
" другой вид) определяет, \n"
"\t> защищен ли ресурс."

#: ./en/ch03.md:43
msgid "##  3.2 DEFINING THE KINDS OF OBJECTS-CLASSES"
msgstr "## 3.2 ОПРЕДЕЛЕНИЕ ТИПОВ ОБЪЕКТОВ-КЛАССОВ"

#: ./en/ch03.md:45
msgid ""
"Now we must translate the English-language description of null locks and "
"simple locks into the language of CLOS. The translation illustrates"
msgstr ""
"Теперь мы должны перевести описание нулевых блокировок и простых блокировок"
" на язык CLOS. Перевод иллюстрирует"

#: ./en/ch03.md:51
msgid ""
"* Designing a program that uses inheritance \n"
"* Using slots to store state information \n"
"* Defining classes with the defclass macro \n"
"* Requesting methods for reading and writing slots \n"
"* Giving a slot a default initial value "
msgstr ""
"* Разработку программы, использующей наследование"
"* Использование слотов для хранения информации о состоянии"
"* Определение классов с помощью макроса defclass"
"* Методы запросов для чтения и записи слотов"
"* Присвоение слоту начального значения по умолчанию"

#: ./en/ch03.md:53
msgid "### Choosing the Classes to Represent Locks"
msgstr "### Выбор классов для представления блокировок"

#: ./en/ch03.md:55
msgid ""
"Although at first glance it seems that we should define two classes (one to "
"represent simple locks and the other to represent null locks), we can make "
"better use of inheritance by defining three classes in the organization "
"shown in Fig. 3.1."
msgstr ""
"Хотя на первый взгляд кажется, что мы должны определить два класса (один для"
" представления простых блокировок, а другой для представления нулевых"
" блокировок), мы можем лучше использовать наследование, определив три класса"
" в организации, показанной на рис. 3.1."

#: ./en/ch03.md:58
msgid ""
"![Figure 3.1: Organization of lock classes.](images/f03-01.jpg)\n"
"**Figure 3.1: Organization of lock classes.**"
msgstr ""
"![Рисунок 3.1: Организация классов блокировок.](images/f03-01.jpg )"
"**Рисунок 3.1: Организация классов блокировок.**"

#: ./en/ch03.md:60
msgid ""
"The classes simple-lock and null-lock include lock in their definition; we "
"say that they are built on the class lock. They both inherit from the class "
"lock. Here is a terminology reminder: "
msgstr ""
"Классы simple-lock и null-lock включают lock в свое определение; мы говорим,"
" что они построены на классе lock. Они оба наследуются от класса"
" lock(блокировки). Вот напоминание о терминологии:"

#: ./en/ch03.md:63
msgid ""
"\t> lock is a direct superclass of null-lock, \n"
"\t> lock is a direct superclass of simple-lock."
msgstr ""
"\t> lock - это прямой суперкласс null-lock,\n"
"\t> lock - это прямой суперкласс simple-lock."

#: ./en/ch03.md:66
msgid ""
"\t> null-lock is a direct subclass of lock, \n"
"\t> simple-lock is a direct subclass of lock. "
msgstr ""
"\t> null-lock - это прямой подкласс lock, \n"
"\t> simple-lock - это прямой подкласс lock."

#: ./en/ch03.md:68
msgid ""
"We call lock a basic class. The term \"basic class\" does not have any "
"specific technical significance (the class lock acts just like any other "
"class), but it describes the purpose of the class. The lock class is "
"intended to be the foundation of all locks; its purpose is to contribute the "
"characteristics that all locks have in common. The principal characteristic "
"that all locks share is the fact that they are locks. By building all lock "
"classes on the class named lock, we can use (typep object 'lock) to find out "
"whether an object is a lock."
msgstr ""
"Мы называем lock базовым классом. Термин \"базовый класс\" не имеет"
" какого-либо конкретного технического значения (класс lock(блокировка)"
" действует так же, как и любой другой класс), но он описывает назначение"
" класса. Класс lock предназначен для того, чтобы быть основой всех"
" блокировок; его цель - привнести характеристики, которые являются общими для"
" всех блокировок. Основной характеристикой, общей для всех блокировок,"
" является тот факт, что они являются блокировками. Создавая все классы"
" блокировок для класса с именем lock, мы можем использовать (typep object"
" 'lock), чтобы выяснить, является ли объект блокировкой."

#: ./en/ch03.md:70
msgid ""
"Also, both simple locks and null locks have names, so the \"name "
"characteristic\" is provided by the class lock and is inherited by all kinds "
"of locks. Another reason for providing a basic class is to make it "
"convenient to define default methods. A method attached to a basic class is "
"a default method. Any class that inherits from the basic class can choose to "
"use the default method, provide a method to override the default method, or "
"support additional behavior by providing a before-method or an after-method "
"to work with the default method. In summary, we define the class lock for "
"three reasons:"
msgstr ""
"Кроме того, как простые блокировки, так и нулевые блокировки имеют имена,"
" поэтому \"характеристика имени\" предоставляется классом lock и наследуется"
" всеми видами блокировок. Еще одна причина предоставления базового класса"
" заключается в том, чтобы было удобно определять методы по умолчанию. Метод,"
" присоединенный к базовому классу, является методом по умолчанию. Любой"
" класс, который наследуется от базового класса, может выбрать использование"
" метода по умолчанию, предоставить метод для переопределения метода по"
" умолчанию или поддерживать дополнительное поведение, предоставляя метод"
" before или after для работы с методом по умолчанию. Таким образом, мы"
" определяем класс lock по трем причинам:"

#: ./en/ch03.md:74
msgid ""
"* It enables us to use (typep object 'lock) to check whether an object is a "
"lock \n"
"* It contributes the name characteristic to all locks \n"
"* It supports the default behavior of all locks "
msgstr ""
"* Он позволяет нам использовать (typep object 'lock), чтобы проверить,"
" является ли объект блокировкой\n"
"* Он добавляет характеристику имени ко всем блокировкам\n"
"* Он поддерживает поведение всех блокировок по умолчанию"

#: ./en/ch03.md:76
msgid ""
"We do not intend this class to stand alone, in that we do not expect to "
"create instances of it. The class lock will not have a complete set of "
"methods for supporting the locking protocol."
msgstr ""
"Мы не предполагаем, что этот класс будет работать самостоятельно, поскольку"
" мы не ожидаем создания его экземпляров. Класс lock не будет иметь полного"
" набора методов для поддержки протокола блокировки."

#: ./en/ch03.md:78
msgid "### Using defclass "
msgstr "### Использование defclass"

#: ./en/ch03.md:80
msgid "We define the class lock as follows:"
msgstr "Мы определяем класс lock следующим образом:"

#: ./en/ch03.md:88
msgid ""
"<pre>\n"
"(defclass lock () \n"
"  ((name :initarg :name\n"
"         :reader  lock-name)) \n"
"  (:documentation \"The foundation of all locks.\"))\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:91
msgid ""
"Evaluating this form creates a new class named lock with one slot called "
"name. It also creates the generic function lock-name, and a method for lock-"
"name that allows you to read the value of the name slot of any object whose "
"type is lock. Here we examine each portion of the class definition and see "
"what it does: \n"
"\t>  defclass            The macro for defining a new class,"
msgstr ""
"Вычисление этой формы создает новый класс с именем lock с одним слотом с"
" именем name. Он также создает обобщенную функцию lock-name и метод для"
" lock-name, который позволяет вам считывать значение слота name(имени) любого"
" объекта, тип которого lock. Здесь мы рассмотрим каждую часть определения"
" класса и посмотрим, что она делает: \n"
"\t>  defclass            Макрос для определения нового класса,"

#: ./en/ch03.md:93
msgid "\t>  lock                The name of the new class."
msgstr "\t>  lock                имя нового класса."

#: ./en/ch03.md:96
msgid ""
"\t>  ()                  The list of direct superclasses. The list here is "
"empty\n"
"\t>                      because we have not specified any superclasses for "
"lock."
msgstr ""
"\t>  ()                  Список прямых суперклассов. Список здесь пуст, \n"
"\t>                      потому что мы не указали никаких суперклассов для"
" lock(блокировки)."

#: ./en/ch03.md:102
msgid ""
"\t> ((name :initarg :name :reader lock-name)) \n"
"\t>                      The list of slot specifiers. Each slot specifier "
"can be given as a symbol\n"
"\t>                      (the name of the slot) or a list (the name of the "
"slot followed by slot\n"
"\t>                      options). Here we have a single slot named name, "
"with these two slot\n"
"\t>                      options:"
msgstr ""
"\t> ((name :initarg :name :reader lock-name)) \n"
"\t>                      Список спецификаторов слотов. Каждый спецификатор"
" слота может быть задан в виде символа\n"
"\t>                      (название слота) или списка (название слота, за"
" которым следуют параметры слота). Здесь у нас\n"
"\t>                      есть один слот с именем name, с этими двумя опциями"
" слота:"

#: ./en/ch03.md:114
msgid ""
"\t>                      :initarg :name \n"
"\t>                          This option makes it possible to initialize the "
"value of this slot when\n"
"\t>                          creating instances. To initialize the name "
"slot, we can give the\n"
"\t>                          :name keyword argument to make-instance. (Note "
"that make-instance is\n"
"\t>                          the CLOS function for creating new instances; "
"we discuss it in\n"
"\t>                          \"Using make-instance or Constructors,\" page "
"24.) \n"
"\t>                      :reader lock-name \n"
"\t>                          This option makes it possible to read the value "
"of this slot by using\n"
"\t>                          the generic function lock-name. This slot "
"option causes the CLOS\n"
"\t>                          system to generate a method for lock-name, lock-"
"name is called a\n"
"\t>                          reader generic function."
msgstr ""
"\t>                      :initarg :name \n"
"\t>                          Эта опция позволяет инициализировать значение"
" этого слота при создании экземпляров. \n"
"\t>                          Чтобы инициализировать слот name, мы можем"
" задать ключевое слово :name аргумент \n"
"\t>                          при создания экземпляра. (Обратите внимание, что"
" make-instance - это функция CLOS \n"
"\t>                          для создания новых экземпляров; мы обсуждаем ее"
" в разделе \"Использование make-instance\n"
"\t>                          или конструкторов\", стр. 24.)\n"
"\t>                      :reader lock-name \n"
"\t>                          Эта опция позволяет считывать значение этого"
" слота с помощью обобщенной функции lock-name.\n"
"\t>                          Этот параметр слота заставляет систему CLOS"
" генерировать метод для lock-name, lock-name \n"
"\t>                          называется обобщенной функцией чтения."

#: ./en/ch03.md:120
msgid ""
"\t> (:documentation \"The foundation of all locks.\") \n"
"\t>                       This is a class option; it pertains to the class "
"as a whole. The\n"
"\t>                       :documentation class option provides a "
"documentation string describing\n"
"\t>                       the purpose of the class. You can retrieve the "
"documentation string of\n"
"\t>                       a class by calling the documentation function."
msgstr ""
"\t> (:documentation \"The foundation of all locks.\") - \"Основа всех"
" блокировок\" \n"
"\t>                       Это параметр класса; он относится к классу в целом."
" Параметр :documentation  предоставляет строку\n"
"\t>                       документации, описывающую назначение класса. Вы"
" можете получить строку документации класса, \n"
"\t>                       вызвав функцию документации."

#: ./en/ch03.md:122
msgid "### Inheriting from a Superclass "
msgstr "### Наследование от суперкласса"

#: ./en/ch03.md:124
msgid ""
"The definition of null-lock illustrates how to define a class that is built "
"on a superclass. Here the class null-lock is built on one superclass, the "
"class lock. "
msgstr ""
"Определение нулевой блокировки(null-lock) иллюстрирует, как определить класс,"
" построенный на суперклассе. Здесь класс null-lock построен на одном"
" суперклассе, классе lock."

#: ./en/ch03.md:130
msgid ""
"<pre>\n"
"(defclass null-lock (lock)\n"
"  () \n"
"  (:documentation \"A lock that is always free.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:132
msgid "The class null-lock inherits the following from its superclass lock: "
msgstr "Класс null-lock наследует следующее от своей блокировки суперкласса:"

#: ./en/ch03.md:134
msgid ""
"\t> name slot              Each instance of null-lock has a slot named name."
msgstr ""
"\t> name slot               Каждый экземпляр null-lock имеет слот с именем"
" name."

#: ./en/ch03.md:137
msgid ""
"\t> :initarg :name slot option \n"
"\t>                        You can initialize the name slot when making an "
"instance of null-lock."
msgstr ""
"\t> :initarg :name slot option \n"
"\t>                        Вы можете инициализировать слот имени при создании"
" экземпляра null-lock."

#: ./en/ch03.md:141
msgid ""
"\t> lock-name method \n"
"\t>                        You can use the reader lock-name on instances of "
"null-lock to read\n"
"\t>                        the value of the name slot. "
msgstr ""
"\t> lock-name method \n"
"\t>                        Вы можете использовать читатель lock-name в"
" экземплярах null-lock для считывания\n"
"\t>                        значения слота name.. "

#: ./en/ch03.md:143
msgid "### Accessors "
msgstr "### Accessors(Методы доступа)"

#: ./en/ch03.md:146
msgid ""
"We now define the class simple-lock. A simple lock keeps track of whether it "
"is busy or free. The definition of simple-lock provides the slot owner, "
"which indicates whether the simple lock is busy or free by remembering which "
"process currently owns the lock. A free lock has its owner slot set to nil, "
"and a busy lock has its owner slot set to the process \n"
"that currently owns the lock."
msgstr ""
"Теперь мы определяем класс simple-lock. Простая блокировка отслеживает,"
" занята она или свободна. Определение simple-lock предоставляет владельца"
" слота, который указывает, занята ли простая блокировка или свободна,"
" запоминая, какому процессу в данный момент принадлежит блокировка. Для"
" свободной блокировки в ее собственном слоте установлено значение nil, а для"
" занятой блокировки в слоте владельца установлен процесс, которому в данный"
" момент принадлежит блокировка."

#: ./en/ch03.md:152
msgid ""
"<pre>\n"
"(defclass simple-lock (lock) \n"
"  ((owner :initform nil :accessor lock-owner)) \n"
"  (:documentation \"A lock that is either free or busy.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:154
msgid ""
"The class simple-lock inherits exactly the same characteristics and behavior "
"from lock as does null-lock. Note that the class simple-lock inherits the "
"slot name from its superclass, and that it adds a slot of its own, the owner "
"slot. The definition of simple-lock also includes two new slot options:"
msgstr ""
"Класс simple-lock наследует от lock точно такие же характеристики и"
" поведение, как и null-lock. Обратите внимание, что класс simple-lock"
" наследует имя слота от своего суперкласса и что он добавляет свой"
" собственный слот, слот owner(владельца). Определение simple-lock также"
" включает в себя два новых варианта слотов:"

#: ./en/ch03.md:156
msgid "\t> :initform nil"
msgstr ""

#: ./en/ch03.md:160
msgid ""
"\t>                    This slot option allows you to give a default initial "
"value for a slot.\n"
"\t>                    Here, the default initial value of the owner slot is "
"nil. This means that,\n"
"\t>                    when a simple lock is created, it is free."
msgstr ""
"\t>                    Этот параметр слота позволяет задать начальное"
" значение по умолчанию для слота.\n"
"\t>                    Здесь начальное значение по умолчанию для слота"
" владельца равно nil. Это означает, \n"
"\t>                    что при создании простой блокировки она является"
" свободной(free)."

#: ./en/ch03.md:169
msgid ""
"\t> :accessor lock-owner \n"
"\t>                    This slot option enables you to access the slot owner "
"for either reading\n"
"\t>                    or writing the value of the slot. CLOS generates two "
"generic functions:\n"
"\t>                    a reader generic function called lock-owner and a "
"corresponding writer\n"
"\t>                    generic function. CLOS also defines methods for each "
"of these generic\n"
"\t>                    functions. Thus, you can read the value of the slot "
"owner by using the\n"
"\t>                    reader generic function lock-owner, and you can write "
"the value of the\n"
"\t>                    slot by using setf with lock-owner."
msgstr ""
"\t> :accessor lock-owner \n"
"\t>                    Эта опция слота позволяет вам получить доступ к слоту"
" owner для считывания или записи значения \n"
"\t>                    слота.  CLOS генерирует две обобщенные функции:"
" обобщенную функцию чтения, называемую \n"
"\t>                    lock-owner, и соответствующую обобщенную функцию"
" записи. CLOS также определяет методы для \n"
"\t>                    каждой из этих обобщенных функций. Таким образом, вы"
" можете прочитать значение слота owner с \n"
"\t>                    помощью обобщенной функции чтения lock-owner, и вы"
" можете записать значение слота с помощью \n"
"\t>                    setf с lock-owner."

#: ./en/ch03.md:174
msgid ""
"The name of this reader generic function is the symbol lock-owner. To call a "
"reader, use normal function-calling syntax, such as: \n"
"<pre>\n"
"(lock-owner lock-object) \n"
"</pre>"
msgstr ""
"Имя этой обобщенной функции чтения - символ lock-owner. Чтобы вызвать"
" средство чтения, используйте обычный синтаксис вызова функций, например: \n"
"<pre>\n"
"(lock-owner lock-object) \n"
"</pre>"

#: ./en/ch03.md:181
msgid ""
"The name of the writer generic function is the list (setf lock-owner). \n"
"This list is not a form to be evaluated; it is the name of the function — in "
"other words, it is the \"function specifier.\" To call the writer, use the "
"setf syntax as follows:\n"
"<pre>\n"
"(setf (lock-owner lock-object) new-value) \n"
"</pre>\n"
"The slot options :reader and :accessor are similar. The :reader slot option "
"generates a method for a reader generic function only. The :accessor slot "
"option generates two methods: one for a reader and one for a writer. The "
"term accessor generic function is an umbrella term that includes both "
"readers and writers. Usually you define a reader if you want to read the "
"slot, and both kinds of accessors if you want to read and write the slot. It "
"is possible to define only a writer (with the rwriter slot option), but this "
"is rarely done."
msgstr ""
"Имя обобщенной функции записи - это список (set flock-owner).\n"
"Этот список не является формой, подлежащей оценке/вычислению; это имя функции"
" — другими словами, это \"спецификатор функции\". Чтобы вызвать средство"
" записи, используйте синтаксис setf следующим образом::\n"
"<pre>\n"
"(setf (lock-owner lock-object) new-value) \n"
"</pre>\n"
"Параметры слота :reader и :accessor аналогичны. Параметр слота  :reader "
" генерирует метод только для обобщенной функции считывателя. Опция слота"
" :accessor  генерирует два метода: один для чтения и один для записи. Термин"
" \"обобщенная функция доступа(accessor generic function)\" является"
" обобщающим термином, который включает в себя как средства чтения, так и"
" средства записи. Обычно вы определяете средство чтения, если хотите"
" прочитать слот, и оба вида средств доступа, если хотите читать и записать"
" слот. Можно определить только запись (с помощью опции слота :writer), но это"
" делается редко."

#: ./en/ch03.md:183
msgid "### Slots Used in Lock Classes "
msgstr "### Слоты, используемые в классах блокировок"

#: ./en/ch03.md:185
msgid ""
"Here we review how we intend to use the name and owner slots, and rlate that "
"to the slot options chosen for the slots:"
msgstr ""
"Здесь мы рассмотрим, как мы намерены использовать слоты name и owner, и"
" соотнесем это с параметрами слотов, выбранными для слотов:"

#: ./en/ch03.md:194
msgid ""
"\t> name           Each lock has a name. We initialize the name when we "
"create a lock, by giving it\n"
"\t>                as an argument to make-instance. We do not provide a "
"default initial value for\n"
"\t>                the name slot because that would not make sense; each "
"lock needs a name suited\n"
"\t>                to its purpose, so no default name would be appropriate "
"in enough cases to make\n"
"\t>                defaulting worth-while. \n"
"\t>                We can use the reader lock-name to determine the name of "
"a lock. We have not\n"
"\t>                provided a means for changing the name of the lock; there "
"is no writer method\n"
"\t>                for lock-name."
msgstr ""
"\t> name            У каждой блокировки есть имя. Мы инициализируем имя при"
" создании блокировки, передавая его в \n"
"\t>                     качестве аргумента make-instance. Мы не предоставляем"
" начальное значение по умолчанию для слота\n "
"\t>                     name, потому что это не имело бы смысла; каждой"
" блокировке нужно имя, соответствующее ее назначению,\n"
"\t>                     поэтому ни одно имя по умолчанию не подходит в"
" достаточном количестве случаев, чтобы оправдать\n"
"\t>                     дефолт( worth-while)."

#: ./en/ch03.md:204
msgid ""
"\t> owner          Each simple lock has an owner. The owner slot is always "
"initialized to nil when\n"
"\t>                a simple lock is created. We have not allowed the slot to "
"be initialized by an\n"
"\t>                argument to make-instance, because we want all newly "
"created simple locks to be\n"
"\t>                free.\n"
"\t>                We can use the reader lock-owner to find out the owner of "
"a simple lock. We can\n"
"\t>                use the writer method corresponding to lock-owner to "
"change the owner of a simple\n"
"\t>                lock. The name of the writer is (setf lock-owner). This "
"writer method will be\n"
"\t>                useful inside the seize methods, but we do not intend it "
"to be part of the\n"
"\t>                interface. "
msgstr ""
"\t> owner           У каждой простой блокировки есть владелец. Слот владельца"
" всегда инициализируется равным nil при \n"
"\t>                    создании простой блокировки. Мы не разрешили"
" инициализировать слот аргументом make-instance, потому\n"
"\t>                    что мы хотим, чтобы все вновь созданные простые"
" блокировки были свободными."
"\t>                    Мы можем использовать считыватель  lock-owner, чтобы"
" узнать владельца простой блокировки. Мы можем\n "
"\t>                    использовать метод записи, соответствующий lock-owner,"
" чтобы изменить владельца простой блокировки.\n "
"\t>                    Имя метода записи  - (setf lock-owner). Этот метод"
" записи будет полезен внутри методов захвата(seize), но мы\n"
"\t>                    не предполагаем, что он будет частью интерфейса."

#: ./en/ch03.md:206
msgid ""
"Despite the similarity in the names :initform and :initarg, these slot "
"options are intended for different purposes. The :initarg option lets you "
"provide an argument to make-instance for initializing the value of a slot. "
"Thus, using this slot option enables callers of make-instance to specify an "
"initial value for the slot. We used :initarg for the name slot."
msgstr ""
"Параметры слота :reader и :accessor аналогичны. Параметр :слот для"
" считывателя генерирует метод только для универсальной функции считывателя."
" Опция :слот для доступа генерирует два метода: один для чтения и один для"
" записи. Термин \"универсальная функция доступа\" является обобщающим"
" термином, который включает в себя как средства чтения, так и средства"
" записи. Обычно вы определяете средство чтения, если хотите прочитать слот, и"
" оба вида средств доступа, если хотите прочитать и записать слот. Можно"
" определить только запись (с помощью опции :writer slot), но это делается"
" редко."

#: ./en/ch03.md:208
msgid ""
"In contrast, :initform provides a default initial value for the slot. The "
"slot is initialized to the value specified in the :initform option, instead "
"of being initialized by an argument to make-instance. We used :initform for "
"the owner slot."
msgstr ""
"В отличие от этого, :initform предоставляет начальное значение по умолчанию"
" для слота. Слот инициализируется значением, указанным в параметре :initform,"
" вместо того, чтобы инициализироваться аргументом make-instance. Мы"
" использовали :initform для слота owner(владельца)."

#: ./en/ch03.md:210
msgid "##   3.3 CREATING NEW OBJECTS-INSTANCES "
msgstr "## 3.3 СОЗДАНИЕ НОВЫХ ОБЪЕКТОВ-ЭКЗЕМПЛЯРОВ(OBJECTS-INSTANCES)"

#: ./en/ch03.md:212
msgid ""
"The code we have written will feel more real if we create some locks and "
"manipulate them. In the following sections, we create instances of simple-"
"lock and null-lock and experiment with them. "
msgstr ""
"Написанный нами код будет казаться более реальным, если мы создадим несколько"
" блокировок и будем манипулировать ими. В следующих разделах мы создадим"
" экземпляры simple-lock и null-lock и поэкспериментируем с ними."

#: ./en/ch03.md:214
msgid "### Using make-instance or Constructors"
msgstr "### Использование make-instance или конструкторов"

#: ./en/ch03.md:221
msgid ""
"The function for creating new instances is make-instance. Here we use make-"
"instance to create a null lock and to initialize its name slot to be \"Null "
"lock\":\n"
"<pre>\n"
"(setq *null-lock* \n"
"      (make-instance 'null-lock :name \"Null lock\")) \n"
";=> #<NULL-LOCK {23FEFD01}>\n"
"</pre>"
msgstr ""
"Функция для создания новых экземпляров называется make-instance. Здесь мы"
" используем make-instance для создания нулевой блокировки и инициализации ее"
" слота имени как  \"Null lock\"(Нулевая блокировка).:\n"
"<pre>\n"
"(setq *null-lock* \n"
"      (make-instance 'null-lock :name \"Null lock\")) \n"
";=> #<NULL-LOCK {23FEFD01}>\n"
"</pre>"

#: ./en/ch03.md:229
msgid ""
"Here we use make-instance to create a simple lock and to initialize its name "
"slot to be \"Simple Lock\":\n"
"<pre>\n"
"(setq *simple-lock* \n"
"      (make-instance 'simple-lock :name \"Simple lock\"))\n"
";=> #<SIMPLE-LOCK {240CBD21}>\n"
"</pre>\n"
"You can use make-instance to make an instance of a class. The first argument "
"is the name of the class. The following arguments are initargs followed by "
"values. Here the initarg :name is used to initialize the name slot with a "
"value."
msgstr ""
"Здесь мы используем make-instance для создания простой блокировки и"
" инициализации ее слота имени как \"Simple Lock\".:\n"
"<pre>\n"
"(setq *simple-lock* \n"
"      (make-instance 'simple-lock :name \"Simple lock\"))\n"
";=> #<SIMPLE-LOCK {240CBD21}>\n"
"</pre>\n"
"Вы можете использовать make-instance для создания экземпляра класса. Первый"
" аргумент - это имя класса. Следующие аргументы являются initargs, за"
" которыми следуют значения. Здесь initarg :name используется для"
" инициализации слота name значением."

#: ./en/ch03.md:231
msgid ""
"We recommend that you define constructor functions to be used by the clients "
"to make instances. A constructor is a tailored way to make an instance of a "
"given class; its name usually describes the kind of instance that it "
"creates. A constructor provides a more abstract external interface than does "
"make-instance, because its name describes its higher-level purpose (make a "
"null lock) instead of its internal implementation (make an instance of the "
"class null-lock). "
msgstr ""
"Мы рекомендуем вам определить функции конструктора, которые будут"
" использоваться клиентами для создания экземпляров. Конструктор - это"
" специально разработанный способ создания экземпляра данного класса; его имя"
" обычно описывает тип экземпляра, который он создает. Конструктор"
" предоставляет более абстрактный внешний интерфейс, чем make-instance,"
" поскольку его имя описывает его назначение более высокого уровня (создание"
" нулевой блокировки), а не его внутреннюю реализацию (создание экземпляра"
" класса null-lock)."

#: ./en/ch03.md:233
msgid ""
"Another advantage is that a constructor can have required arguments. In "
"contrast, all arguments to make-instance except for the first are optional. "
"We might prefer to require that users initialize the name of a lock."
msgstr ""
"Еще одним преимуществом является то, что конструктор может иметь требуемые"
" аргументы. Напротив, все аргументы для make-instance, за исключением"
" первого, являются необязательными. Мы могли бы предпочесть потребовать,"
" чтобы пользователи инициализировали имя блокировки."

#: ./en/ch03.md:235
msgid ""
"You can define a constructor by using defun, and calling make-instance in "
"the body of the function. For example, here we define two constructors, one "
"for making a null lock, and the other for making a simple lock:"
msgstr ""
"Вы можете определить конструктор, используя defun и вызывать make-instance в"
" теле функции. Например, здесь мы определяем два конструктора, один для"
" создания нулевой блокировки, а другой для создания простой блокировки:"

#: ./en/ch03.md:239
msgid ""
"<pre>\n"
"(defun make-null-lock (name) \n"
"   (make-instance 'null-lock :name name)) "
msgstr ""

#: ./en/ch03.md:243
msgid ""
"(defun make-simple-lock (name) \n"
"   (make-instance 'simple-lock :name name)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:245
msgid ""
"We shall advertise make-null-lock and make-simple-lock as part of the "
"interface to be used by clients when creating new locks. Thus, instead of "
"using make-instance, clients use the constructors:"
msgstr ""
"Мы будем рекламировать make-null-lock и make-simple-lock как часть"
" интерфейса, который будет использоваться клиентами при создании новых"
" блокировок. Таким образом, вместо использования make-instance клиенты"
" используют конструкторы:"

#: ./en/ch03.md:250
msgid ""
"<pre>\n"
"(make-null-lock \"Null lock\") \n"
"(make-simple-lock \"Simple lock\") \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:252
msgid "### Using the Accessors "
msgstr "### Использование Методов Доступа(Accessors)"

#: ./en/ch03.md:254
msgid ""
"We can experiment with the reader and writer generic functions which were "
"automatically generated through the :reader and :accessor options to "
"defclass. "
msgstr ""
"Мы можем поэкспериментировать с обобщенными функциями reader и writer,"
" которые были автоматически сгенерированы с помощью опций :reader и :accessor"
" в defclass."

#: ./en/ch03.md:256
msgid ""
"We have a reader generic function lock-name, and a method for it. That "
"method is attached to the lock class, and is inherited by both null-lock and "
"simple-lock, because they are both built on lock."
msgstr ""
"У нас есть обобщенная функция чтения lock-name и метод для нее. Этот метод"
" присоединен к классу lock и наследуется как null-lock, так и simple-lock,"
" поскольку оба они построены на lock."

#: ./en/ch03.md:261
msgid ""
"<pre>\n"
"(lock-name *null-lock*)              ;=>\"Null lock\"\n"
"(lock-name *simple-lock*)            ;=>\"Simple lock\"\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:264
msgid ""
"We also have a reader generic function named lock-owner, and a corresponding "
"writer generic function named (setf lock-owner). Each of these accessors has "
"a method for it attached to the simple-lock class. \n"
"We can use these accessors on instances of simple-lock."
msgstr ""
"У нас также есть обобщенная функция чтения с именем lock-owner и"
" соответствующая обобщенная функция записи с именем (setf lock-owner). У"
" каждого из этих аксессуаров есть метод для него, прикрепленный к классу"
" simple-lock.\n"
"Мы можем использовать эти аксессуары на экземплярах simple-lock."

#: ./en/ch03.md:266
msgid ""
"In the following example, we use lock-owner on the newly created simple "
"lock, which shows that the initial value of the owner slot is nil. We then "
"call the writer generic function to set the value of the slot to 3401, and "
"call the reader again to see that the value is indeed 3401."
msgstr ""
"В следующем примере мы используем lock-owner для вновь созданной простой"
" блокировки, которая показывает, что начальное значение слота owner равно"
" nil. Затем мы вызываем универсальную функцию записи, чтобы установить"
" значение слота равным 3401, и снова вызываем считыватель, чтобы убедиться,"
" что значение действительно равно 3401."

#: ./en/ch03.md:273
msgid ""
"<pre>\n"
"(lock-owner *simple-lock*)                    ;=>NIL\n"
"(setf (lock-owner *simple-lock*) 3401)        ;=>3401\n"
"(lock-owner *simple-lock*)                    ;=>3401\n"
"</pre>\n"
"We cannot use lock-owner or (setf lock-owner) on instances of null-lock. No "
"method is attached to null-lock for these generic functions, and null-lock "
"does not inherit any method for them. Therefore, if we try to use these "
"generic functions on an instance of null-lock, CLOS will signal the \"no "
"applicable method\" error."
msgstr ""
"<pre>\n"
"(lock-owner *simple-lock*)                    ;=>NIL\n"
"(setf (lock-owner *simple-lock*) 3401)        ;=>3401\n"
"(lock-owner *simple-lock*)                    ;=>3401\n"
"</pre>\n"
"Мы не можем использовать lock-owner или (setf lock-owner) для экземпляров"
" null-lock. Ни один метод не привязан к null-lock для этих обобщенных"
" функций, и null-lock не наследует для них никаких методов. Поэтому, если мы"
" попытаемся использовать эти обобщенные функции с экземпляром null-lock, CLOS"
" выдаст сообщение об ошибке \"нет применимого метода\"."

#: ./en/ch03.md:278
msgid ""
"<pre>\n"
"(lock-owner *null-lock*) \n"
"ERROR: No applicable method for LOCK-OWNER \n"
"for the argument #<NULL-LOCK 802335> "
msgstr ""

#: ./en/ch03.md:283
msgid ""
"(setf (lock-owner *null-lock*) 3401) \n"
"ERROR: No applicable method for (SETF LOCK-OWNER) \n"
"for the argument #<NULL-LOCK 802335> \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:286
msgid ""
"### Querying a Lock for Its Type \n"
"Now that we have instances, we can demonstrate that CLOS is neatly "
"integrated with the existing Common Lisp type hierarchy. The names of all "
"classes are Common Lisp type specifiers, so you can use type-of and typep to "
"query a Lisp object about its type. The type of an instance is its class. "
msgstr ""
"### ### Запрос блокировки(Lock) о ее типе \n\n"
"Теперь, когда у нас есть экземпляры, мы можем продемонстрировать, что CLOS"
" аккуратно интегрирован с существующей иерархией типов Common Lisp. Имена"
" всех классов являются общими спецификаторами типов Lisp, поэтому вы можете"
" использовать type-of и type для запроса объекта Lisp о его типе. Тип"
" экземпляра - это его класс."

#: ./en/ch03.md:290
msgid ""
"<pre>\n"
"(type-of *null-lock*)                          ;NULL-LOCK\n"
"(type-of *simple-lock*)                        ;SIMPLE-LOCK"
msgstr ""

#: ./en/ch03.md:297
msgid ""
"(typep *simple-lock* 'simple-lock)             ;T\n"
"(typep *simple-lock* 'lock)                    ;T\n"
"(typep *simple-lock* 't)                       ;T\n"
"</pre>\n"
"We use typep as shown to indicate that the lock `*simple-lock*` is not only "
"of the type simple-lock, but it is also of the type lock and the type t. \n"
"This is entirely analogous to how typep works for other Common Lisp type "
"specifiers, when one type is a subtype of another. For example, an object of "
"type integer is also of type number, because integer is a subtype of number. "
"Similarly, all objects are of type t."
msgstr ""
"(typep *simple-lock* 'simple-lock)             ;T\n"
"(typep *simple-lock* 'lock)                    ;T\n"
"(typep *simple-lock* 't)                       ;T\n"
"</pre>\n"
"Мы используем показанный typep, чтобы указать, что блокировка `*simple-lock*`"
" относится не только к типу simple-lock, но также к типу lock и типу t.\n"
"Это полностью аналогично тому, как работает type для других спецификаторов"
" типов Common Lisp, когда один тип является подтипом другого. Например,"
" объект типа integer также имеет тип number, поскольку integer является"
" подтипом number. Аналогично, все объекты относятся к типу t."

#: ./en/ch03.md:299
msgid ""
"The significance of this is related to inheritance. The instance `*simple-"
"lock*` is of the types simple-lock, lock, and t. That means that each of "
"those classes can contribute structure and behavior to `*simple-lock*`. So "
"we can use typep to find out whether the behavior of an instance is affected "
"by a particular class."
msgstr ""
"Значение этого связано с наследованием. Экземпляр `*simple-lock*` относится к"
" типам simple-lock, lock и т. Д. Это означает, что каждый из этих классов"
" может вносить свой вклад в структуру и поведение `*simple-lock*`. Таким"
" образом, мы можем использовать typep, чтобы выяснить, влияет ли конкретный"
" класс на поведение экземпляра."

#: ./en/ch03.md:301
msgid ""
"Similarly, to find out the relationship of one class to another, we can use "
"subtypep with classes:"
msgstr ""
"Точно так же, чтобы узнать отношение одного класса к другому, мы можем"
" использовать subtypep с классами:"

#: ./en/ch03.md:307
msgid ""
"<pre>\n"
"(subtypep 'simple-lock 'lock)                  ;T   T\n"
"(subtypep 'null-lock   'lock)                  ;T   T\n"
"(subtypep 'null-lock   'simple-lock)           ;NIL T\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:309
msgid ""
"The results confirm what we already knew: simple-lock is a subtype of lock, "
"null-lock is a subtype of lock, and null-lock is not a subtype of simple-"
"lock."
msgstr ""
"Результаты подтверждают то, что мы уже знали: простая блокировка — это подтип"
" блокировки, нулевая блокировка — подтип блокировки, а нулевая блокировка —"
" не подтип простой блокировки."

#: ./en/ch03.md:311
msgid ""
"The first value of subtypep tells whether the first argument is a subtype of "
"the second argument. The second value of subtypep indicates the certainty of "
"the first value. If the relationship between the two types is not known, the "
"values will be nil nil. This can happen for Common Lisp types, but it can "
"never happen for two classes. When both arguments to subtypep are class "
"names, the second value will always be t."
msgstr ""
"Первое значение subtypep указывает, является ли первый аргумент подтипом"
" второго аргумента. Второе значение subtypep указывает на достоверность"
" первого значения. Если взаимосвязь между двумя типами неизвестна, значения"
" будут равны nil nil. Это может случиться для типов Common Lisp, но никогда"
" не может случиться для двух классов. Когда оба аргумента subtypep являются"
" именами классов, вторым значением всегда будет t."

#: ./en/ch03.md:313
msgid "## 3.4 DEFINING THE INTERFACE-GENERIC FUNCTIONS "
msgstr "## 3.4 ОПРЕДЕЛЕНИЕ ОБОБЩЕННЫХ-ИНТЕРФЕЙСНЫХ ФУНКЦИЙ "

#: ./en/ch03.md:315
msgid ""
"We have already completed one part of the interface, by giving clients a "
"means of creating new locks. Each kind of lock has its own constructor for "
"creating a new lock. The constructor make-simple-lock creates a simple lock "
"and make-null-lock creates a null lock. Constructors are ordinary functions, "
"not generic functions. "
msgstr ""
"Мы уже завершили одну часть интерфейса, предоставив клиентам возможность"
" создавать новые блокировки. У каждого типа блокировки есть свой конструктор"
" для создания новой блокировки. Конструктор make-simple-lock создает простую"
" блокировку, а make-null-lock создздает null-lock блокировку. Конструкторы —"
" это обычные функции, а не обобщенные функции."

#: ./en/ch03.md:317
msgid ""
"Once a lock has been created, it must support two locking operations: seize "
"and release. We shall implement these operations as generic functions."
msgstr ""
"После того, как блокировка создана, она должна поддерживать две операции"
" блокировки: захват и освобождение. Мы будем реализовывать эти операции как"
" обобщенные функции."

#: ./en/ch03.md:319
msgid "### Using defgeneric to Document the Interface"
msgstr "### Использование defgeneric для документирования интерфейса"

#: ./en/ch03.md:321
msgid ""
"We can document the interface of each generic function by using a defgeneric "
"form. The interface comprises three concepts, each of which is represented "
"in the defgeneric form:"
msgstr ""
"Мы можем задокументировать интерфейс каждой обобщенной функции, используя"
" форму defgeneric. Интерфейс состоит из трех концептов, каждый из которых"
" представлен в родовой форме:"

#: ./en/ch03.md:327
msgid ""
"| Interface         | Described by defgeneric      |\n"
"|-------------------|------------------------------|\n"
"|Expected arguments | Parameters in the lambda-list|\n"
"|What it does       | The documentation string     |\n"
"|Returned values    | The documentation string     |"
msgstr ""
"| Интерфейс                    | Описано defgeneric                |\n"
"|--------------------------------------|--------------------------------------"
"--------|\n"
"|Ожидаемые аргументы   | Параметры в лямбда-списке  |\n"
"|Что он делает                 | Строка документации            |\n"
"|Возвращаемые значения | Строка документации            |"

#: ./en/ch03.md:329
msgid ""
"You can use defgeneric to document the generic function for the benefit of "
"programmers who call it or define additional methods for it. A defgeneric "
"form also sets guidelines for the generic function that must be followed by "
"any future extensions to the program. "
msgstr ""
"Вы можете использовать defgeneric для документирования обобщенной функции в"
" интересах программистов, которые вызывают ее или определяют для нее"
" дополнительные методы. Форма defgeneric также устанавливает рекомендации для"
" обобщенной функции, которым должны следовать любые будущие расширения"
" программы."

#: ./en/ch03.md:331
msgid ""
"A defgeneric form describes the generic function as a whole. The defgeneric "
"forms for seize and release provide English text in the documentation string "
"describing the overall purpose of the generic function. The documentation "
"string is not a functional piece of the program; it does not actually do "
"anything. However, without that documentation, people who wanted to read the "
"code and learn how a program works would have to look at the method "
"definitions and try to discern the overall purpose of the generic function "
"based on the set of methods."
msgstr ""
"Форма defgeneric описывает обобщенную функцию в целом. Формы defgeneric для"
" seize(захвата) и release(освобождения) предоставляют текст на английском"
" языке в строке документации, описывающей общую цель обобщенной функции."
" Строка документации не является функциональной частью программы; на самом"
" деле она ничего не делает. Однако без этой документации людям, которые"
" хотели бы прочитать код и узнать, как работает программа, пришлось бы"
" смотреть на определения методов и пытаться понять общее назначение"
" обобщенной функции на основе набора методов."

#: ./en/ch03.md:339
msgid ""
"<pre>\n"
"(defgeneric seize (lock) \n"
"   (:documentation \n"
"    \"Seizes the lock. \n"
"     Returns the lock when the operation succeeds. \n"
"     Some locks simply wait until they can succeed, while \n"
"     other locks return NIL if they fail.\")) "
msgstr ""

#: ./en/ch03.md:348
msgid ""
"(defgeneric release (lock Soptional failure-mode) \n"
"   (:documentation \n"
"    \"Releases the lock if it is currently owned by this process. \n"
"     Returns T if the operation succeeds. \n"
"     If unsuccessful and failure-mode is :no-error, returns NIL. \n"
"     If unsuccessful and failure-mode is :error, signals an error. \n"
"     The default for failure-mode is :no-error.\"))\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:350
msgid ""
"In Lisp, a lambda-list is the portion of a function that specifies names for "
"the parameters of the function. The defgeneric form for seize specifies one "
"required parameter (whose name is lock), and the defgeneric form for release "
"specifies one required parameter named lock and one optional parameter named "
"failure-mode."
msgstr ""
"В Лиспе лямбда-список — это часть функции, которая указывает имена для"
" параметров функции. Форма defgeneric для seize указывает один обязательный"
" параметр (с именем lock), а форма defgeneric для release указывает один"
" обязательный параметр с именем lock и один необязательный параметр с именем"
" failure-mode."

#: ./en/ch03.md:353
msgid ""
"The documentation strings look somewhat awkward as shown, but there is a "
"reason for aligning them at the left margin. If we indented them, the "
"documentation function would indent them, which is not what we want. It is "
"not necessary to align the first line of a documentation string at the left "
"margin, but we choose that style for strings that are \n"
"longer than one line, just to be consistent with the lines that follow."
msgstr ""
"Строки документации выглядят несколько неуклюже, как показано, но есть"
" причина выровнять их по левому краю. Если бы мы сделали для них отступ,"
" функция документирования сделала бы для них отступ, а это не то, что нам"
" нужно. Нет необходимости выравнивать первую строку строки документации по"
" левому краю, но мы выбираем этот стиль для строк, которые"
"длиннее одной строки, просто чтобы соответствовать следующим строкам."

#: ./en/ch03.md:355
msgid "### Creation of a Generic Function"
msgstr "### Создание обобщенной функции"

#: ./en/ch03.md:357
msgid ""
"A defgeneric form creates a new generic function. Using defgeneric is not "
"the only way to define a generic function. The other way is to define a "
"method. If you define a method for a generic function and the generic "
"function itself does not yet exist, CLOS automatically creates it. The "
"lambda-list of the generic function is derived from the lambda-list of the "
"method. You can use defgeneric later to specify the lambda-list of the "
"generic function, a documentation string, and any other options; CLOS "
"modifies the existing generic function according to your new definition."
msgstr ""
"Форма defgeneric создает новую обобщённую функцию. Использование defgeneric —"
" не единственный способ определить обобщенную функцию. Другой способ —"
" определить метод. Если вы определяете метод для обобщенной функции, а сама"
" эта функция еще не существует, CLOS автоматически создает ее. Лямбда-список"
" обобщенной  функции получается из лямбда-списка метода. Вы можете"
" использовать defgeneric позже, чтобы указать лямбда-список обобщенной"
" функции, строку документации и любые другие параметры; CLOS модифицирует"
" существующую обобщенную функцию в соответствии с вашим новым определением."

#: ./en/ch03.md:359
msgid ""
"Although is not necessary to document the interface explicitly by means of "
"defgeneric, as we do here, doing so often makes it easier for other people "
"to learn how your program works, and provides guidelines for programmers who "
"wish to extend the program."
msgstr ""
"Хотя нет необходимости явно документировать интерфейс с помощью defgeneric,"
" как мы делаем здесь, это часто облегчает другим людям изучение того, как"
" работает ваша программа, и дает рекомендации для программистов, которые"
" хотят расширить программу."

#: ./en/ch03.md:361
msgid "### Establishment of the Parameter Pattern"
msgstr "### Создание шаблона параметра"

#: ./en/ch03.md:363
msgid ""
"A defgeneric form establishes a parameter pattern that must be followed by "
"all methods for that generic function. Thus, the lambda-list of a defgeneric "
"form is a functional piece of the program. CLOS requires that the lambda-"
"lists of all methods and the defgeneric form for a generic function have the "
"same \"shape\" or be \"congruent.\" The lambda-lists must have the same "
"number of required parameters and the same number of optional parameters. "
"Special rules state what congruence means for skey parameters. For full "
"details, see \"Congruent Lambda-Lists,\" page 132. "
msgstr ""
"Форма  defgeneric определяет шаблон параметра, которому должны следовать все"
" методы этой обобщенной функции. Таким образом, лямбда-список формы"
" defgeneric является функциональной частью программы. CLOS требует, чтобы"
" лямбда-списки всех методов и форма определения обобщенной функции имели"
" одинаковую «форму» или были «конгруэнтны». Лямбда-списки должны иметь"
" одинаковое количество обязательных параметров и одинаковое количество"
" необязательных параметров. Специальные правила определяют, что означает"
" конгруэнтность для ключевых параметров(&key). Подробности см. в разделе"
" «Конгруэнтные лямбда-списки», стр. 132."

#: ./en/ch03.md:365
msgid "### Naming Issues "
msgstr "### Проблемы Именования"

#: ./en/ch03.md:367
msgid ""
"The names of the parameters of a generic function should imply the class of "
"objects on which the generic function can operate. Here, we use the name "
"\"lock\" to indicate that the generic function can be used on any lock. It "
"happens that \"lock\" is also the name of a class, but there is no "
"requirement that parameter names of a generic function be class names. "
msgstr ""
"Имена параметров обобщенной функции должны подразумевать класс объектов, с"
" которыми может работать обобщенная функция. Здесь мы используем имя"
" \"lock\", чтобы указать, что обобщенную функцию можно использовать для любой"
" блокировки. Бывает, что «lock» также является именем класса, но нет"
" требования, чтобы имена параметров универсальной функции были именами"
" классов."

#: ./en/ch03.md:369
msgid ""
"The same guideline applies to the name of a generic function. The name "
"should tell us something about the function's purpose and should answer the "
"question, \"How generic is it?\" For example, we might later add a generic "
"function to the protocol for resetting a lock, which would be useful for "
"debugging; a process could reset the lock owned by another process. The name "
"\"reset-lock\" would be better than merely \"reset\", which is too general. "
"One potential pitfall of an overly general name for a generic function is "
"related to the requirement that all methods for a generic function must have "
"congruent lambda-lists. If we name a generic function \"reset\" and several "
"different programs want to write methods to reset different kinds of "
"devices, it is likely that the different programs will want to establish "
"different argument patterns, which is not allowed. "
msgstr ""
"То же самое относится и к имени обобщенной функции. Имя должно что-то"
" говорить нам о назначении функции и должно отвечать на вопрос: «Насколько"
" она общая/универсальна?» Например, позже мы могли бы добавить в протокол"
" обобщенную функцию для сброс(resetting) блокировки, что было бы полезно для"
" отладки; процесс может сбросить блокировку, принадлежащую другому процессу."
" Название «reset-lock» было бы лучше, чем просто «reset», которое носит"
" слишком общий характер. Одна потенциальная ловушка слишком общего имени для"
" обобщенной  функции связана с требованием, чтобы все методы для обобщенной "
" функции имели конгруэнтные лямбда-списки. Если мы назовем обобщенную функцию"
" \"reset\", и несколько разных программ захотят написать методы для сброса"
" различных типов устройств, вполне вероятно, что разные программы захотят"
" установить разные шаблоны аргументов, что недопустимо."

#: ./en/ch03.md:371
msgid "### The Locking Protocol"
msgstr "### Протокол блокировки"

#: ./en/ch03.md:374
msgid ""
"A generic function defines the interface of a single operation. This is a "
"valuable concept in the initial design phase, because it helps you focus on "
"the interface while leaving the details of the implementation until later. "
"It is also valuable during the maintenance of the program. A set of "
"defgeneric forms appearing at the beginning of a program can go a \n"
"long way toward documenting the roles of the individual pieces of the "
"program."
msgstr ""
"Обобщенная функция определяет интерфейс одной операции. Это ценная концепция"
" на начальной фазе проектирования, потому что она помогает вам"
" сосредоточиться на интерфейсе, оставляя детали реализации на потом. Это"
" также ценно во время обслуживания программы. Набор отдельных форм,"
" появляющихся в начале программы, может иметь большое значение для"
" документирования ролей отдельных фрагментов программы."

#: ./en/ch03.md:378
msgid ""
"The generic functions taken together can be called a protocol. A protocol "
"encompasses the complete behavior of the objects in the program. For "
"example, the basis of the locking protocol is as follows: \n"
"\t    >    There must be a means for creating new locks, and all existing "
"locks must support\n"
"\t    >    the seize and release operations."
msgstr ""
"Обобщенные функции, взятые вместе, можно назвать протоколом. Протокол"
" охватывает полное поведение объектов в программе. Например, основание"
" протокола блокировки заключается в следующем:"
"\t>    Должны быть средства для создания новых блокировок, и все существующие"
" блокировки должны поддерживать\n"
"\t>    операции захвата(seize) и освобождения(release)."

#: ./en/ch03.md:380
msgid ""
"The locking protocol must convey more information on the semantics of each "
"operation: its arguments, what it does, and its returned values. For the "
"generic functions, this information is contained in the individual "
"defgeneric forms. "
msgstr ""
"Протокол блокировки должен предоставить больше информации о семантике каждой"
" операции: ее аргументы, что она делает, и её возвращаемые значения. Для"
" обобщенных функций эта информация содержится в отдельных формах defgeneric."

#: ./en/ch03.md:382
msgid ""
"The idea of a protocol gives us another perspective on an application "
"program. The question \"What is a lock?\" can be answered with \"A lock is "
"an object that obeys the locking protocol.\" We now have an operational "
"definition of locks. This perspective allows for a natural and accurate "
"description of a null lock: \"A null lock obeys the locking protocol, "
"without actually protecting anything against simultaneous access.\" Note "
"that an instance of the basic class lock is not a lock by this definition, "
"because it does not obey the locking protocol."
msgstr ""
"Идея протокола дает нам еще один взгляд на прикладную программу. Вопрос \"Что"
" такое блокировка?\" Можно ответить с помощью «Блокировка(lock) - это объект,"
" который подчиняется протоколу блокировки». Теперь у нас есть оперативное"
" определение блокировок. Эта перспектива допускает естественное и точное"
" описание null lock(нулевой блокировки): «Нулевая блокировка подчиняется"
" протоколу блокировки, не защищая ничего от одновременного доступа». Обратите"
" внимание, что экземпляр класса базовой блокировки не является блокировкой по"
" этому определению, поскольку он не подчиняется протоколу блокировки."

#: ./en/ch03.md:384
msgid ""
"When we define locks by the protocol that they obey, we are taking an "
"external point of view. We could take an internal point of view by defining "
"a lock as \"an instance of any class that includes the class lock.\" Each of "
"these perspectives is valid and useful in its own right. Software developers "
"who use locks benefit by the external point of view. The implementor of "
"locks takes the internal point of view when defining the classes and methods "
"that constitute the locking program. However, the implementor cannot neglect "
"the external point of view, because the implementation must ensure that the "
"locks follow the advertised locking protocol."
msgstr ""
"Когда мы определяем блокировки по протоколу, которому они подчиняются, мы"
" используем внешнюю точку зрения. Мы могли бы взять внутреннюю точку зрения,"
" определив блокировку как «экземпляр любого класса, который включает в себя"
" класс блокировки(lock)». Каждая из этих перспектив является действительной и"
" полезной сама по себе. Разработчики программного обеспечения, которые"
" используют блокировки выгоды от внешней точки зрения. Реализатор Блокриовок"
" берет на себя внутреннюю точку зрения при определении классов и методов,"
" которые составляют программу блокировки. Однако реализатор не может"
" пренебрегать внешней точкой зрения, поскольку реализация должна"
" гарантировать, что блокировки следуют за рекламируемым протоколом блокировки."

#: ./en/ch03.md:386
msgid ""
"We are discussing not a formalized concept of a protocol, but rather an "
"informal notion that programmers find useful when designing and describing "
"object-oriented programs. CLOS does not include any mechanism for enforcing "
"protocols."
msgstr ""
"Мы обсуждаем не формализованную концепцию протокола, а скорее неформальное"
" представление о том, что программисты считают полезным при разработке и"
" описании объектно-ориентированных программ. Clos не включает в себя"
" какой-либо механизм для обеспечения соблюдения протоколов."

#: ./en/ch03.md:388
msgid "## 3.5 DEFINING THE IMPLEMENTATION—METHODS"
msgstr "## 3.5 ОПРЕДЕЛЕНИЕ РЕАЛИЗАЦИИ — МЕТОДЫ"

#: ./en/ch03.md:391
msgid ""
"In this section, we define the methods for null locks and simple locks. We "
"discuss methods in detail, including when a method is called, what arguments "
"it receives, and how a method can provide a default value for an argument. "
"Throughout this discussion, keep in mind the distinction between the terms "
"argument and parameter. You provide arguments to a Lisp function when you "
"call it, and you name the parameters of the function when you define it. In "
"the body of a function, you can refer to an argument by using the "
"corresponding parameter. Thus, a parameter is a variable that is bound to an "
"argument during the execution of a function. For details on the different "
"kinds of parameters, see Steele's \n"
"Common LISP: The Language, pages 59-61."
msgstr ""
"В этом разделе мы определяем методы для null и simple блокировок. Мы подробно"
" обсуждаем методы, в том числе когда вызывается метод, какие аргументы он"
" получает и как метод может предоставить значение по умолчанию для аргумента."
" На протяжении всего обсуждения помните о различиях между терминами"
" «аргумент» и «параметр». Вы предоставляете аргументы лисп-функции при ее"
" вызове и именуете параметры функции при ее определении. В теле функции вы"
" можете ссылаться на аргумент, используя соответствующий параметр. Таким"
" образом, параметр — это переменная, которая привязывается к аргументу во"
" время выполнения функции. Подробнее о различных типах параметров см."
"Steele, Common LISP: Язык, страницы 59-61."

#: ./en/ch03.md:393
msgid ""
"Generic functions and methods use the same terminology. The lambda-list of a "
"defgeneric form names the parameters of the generic function, and the lambda-"
"list of a defmethod form names the parameters of the method. "
msgstr ""
"Обобщенные функции и методы используют ту же терминологию. Лямбда-список"
" формы defgeneric именует параметры обобщенной функции, а лямбда-список формы"
" defmethod именует параметры метода."

#: ./en/ch03.md:395
msgid "### Methods for Null Locks"
msgstr "### Методы нулевых блокировок(Null Locks)"

#: ./en/ch03.md:397
msgid ""
"The purpose of implementing null locks is to disable locking in a program "
"that performs locking operations. The program follows its normal seizing and "
"releasing routine, without a need for a special \"debug mode\" that turns "
"locking off in exceptional circumstances. The methods exist so that a null "
"lock can be used wherever a program expects a lock."
msgstr ""
"Цель реализации нулевых блокировок — отключить блокировку в программе,"
" выполняющей операции блокировки. Программа выполняет свою обычную процедуру"
" захвата и освобождения без необходимости в специальном «режиме отладки/debug"
" mode», который отключает блокировку в исключительных обстоятельствах. Методы"
" существуют для того, чтобы нулевую блокировку можно было использовать везде,"
" где программа ожидает блокировку."

#: ./en/ch03.md:399
msgid ""
"The methods for the locking operations on null locks are simple. They are "
"primary methods and they do all the work of the generic functions they "
"implement. Each method adheres to the interface of its generic function. "
"Since these methods do not actually seize or release anything, they are "
"always successful and they always return the value indicating success."
msgstr ""
"Методы операций блокировки нулевых блокировок просты. Это первичные методы, и"
" они выполняют всю работу обобщенных функций, которые они реализуют. Каждый"
" метод придерживается интерфейса своей обобщенной функции. Поскольку эти"
" методы на самом деле ничего не захватывают и не освобождают, они всегда"
" успешны и всегда возвращают значение, указывающее на успех."

#: ./en/ch03.md:403
msgid ""
"<pre>\n"
"(defmethod seize ((l null-lock)) \n"
"   l)                                   ;return lock, no waiting "
msgstr ""

#: ./en/ch03.md:408
msgid ""
"(defmethod release ((l null-lock) &optional failure-mode) \n"
"   (declare (ignore failure-mode))      ;never fails for null locks \n"
"   t) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:410
msgid "### A Method's Lambda-List "
msgstr "### Лямбда-список метода"

#: ./en/ch03.md:412
msgid ""
"In an object-oriented program, it is important to understand the scope of a "
"method. When is this method applicable? The lambda-list states the method's "
"scope by using specialized parameters, which attach the method to one or "
"more classes. A method is applicable when the arguments to the generic "
"function fulfill the requirements of the specialized parameters in the "
"lambda-list."
msgstr ""
"В объектно-ориентированной программе важно понимать область действия метода."
" Когда применим этот метод? Лямбда-список указывает область действия метода с"
" помощью специализированных параметров, которые связывают метод с одним или"
" несколькими классами. Метод применим, когда аргументы обобщенной функции"
" удовлетворяют требованиям специализированных/указанных параметров в"
" лямбда-списке."

#: ./en/ch03.md:414
msgid ""
"Figure 3.2 shows the lambda-list of the release method, which has one "
"specialized parameter."
msgstr ""
"На рис. 3.2 показан лямбда-список метода release, который имеет один"
" специализированный параметр."

#: ./en/ch03.md:418
msgid ""
"![Figure 3.2: Specialized parameter in a lambda-list.](images/f03-02.jpg)\n"
"**Figure 3.2: Specialized parameter in a lambda-list.**"
msgstr ""
"![Рисунок 3.2: Специализированный параметр в"
" лямбда-списке.](images/f03-02.jpg)"
"**Рисунок 3.2: Специализированный параметр в лямбда-списке.**"

#: ./en/ch03.md:420
msgid ""
"The lambda-list of a method is an ordinary lambda-list with one difference. "
"It distinguishes between two kinds of parameters:"
msgstr ""
"Лямбда-список метода — это обычный лямбда-список с одним отличием. Он"
" различает два типа параметров:"

#: ./en/ch03.md:424
msgid ""
"*   A specialized parameter indicates the applicability of the method by \n"
"stating the class of the argument for which this method applies. A "
"specialized parameter is a list containing a variable and a class name. The "
"parameter is said to be specialized on that class. You can specialize any of "
"the required parameters, but not &optional, &key, or &rest parameters. \n"
"*   An ordinary parameter does not indicate the applicability of the method; "
"it simply gives a variable to be bound to the argument to the generic "
"function."
msgstr ""
"* Специализированный параметр указывает на применимость метода, указывая"
" класс аргумента, для которого применяется этот метод. Специализированный"
" параметр — это список, содержащий переменную и имя класса. Говорят, что"
" параметр специализируется на этом классе. Вы можете специализировать любой"
" из обязательных параметров, но не &optional, &key или &rest параметры."
"* обычный параметр не указывает на применимость метода; он просто дает"
" переменную, которая должна быть привязана к аргументу обобщенной функции."

#: ./en/ch03.md:426
msgid ""
"Although a specialized parameter has the same syntax as a defaulted "
"parameter, there is no ambiguity. In methods, required parameters may be "
"specialized but may not have default values. Optional parameters may not be "
"specialized but may have default values."
msgstr ""
"Хотя специализированный параметр имеет тот же синтаксис, что и параметр по"
" умолчанию, двусмысленности нет. В методах обязательные параметры могут быть"
" специализированными, но могут не иметь значений по умолчанию. Необязательные"
" параметры не могут быть специализированными, но могут иметь значения по"
" умолчанию."

#: ./en/ch03.md:428
msgid "### The Applicability of a Method"
msgstr "### Применимость метода"

#: ./en/ch03.md:430
msgid ""
"When a generic function is called, CLOS selects the set of applicable "
"methods. A method is applicable if the arguments to the generic function "
"match that method's specialized parameters. For an argument to match, it "
"must be of the type indicated by the class. This includes instances of the "
"class itself and instances of classes built on that class (subclasses)."
msgstr ""
"При вызове обобщенной функции CLOS выбирает набор применимых методов. Метод"
" применим, если аргументы обобщенной функции соответствуют специализированным"
" параметрам этого метода. Чтобы аргумент совпадал, он должен иметь тип,"
" указанный классом параметра. Сюда входят экземпляры самого класса и"
" экземпляры классов, созданных на основе этого класса (подклассы)."

#: ./en/ch03.md:432
msgid ""
"In the lambda-list in Fig. 3.2, only the first parameter is specialized. The "
"parameter specializer is the class named null-lock, indicating that the "
"method is applicable when the first argument to the generic function is an "
"instance of null-lock or some class built on it. In other words, the "
"following expression must be true:"
msgstr ""
"В лямбда-списке на рис. 3.2 специализированным является только первый"
" параметр. Специализирующим параметром является класс с именем null-lock,"
" указывающий, что метод применим, когда первый аргумент обобщенной функции"
" является экземпляром null-lock или некоторым построенным на нем классом."
" Другими словами, следующее выражение должно быть истинным:"

#: ./en/ch03.md:436
msgid ""
"<pre>\n"
"(typep argument 'null-lock) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:438
msgid ""
"Sometimes we speak of a class \"inheriting a method.\" This is a natural way "
"to describe the fact that an instance can use a method that is attached to a "
"superclass of its class. This model allows us to picture a link between a "
"class and a method attached to that class."
msgstr ""
"Иногда мы говорим о классе, «наследующем метод». Это естественный способ"
" описать тот факт, что экземпляр может использовать метод, присоединенный к"
" суперклассу своего класса. Эта модель позволяет нам изобразить связь между"
" классом и методом, присоединенным к этому классу."

#: ./en/ch03.md:440
msgid ""
"It is important to keep in mind that a method can contain any number of "
"specialized parameters. A method can have links to more than one class; it "
"is linked to all the classes that are used as parameter specializers. We "
"discuss this style of programming in \"Multi-Methods,\" page 75. For methods "
"that have more than one specialized parameter, the model of \"method "
"applicability\" is more appropriate than is the model of \"inheriting a "
"method.\" We can express the rule of method applicability in one sentence: "
msgstr ""
"Важно иметь в виду, что метод может содержать любое количество"
" специализированных параметров. Метод может иметь ссылки более чем на один"
" класс; он связан со всеми классами, которые используются в качестве"
" специализаторов для параметров. Мы обсуждаем этот стиль программирования в"
" разделе «Мультиметоды» на стр. 75. Для методов, которые имеют более одного"
" специализированного параметра, модель «применимости метода» более подходит,"
" чем модель «наследования метода». Мы можем выразить правило применимости"
" метода в одном предложении:"

#: ./en/ch03.md:445
msgid ""
"|**Rule of method applicability:**"
"                                                \n"
"|----------------------------------------------------------------------------"
"-----\n"
"|A method is applicable if each of its specialized parameters is satisfied "
"by the\n"
"|corresponding argument to the generic "
"function.                                 "
msgstr ""
"|**Правило применимости метода:**                       |\n"
"|-----------------------------------------------------------------------------"
"|\n"
"|Метод применим, если каждому из его специализированных параметров"
" удовлетворяет   |\n "
"|соответствующий аргумент обобщенной функции.                                "
"                             |"

#: ./en/ch03.md:447
msgid ""
"Many methods have only one specialized parameter. Accessor methods fall into "
"this category, as do all the methods we define in the locking program. We "
"shall continue to use the model of \"inheriting a method\" for methods that "
"have only one specialized parameter."
msgstr ""
"Многие методы имеют только один специализированный параметр. Методы доступа"
" попадают в эту категорию, как и все методы, которые мы определяем в"
" программе блокировки. Мы будем продолжать использовать модель «наследования"
" метода» для методов, имеющих только один специализированный параметр."

#: ./en/ch03.md:449
msgid "### The Arguments Passed to a Method "
msgstr "### Аргументы, передаваемые методу"

#: ./en/ch03.md:451
msgid ""
"When CLOS chooses the implementation of a generic function and calls the "
"methods, it passes all the arguments supplied to the generic function to "
"each method. The variables in the lambda-list are bound to the arguments. "
"Within the method body, you can use the variables bound to the objects by "
"using generic functions or ordinary functions to manipulate them."
msgstr ""
"Когда CLOS выбирает реализацию обобщенной функции и вызывает методы, она"
" передает все аргументы, предоставленные обобщенной функцией, каждому методу."
" Переменные в лямбда-списке привязаны к аргументам. В теле метода вы можете"
" использовать переменные, привязанные к объектам, используя обобщенные"
" функции или обычные функции для управления ими."

#: ./en/ch03.md:453
msgid ""
"For example, when release is called on an instance of null-lock, the method "
"we defined for release is called. The variable 1 is bound to the first "
"argument to the generic function, the lock."
msgstr ""
"Например, когда release вызывается для экземпляра null-lock, вызывается"
" метод, который мы определили для release. Переменная 1 привязана к первому"
" аргументу обобщенной функции, блокировке."

#: ./en/ch03.md:455
msgid ""
"The variable failure-mode is bound to the second argument. The method "
"chooses to ignore this variable, because it has no need to use it. Even "
"though the method does not use this argument, it must explicitly allow it by "
"including a parameter for it in the lambda-list. This is necessary because "
"the method receives all arguments passed to the generic function."
msgstr ""
"Переменная failure-mode привязана ко второму аргументу. Метод предпочитает"
" игнорировать эту переменную, поскольку в ней нет необходимости. Несмотря на"
" то, что метод не использует этот аргумент, он должен явно разрешить его,"
" включив для него параметр в лямбда-список. Это необходимо, потому что метод"
" получает все аргументы, переданные обобщенной функции."

#: ./en/ch03.md:457
msgid "### Locks and Processes"
msgstr "### Блокировки и процессы"

#: ./en/ch03.md:459
msgid ""
"Before defining the methods for simple locks, we need to discuss processes "
"further. Our example assumes that processes do not actually execute "
"concurrently, but rather are interleaved, as happens when a single time-"
"sliced processor is used."
msgstr ""
"Прежде чем определить методы для простых блокировок, нам нужно дальше"
" обсудить процессы. В нашем примере предполагается, что процессы на самом"
" деле не выполняются одновременно, а чередуются, как это происходит при"
" использовании одного процессора с квантованием времени."

#: ./en/ch03.md:461
msgid ""
"Since Common Lisp does not currently include functions for dealing with "
"processes, for the purposes of this example we assume three primitives that "
"support multiple processes in a shared address space. These primitives are "
"not part of CLOS or Common Lisp."
msgstr ""
"Поскольку Common Lisp в настоящее время не включает функции для работы с"
" процессами, для целей этого примера мы предполагаем три примитива, которые"
" поддерживают несколько процессов в общем адресном пространстве. Эти"
" примитивы не являются частью CLOS или Common Lisp."

#: ./en/ch03.md:466
msgid ""
"\t>  without-process-preemption &body body \n"
"\t>            The body of this special form runs without risk of the "
"process being preempted by\n"
"\t>            the scheduler. In other words, the body is an atomic "
"operation with respect to\n"
"\t>            process scheduling. "
msgstr ""
"\t>  without-process-preemption &body body \n"
"\t>           Тело этой специальной формы выполняется без риска прерывания"
" процесса планировщиком.\n"
"\t>           Другими словами, тело является атомарной операцией по отношению"
" к планированию процесса."

#: ./en/ch03.md:472
msgid ""
"\t>  process-wait reason function &rest arguments \n"
"\t>            This function is the primitive for waiting. The current "
"process waits until the\n"
"\t>            application of function to arguments returns non-nil. At that "
"time process-wait\n"
"\t>            returns the values of applying function to arguments. The "
"argument reason is a\n"
"\t>            string describing the reason for waiting."
msgstr ""
"\t>  process-wait reason function &rest arguments \n"
"\t>            This function is the primitive for waiting. The current "
"process waits until the\n"
"\t>            application of function to arguments returns non-nil. At that "
"time process-wait\n"
"\t>            returns the values of applying function to arguments. The "
"argument reason is a\n"
"\t>            string describing the reason for waiting. "
"\t>            Эта функция является примитивом для ожидания. Текущий процесс"
" ожидает, пока применение\n"
"\t>            функции к аргументам не вернет значение, отличное от нуля. В"
" это время process-wait возвращает\n"
"\t>            значения применения функции к аргументам. Аргумент"
" reason(Причина) — это строка, описывающая\n "
"\t>            причину ожидания."

#: ./en/ch03.md:476
msgid ""
"\t>  *current-process* \n"
"\t>            The value of this variable is an identifier of the process "
"that is currently\n"
"\t>            executing."
msgstr ""
"\t>  *current-process* \n"
"\t>               Значение этой переменной является идентификатором процесса,"
" который выполняется в \n"
"\t>               данный момент."

#: ./en/ch03.md:478
msgid ""
"We now define the macro setf-if, which we shall use in the seize and release "
"methods. The macro setf-if compares the value of a generalized variable to "
"an expected value. If these values are the same, setf-if sets the value of "
"the variable to a new value and returns t; otherwise, it does not change the "
"value and it returns nil. setf-if uses without-process-preemption to ensure "
"that the operations happen atomically, to ensure that another process cannot "
"change the variable between the time setf-if tests the variable and the time "
"it changes it."
msgstr ""
"Теперь мы определим макрос setf-if, который мы будем использовать в методах"
" seize(захвата) и release(освобождения). Макрос setf-if сравнивает значение"
" обобщенной переменной с ожидаемым значением. Если эти значения совпадают,"
" setf-if устанавливает значение переменной в новое значение и возвращает t; в"
" противном случае он не изменяет значение и возвращает nil. setf-if"
" использует without-process-preemption(без вытеснения процесса), чтобы"
" гарантировать, что операции происходят атомарно, чтобы гарантировать, что"
" другой процесс не сможет изменить переменную между временем, когда setf-if"
" проверяет переменную, и временем, когда он ее изменяет."

#: ./en/ch03.md:489
msgid ""
"<pre>\n"
";; If value of place is old-value, set it to new-value \n"
";; Return t if the setf worked, nil otherwise \n"
"(defmacro setf-if (place old-value new-value) \n"
"   `(without-process-preemption         ;do atomically \n"
"     (cond ((eql  ,place ,old-value) \n"
"            (setf ,place ,new-value) \n"
"            t) \n"
"           (t nil)))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:491
msgid ""
"Note that a real multiprocessing system would include its own definition for "
"a setf-if operation, which would no doubt be more efficient and would deal "
"better with order of evaluation issues."
msgstr ""
"Обратите внимание, что реальная многопроцессорная система будет включать"
" собственное определение операции setf-if, которая, несомненно, будет более"
" эффективной и лучше справится с вопросами порядка вычисления."

#: ./en/ch03.md:493
msgid "### Methods for Simple Locks "
msgstr "### Методы Simple Locks(простых блокировок)"

#: ./en/ch03.md:495
msgid ""
"First, we define check-for-mylock to check for the common mistake in which a "
"process tries to seize a lock it already owns. The following method for "
"check-for-my lock signals an error in this situation. We shall use check-for-"
"mylock in the seize method."
msgstr ""
"Во-первых, мы определяем check-for-mylock для проверки распространенной"
" ошибки, при которой процесс пытается захватить блокировку, которой он уже"
" владеет. Следующий метод проверки моей блокировки сигнализирует об ошибке в"
" этой ситуации. Мы будем использовать check-for-mylock в методе"
" seize(захвата)."

#: ./en/ch03.md:501
msgid ""
"<pre>\n"
"(defmethod check-for-mylock ((l simple-lock) process) \n"
"   (when (eql (lock-owner 1) process) \n"
"      (error \"Can't seize ~A because you already own it.\" 1))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:503
msgid ""
"The following seize method iterates with do until the setf-if succeeds. On "
"each iteration, setf-if determines whether the lock is free by using lock-"
"owner to find out if the owner slot is nil. If the lock is free, setf-if "
"sets its owner to the current process, thus seizing it. (This is done "
"atomically by setf-if.) If the lock is not free the first time around, "
"process-wait is called to wait until lock-owner returns nil, which indicates "
"that the lock is currently free. Then the setf-if form tries again."
msgstr ""
"Следующий метод захвата повторяется с do до тех пор, пока setf-if не"
" завершится успешно. На каждой итерации setf-if определяет, свободна ли"
" блокировка, используя lock-owner, чтобы узнать, равен ли слот владельца nil."
" Если блокировка свободна, setf-if устанавливает ее владельца на текущий"
" процесс, тем самым захватывая его. (Это делается атомарно с помощью"
" setf-if.) Если блокировка не свободна в первый раз, вызывается process-wait"
" для ожидания, пока владелец блокировки не вернет nil, что указывает на то,"
" что блокировка в данный момент свободна. Затем форма setf-if пытается снова."

#: ./en/ch03.md:513
msgid ""
"<pre>\n"
"(defmethod seize ((l simple-lock)) \n"
"   (check-for-mylock l *current-process*) \n"
"   (do () \n"
"       ((setf-if (lock-owner l) nil *current-process*)) \n"
"      (process-wait \"Seizing lock\" \n"
"                    #'(lambda () (null (lock-owner l))))) \n"
"   l) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:515
msgid ""
"Note that the body of the do is not necessary, because without it the end-"
"test itself would iterate repeatedly until the setf-if succeeds. The problem "
"is that the setf-if might use a good deal of machine time before it finally "
"succeeds. In contrast, using process-wait in the body of the do allows other "
"processes to run, and tries the setf-if only when it is likely to succeed."
msgstr ""
"Обратите внимание, что тело do не обязательно, потому что без него сам"
" end-test будет многократно повторяться до тех пор, пока setf-if не"
" завершится успешно. Проблема в том, что setf-if может использовать много"
" машинного времени, прежде чем, наконец, добьется успеха. Напротив,"
" использование process-wait в теле do позволяет запускать другие процессы и"
" пробует setf-if только тогда, когда есть вероятность успеха."

#: ./en/ch03.md:517
msgid ""
"The following release method uses setf-if as a convenient way to make sure "
"that the process trying to release the lock is the current owner of the "
"lock. If not, setf-if does not release the lock."
msgstr ""
"Следующий метод оrelease(свобождения) использует setf-if как удобный способ"
" убедиться, что процесс, пытающийся снять блокировку, является текущим"
" владельцем блокировки. В противном случае setf-if не освобождает блокировку."

#: ./en/ch03.md:526
msgid ""
"<pre>\n"
"(defmethod release ((l simple-lock) \n"
"                    &optional (failure-mode :no-error)) \n"
"   (or (setf-if (lock-owner l) *current-process* nil) \n"
"       (ecase failure-mode \n"
"         (:no-error nil) \n"
"         (:error (error \"~A is not owned by this process\" l))))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:528
msgid "### Defaulting Optional Parameters of Methods "
msgstr "### Установка необязательных(Optional) параметров методов по умолчанию"

#: ./en/ch03.md:530
msgid ""
"The lambda-list of the release method for simple-lock gives a default value "
"for the optional parameter failure-mode. A method lambda-list may provide "
"default values for any optional parameters, but not for required parameters. "
"The defgeneric form may not provide a default value for any parameter in its "
"lambda-list. "
msgstr ""
"Лямбда-список метода release для simple-lock(простой блокировки) дает"
" значение по умолчанию для необязательного параметра failure-mode(режим"
" отказа). Лямбда-список метода может предоставлять значения по умолчанию для"
" любых необязательных параметров, но не для обязательных параметров. Форма"
" defgeneric может не предоставлять значение по умолчанию для любого параметра"
" в своем лямбда-списке."

#: ./en/ch03.md:532
msgid "##  3.6 SPECIALIZING THE BEHAVIOR OF LOCKS "
msgstr "## 3.6 СПЕЦИАЛИЗАЦИЯ ПОВЕДЕНИЯ БЛОКИРОВОК"

#: ./en/ch03.md:534
msgid ""
"At this point, we have completed the requirements of the locking "
"application. The interface is defined and the implementation is complete. In "
"this section, we add some final touches by specializing the printed "
"representation and description of locks. We describe the system-supplied "
"default methods for printing and describing objects and discuss why it is "
"often useful to provide a method to override the default behavior. We also "
"show how methods can have different roles and work together cooperatively. "
msgstr ""
"На данный момент мы выполнили требования приложения блокировки. Интерфейс"
" определен, и реализация завершена. В этом разделе мы добавляем некоторые"
" последние штрихи, специализируясь на печатном представлении и описании"
" блокировок. Мы опишем предоставляемые системой методы по умолчанию для"
" печати и описания объектов и обсудим, почему часто бывает полезно"
" предоставить метод для переопределения поведения по умолчанию. Мы также"
" показываем, как методы могут играть разные роли и совместно работать."

#: ./en/ch03.md:536
msgid "### Controlling How Locks Print"
msgstr "### Управление печатью объектов блокировок"

#: ./en/ch03.md:538
msgid ""
"The printed representations of null locks and simple locks look something "
"like this:"
msgstr ""
"Печатные представления нулевых блокировок и простых блокировок выглядят"
" примерно так:"

#: ./en/ch03.md:543
msgid ""
"<pre>\n"
"   #<NULL-LOCK 738592> \n"
"   #<SIMPLE-LOCK 220478>\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:545
msgid ""
"This output gives the type of the lock and the address in memory where the "
"instance is stored. However, it does not give the name of the lock. We might "
"decide to change the way that locks are printed so that the printed "
"representation of a lock contains its name as well as its type and address "
"in memory:"
msgstr ""
"Этот вывод дает тип блокировки и адрес в памяти, где хранится экземпляр."
" Однако он не дает имени блокировки. Мы можем решить изменить способ вывода"
" блокировок, чтобы напечатанное представление блокировки содержало его имя, а"
" также его тип и адрес в памяти:"

#: ./en/ch03.md:550
msgid ""
"<pre>\n"
"   #<NULL-LOCK \"Debug lock\" 738592> \n"
"   #<SIMPLE-LOCK \"Database lock\" 220478> \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:552
msgid ""
"CLOS specifies that Lisp always calls the generic function print-object "
"whenever one of the printing functions is called, such as print, prinl, "
"princ, write, format, and so on. This generic function offers a hook for "
"programs to use to control the printed representation of various classes of "
"objects."
msgstr ""
"CLOS указывает, что Lisp всегда вызывает обобщенную функцию print-object"
" всякий раз, когда вызывается одна из функций печати, такая как print, prinl,"
" princ, write, format и так далее. Эта обобщенная функция предлагает"
" программам hook(ловушку/крючек) для управления печатным представлением"
" различных классов объектов."

#: ./en/ch03.md:554
msgid ""
"Each CLOS implementation supplies a default method for print-object. The "
"default method is inherited by all user-defined classes. However, any class "
"can provide a method to override the default method."
msgstr ""
"Каждая реализация CLOS предоставляет метод по умолчанию для print-object."
" Метод по умолчанию наследуется всеми определяемыми пользователем классами."
" Однако любой класс может предоставить метод для переопределения метода по"
" умолчанию."

#: ./en/ch03.md:557
msgid ""
"We use this hook by specializing print-object. Conceptually, specializing a "
"generic function means causing that generic function to behave in a "
"customized manner for a given set of arguments. We specialize a generic "
"function by defining a method for it. In this case, we shall provide a "
"method to override the inherited method, so locks will be printed \n"
"in a customized way."
msgstr ""
"Мы используем этот хук, специализируясь на print-object. Концептуально"
" специализация обобщенной функции означает, что эта обобщенная функция ведет"
" себя настраиваемым образом для заданного набора аргументов. Мы"
" специализируем обобщенную функцию, определяя для нее метод. В этом случае мы"
" предоставим метод для переопределения унаследованного метода, поэтому"
" блокировки будут напечатаны индивидуальным образом."

#: ./en/ch03.md:560
msgid ""
"Before writing a method, you must understand the interface of the generic "
"function. The interface of print-object is documented in the CLOS "
"specification. CLOS specifies that the generic function print-object prints "
"an object on a stream and then returns the object. It accepts two required "
"arguments, an object and a stream. When Lisp calls print-object, the stream "
"argument will be a real stream, not t or nil. \n"
"(This is different from print, which does accept t or nil as the stream "
"argument.)"
msgstr ""
"Прежде чем писать метод, вы должны понять интерфейс обобщенной функции."
" Интерфейс  print-object задокументирован в спецификации CLOS. CLOS"
" указывает, что обобщенная функция print-object печатает объект в поток, а"
" затем возвращает объект. Она принимает два обязательных аргумента: объект и"
" поток. Когда Лисп вызывает print-object, аргументом потока будет реальный"
" поток, а не t или nil."
"(Это отличается от print, которая принимает t или nil в качестве аргумента"
" потока.)"

#: ./en/ch03.md:562
msgid "### Specializing print-object for Locks "
msgstr "### Специализация print-object для блокировок(locks)"

#: ./en/ch03.md:564
msgid ""
"We want the method to be selected if the first argument is a lock. In other "
"words, we want all objects whose type is lock to inherit this method. Since "
"only the first argument will be used for method selection, the lambda-list "
"of the method has one specialized parameter and one ordinary parameter."
msgstr ""
"Мы хотим, чтобы метод был выбран, если первым аргументом является"
" блокировка(lock). Другими словами, мы хотим, чтобы все объекты типа lock"
" унаследовали этот метод. Поскольку для выбора метода будет использоваться"
" только первый аргумент, лямбда-список метода имеет один специализированный"
" параметр и один обычный параметр."

#: ./en/ch03.md:575
msgid ""
"<pre>\n"
"(defmethod print-object ((l lock) stream) \n"
"   (format stream \"#<~S ~A ~D>\" \n"
"           (type-of l) \n"
"           (if (slot-boundp l 'name) \n"
"               (lock-name l) \n"
"               \"(no name)\") \n"
"           (sys:%pointer l)) \n"
"   l) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:577
msgid ""
"Once this method is defined, it will be used whenever a lock is printed, and "
"the result is exactly what we want."
msgstr ""
"Как только этот метод будет определен, он будет использоваться всякий раз,"
" когда печатается блокировка, и результат будет именно тем, что мы хотим."

#: ./en/ch03.md:579
msgid ""
"The function sys:%pointer is not part of Common Lisp; it is a function that "
"returns the address of an object in memory in some implementations. It is "
"useful for print-object methods to print the address of the object because "
"it distinguishes this object from other objects, which can be helpful for "
"debugging. The address of the object can change, however, due to garbage "
"collection."
msgstr ""
"Функция sys:%pointer не является частью Common Lisp; это функция, которая в"
" некоторых реализациях возвращает адрес объекта в памяти. Для методов объекта"
" печати полезно печатать адрес объекта, поскольку он отличает этот объект от"
" других объектов, что может быть полезно для отладки. Однако адрес объекта"
" может измениться из-за сборки мусора."

#: ./en/ch03.md:582
msgid ""
"Methods for print-object should not signal errors; it should be possible to "
"get a printed representation of any Lisp object without error. The print-"
"object method for lock uses slot-boundp to check that the lock has a name "
"before calling lock-name. If the name slot were unbound, the lock-name "
"accessor would signal an error; see \"Reading Unbound Slots,\" \n"
"page 75."
msgstr ""
"Методы для print-object не должны сигнализировать об ошибках; должна быть"
" возможность получить печатное представление любого объекта Лиспа без ошибок."
" Метод print-object для блокировки использует slot-boundp для проверки того,"
" что блокировка имеет имя перед вызовом lock-name. Если бы слот имени не был"
" связан, то средство доступа к имени блокировки (accessor lock-name)"
" сигнализировало бы об ошибке; см. «Чтение несвязанных слотов», стр. 75."

#: ./en/ch03.md:585
msgid ""
"It is important to keep in mind the scope of this method. We know it is "
"attached to the class lock, and can therefore use knowledge of the internal "
"details of that class. We also know it is inherited by the classes simple-"
"lock and null-lock and will be used for instances of simple-lock and null-"
"lock. This method cannot use knowledge of any classes built on lock. For "
"example, this method can use the reader generic function lock-name, because "
"the class lock has a method for it; however, it cannot use the reader "
"generic function lock-owner, because the only class that has a method for "
"lock-owner is simple-lock. If this method did use lock-owner, and the "
"argument to print-object were a null lock, an error would be signaled at run "
"time to indicate that there is no applicable \n"
"method for lock-owner."
msgstr ""
"Важно помнить о области действия этого метода. Мы знаем, что он привязан к"
" классу блокировки(lock), и поэтому можем использовать знание внутренних"
" деталей этого класса. Мы также знаем, что он унаследован классами"
" simple-lock и null-lock и будет использоваться для экземпляров simple-lock и"
" null-lock. Этот метод не может использовать знание каких-либо классов,"
" построенных на блокировке. Например, этот метод может использовать"
" обобщенное имя функции чтения lock-name, потому что класс lock имеет для"
" этого метод; однако он не может использовать обобщенную функцию "
" lock-owner(владельца блокировки) для чтения, потому что единственный класс,"
" который имеет метод для  lock-owner, — это simple-lock. Если бы этот метод"
" действительно использовал  lock-owner, а аргумент для print-object был"
" нулевой блокировкой, во время выполнения было бы сообщено об ошибке, чтобы"
" указать, что для lock-owner не существует применимого метода."

#: ./en/ch03.md:588
msgid ""
"Although this method must restrict itself to knowledge of the lock class, we "
"know that the method is inherited by other classes. A common error people "
"make when first learning to write object-oriented programs is to assume that "
"the method will be called only for instances of lock, and not for instances "
"of classes that are built on lock. This method \n"
"could have made that incorrect assumption and produced output stating that "
"the instance is a lock, instead of recognizing that the object might be an "
"instance of a class built on lock. By querying the object for its type with "
"type-of, however, we are recognizing that several different classes will "
"inherit this method."
msgstr ""
"Хотя этот метод должен ограничиваться знанием класса блокировки, мы знаем,"
" что этот метод наследуется другими классами. Обычная ошибка, которую"
" совершают люди, впервые учась писать объектно-ориентированные программы,"
" состоит в том, что предполагается, что метод будет вызываться только для"
" экземпляров блокировки(lock), а не для экземпляров классов, построенных на"
" основе блокировки. Этот метод мог бы сделать это неверное предположение и"
" вывести результат, утверждающий, что экземпляр является блокировкой(lock),"
" вместо того, чтобы признать, что объект может быть экземпляром класса,"
" построенного на базе блокировки. Однако, запрашивая у объекта его тип с"
" помощью type-of, мы понимаем, что несколько разных классов будут наследовать"
" этот метод."

#: ./en/ch03.md:590
msgid "### What Is a Default Method? "
msgstr "### Что такое метод по умолчанию(Default Method)?"

#: ./en/ch03.md:592
msgid ""
"The system's method for print-object is a default method for objects of all "
"user-defined classes. We have provided a method for print-object for the "
"class lock. This is a default method for all locks, because all locks are "
"built on lock."
msgstr ""
"Системный метод для print-object является методом по умолчанию для объектов"
" всех определяемых пользователем классов. Мы предоставили метод print-object"
" для класса блокировкиа. Это метод по умолчанию для всех блокировок, потому"
" что все блокировки построены на базе блокировки."

#: ./en/ch03.md:594
msgid ""
"Like the term \"basic class,\" the term \"default method\" does not have a "
"technical meaning. These terms simply describe the intended purpose of the "
"class or method. A basic class is usually intended to be the foundation of a "
"set of classes. A default method is intended to be inherited by a set of "
"classes. Many basic classes provide default behavior; thus, default methods "
"usually are attached to basic classes."
msgstr ""
"Как и термин «базовый класс», термин «метод по умолчанию» не имеет"
" технического значения. Эти термины просто описывают предполагаемое"
" назначение класса или метода. Базовый класс обычно предназначен для того,"
" чтобы быть основой набора классов. Метод по умолчанию предназначен для"
" наследования набором классов. Многие базовые классы обеспечивают поведение"
" по умолчанию; таким образом, методы по умолчанию обычно присоединяются к"
" базовым классам."

#: ./en/ch03.md:596
msgid "### Specializing describe for Locks"
msgstr "### Специализация описания для блокировок(Locks)"

#: ./en/ch03.md:598
msgid ""
"In addition to controlling the printed representation of locks, it would be "
"beneficial to provide a way for people to examine a lock in more detail."
msgstr ""
"В дополнение к управлению печатным представлением блокировок было бы полезно"
" предоставить людям возможность более подробно изучить блокировку(объект"
" lock)."

#: ./en/ch03.md:600
msgid ""
"One way to do this is to specialize the describe generic function. An "
"alternative would be to write a method for a new generic function, such as "
"show-lock. Either way would accomplish the same thing, but often it is "
"preferable to extend a familiar Common Lisp function rather than to "
"introduce a new function. This approach works only if the function is a "
"generic function. "
msgstr ""
"Один из способов сделать это — специализировать/указать обобщенную функцию"
" describe(описание). Альтернативой может быть написание метода для новой"
" обобщенной функции, такой как show-lock. В любом случае будет достигнуто"
" одно и то же, но часто предпочтительнее расширить знакомую функцию Common"
" Lisp, чем вводить новую функцию. Этот подход работает, только если функция"
" является обобщенной функцией."

#: ./en/ch03.md:602
msgid ""
"Like print-object, describe is a generic function that is provided by CLOS "
"so users can specialize its behavior for a given class of object. A system-"
"supplied default method is available, but you can provide a method to "
"override it."
msgstr ""
"Как и print-object, describe(описать) — это обобщенная функция,"
" предоставляемая CLOS, чтобы пользователи могли специализировать ее поведение"
" для предоставленного класса объектов. Доступен системный метод по умолчанию,"
" но вы можете указать метод для его переопределения."

#: ./en/ch03.md:604
msgid ""
"The interface for describe states that it takes a single argument, prints a "
"description of its argument to standard output, and returns no values. This "
"method specializes describe for locks:"
msgstr ""
"Интерфейс для describe утверждает, что он принимает один аргумент, выводит"
" описание своего аргумента на стандартный вывод и не возвращает никаких"
" значений. Этот метод describe специализируется для блокировок:"

#: ./en/ch03.md:614
msgid ""
"<pre>\n"
"(defmethod describe ((l lock)) \n"
"   (format t \"~&~S is a lock of type ~S named ~A.\" \n"
"           l (type-of l) \n"
"           (if (slot-boundp l 'name) \n"
"               (lock-name l) \n"
"               \"(no name)\")) \n"
"   (values)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:616
msgid ""
"This primary method is applicable for all locks. It is inherited by null "
"locks and simple locks. We use slot-boundp to ensure that the describe "
"method does not signal an error if the name slot is unbound. "
msgstr ""
"Этот основной метод применим для всех блокировок. Он наследуется нулевыми"
" блокировками и простыми блокировками. Мы используем slot-boundp, чтобы"
" гарантировать, что метод describe не сигнализирует об ошибке, если слот"
" имени не связан."

#: ./en/ch03.md:618
msgid "### An After-Method for Describing Simple Locks"
msgstr "### After-method для описания простых блокировок"

#: ./en/ch03.md:620
msgid ""
"The primary method for describe does not give an adequate description of a "
"simple lock. A crucial element of a simple lock is its owner, if it is "
"currently busy. The describe method supplied by lock cannot give this "
"information, because it would be overstepping its bounds. The class lock "
"does not have an owner."
msgstr ""
"Основной метод describe(описания) не дает адекватного описания простой"
" блокировки. Важнейшим элементом простой блокировки является её владелец,"
" если она в данный момент занята. Метод describe(описания), предоставленный"
" блокировкой, не может предоставить эту информацию, потому что он выходит за"
" его пределы. Класс lock(Блокировка) не имеет слота owner(владельца)."

#: ./en/ch03.md:622
msgid ""
"We want to specialize the behavior of describe for simple-lock so that it "
"will give the same information as does the describe method for lock, but "
"also describe the owner of the simple lock."
msgstr ""
"Мы хотим специализировать поведение describe для простой"
" блокировки(simple-lock), чтобы он давал ту же информацию, что и метод"
" describe(описания) для lock(блокировки), но также описывал владельца(owner)"
" простой блокировки."

#: ./en/ch03.md:625
msgid ""
"We could supply a primary method for describe attached to the class simple-"
"lock to override the method inherited from the class lock. Of course, we "
"would have to duplicate the code for displaying the lock's type and name, "
"and for ensuring that no values are returned. However, duplication of code "
"is antithetical to the object-oriented programming style. Instead of "
"overriding the method, we should seek to inherit it and add behavior to it. "
"\n"
"We can do this by providing an after-method for the class simple-lock. The "
"after-method takes care of describing the owner of the simple lock."
msgstr ""
"Мы могли бы предоставить основной метод для describe, прикрепленный к классу"
" simple-lock, чтобы переопределить метод, унаследованный от класса"
" lock(блокировки). Конечно, нам пришлось бы продублировать код для"
" отображения  типа и имени блокировки, а также для обеспечения того, чтобы"
" никакие значения не возвращались. Однако дублирование кода противоречит"
" объектно-ориентированному стилю программирования. Вместо того, чтобы"
" переопределять метод, мы должны стремиться унаследовать его и добавить к"
" нему поведение.\n"
"Мы можем сделать это, предоставив метод after для класса simple-lock."
" After-метод заботится об описании владельца(owner) простой блокировки."

#: ./en/ch03.md:628
msgid ""
"When the generic function describe is called on a simple lock, the generic "
"dispatch procedure first calls the primary method supplied by the class "
"lock, and then calls the after-method supplied by the class simple-lock. The "
"generic function returns the values returned by the primary method, which is "
"just what we want. Any values returned by an after-method are ignored. After-"
"methods are used to perform side effects, not to return values. An after-"
"method has the keyword :after as its method qualifier. This method qualifier "
"gives the role of the method. Until now, we have seen only primary methods, "
"which have no method qualifiers. If a method has any qualifiers, they appear "
"immediately after \n"
"the name of the generic function."
msgstr ""
"Когда обобщенная функция describe вызывается для простой блокировки,"
" обобщенная процедура диспетчеризации(generic dispatch procedure) сначала"
" вызывает первичный метод, предоставляемый классом блокировки, а затем"
" вызывает дополнительный метод, предоставляемый классом simple-lock."
" Обобщенная функция возвращает значения, возвращенные основным методом, что"
" нам и нужно. Любые значения, возвращаемые after-методом, игнорируются."
" After-методы используются для выполнения побочных эффектов, а не для"
" возврата значений. After-метод имеет ключевое слово :after в качестве"
" квалификатора метода. Этот квалификатор метода задает роль метода. До сих"
" пор мы видели только первичные методы, не имеющие квалификаторов методов."
" Если у метода есть квалификаторы, они появляются сразу после имени"
" обобщенной функции."

#: ./en/ch03.md:637
msgid ""
"<pre>\n"
"(defmethod describe :after ((l simple-lock)) \n"
"   (let ((owner (lock-owner l))) \n"
"      (format t (if owner \n"
"                    \"~&It is now owned by process ~A.~%\" \n"
"                    \"~&It is now free.~%\") \n"
"              owner))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:639
msgid ""
"When the describe generic function is called for a simple lock, two methods "
"are called. When the describe generic function is called for a null lock, "
"only one method is called, describe has only one interface, but it has "
"various implementations. This is the meaning of the term generic function."
msgstr ""
"Когда для простой блокировки вызывается обобщенная функция describe,"
" вызываются два метода. Когда для нулевой блокировки вызывается обобщенная"
" функция describe, вызывается только один метод, describe имеет только один"
" интерфейс, но имеет различные реализации. В этом смысл термина обобщенная"
" функция."

#: ./en/ch03.md:641
msgid ""
"In this method, we assume that the owner slot is bound. If it is not, this "
"method will signal an error. The semantics of ordered locks require that the "
"owner slot be either a process or nil."
msgstr ""
"В этом методе мы предполагаем, что слот owner(владелец) связан. Если это не"
" так, этот метод будет сигнализировать об ошибке. Семантика упорядоченных"
" блокировок требует, чтобы слот owner(владельца) был либо процессом, либо nil."

#: ./en/ch03.md:643
msgid "### The System's Default describe Method"
msgstr "### Cистемы по умолчанию Метод describe "

#: ./en/ch03.md:646
msgid ""
"The behavior of the default method for describe is implementation dependent. "
"Typically, the default method gives the type of the object and the names and "
"values of its slots. Why is the default method undesirable for describing "
"locks? \n"
"Instead of merely displaying the names and values of the slots, our method "
"goes a step further and conveys the semantics behind the slots and their "
"values. Our describe method provides output that gives an English-language, "
"conceptual description of the lock. The output of our describe method looks "
"like this:"
msgstr ""
"Поведение метода по умолчанию для describe зависит от реализации. Как"
" правило, метод по умолчанию дает тип объекта, а также имена и значения его"
" слотов. Почему метод по умолчанию нежелателен для описания блокировок?\n"
"Вместо того, чтобы просто отображать имена и значения слотов, наш метод"
" делает шаг вперед и передает семантику слотов и их значений. Наш метод"
" describe выдает концептуальное описание блокировки на английском языке."
" Вывод нашего метода описания выглядит следующим образом:"

#: ./en/ch03.md:652
msgid ""
"<pre>\n"
"#<SIMPLE-LOCK File lock 2417> is a lock of type \n"
"SIMPLE-LOCK named File lock. \n"
"It is now owned by Process 3299. \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:654
msgid ""
"The output of a typical system-supplied default method for describe looks "
"like this: "
msgstr ""
"Вывод типичного системного метода по умолчанию для describe выглядит"
" следующим образом:"

#: ./en/ch03.md:661
msgid ""
"<pre>\n"
"#<SIMPLE-LOCK \"File lock\" 2417> is of type SIMPLE-LOCK, \n"
"with slots: \n"
"         NAME:                \"File lock\" \n"
"         OWNER:               3299 \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:663
msgid ""
"There is another advantage to supplying a describe method customized for a "
"class of object. Often, it is desirable to conceal the details of the "
"implementation of the object. The default method has no way to describe the "
"object other than by laying bare its implementation. By supplying a describe "
"method, you can control how users view your object."
msgstr ""
"Есть еще одно преимущество в предоставлении метода describe(описания),"
" настроенного для класса объекта. Часто желательно скрыть детали реализации"
" объекта. У метода по умолчанию нет другого способа описать объект, кроме как"
" обнажая его реализацию. Предоставляя метод describe, вы можете управлять"
" тем, как пользователи видят ваш объект."

#: ./en/ch03.md:665
msgid "## 3.7 ANALYZING THE INHERITANCE OF LOCKS "
msgstr "## 3.7 АНАЛИЗ НАСЛЕДОВАНИЯ БЛОКИРОВОК"

#: ./en/ch03.md:667
msgid ""
"So far, we have been programming with an implicit understanding of how "
"inheritance should work. At this point it is worth examining inheritance in "
"greater detail and making explicit some of the mechanisms behind it."
msgstr ""
"До сих пор мы программировали с неявным пониманием того, как должно работать"
" наследование. На этом этапе стоит более подробно изучить наследование и"
" прояснить некоторые механизмы, лежащие в его основе."

#: ./en/ch03.md:669
msgid "### Overriding Inherited Traits"
msgstr "### Переопределение унаследованных признаков"

#: ./en/ch03.md:671
msgid ""
"Our organization of locks includes the basic class lock, and two classes "
"built on lock. Both simple-lock and null-lock inherit from the class lock. "
"Also, all user-defined classes inherit from the class standard-object."
msgstr ""
"Наша организация блокировок включает базовый класс блокировки и два класса,"
" построенных на блокировке. И простая блокировка, и нулевая блокировка"
" наследуются от класса блокировки. Кроме того, все пользовательские классы"
" наследуются от класса standard-object(стандартного объекта)."

#: ./en/ch03.md:673
msgid ""
"The class standard-object is a predefined class whose purpose is to support "
"default behavior. That is, several system-supplied default methods are "
"attached to the class standard-object."
msgstr ""
"Класс standard-object — это предопределенный класс, целью которого является"
" поддержка поведения по умолчанию. То есть к классу standard-object привязано"
" несколько системных методов по умолчанию."

#: ./en/ch03.md:675
msgid ""
"Consider what happens when the print-object generic function is called with "
"an instance of null-lock as its argument. The class null-lock has two "
"applicable primary methods for print-object: the method attached to lock and "
"the method attached to standard-object."
msgstr ""
"Рассмотрим, что происходит, когда обобщенная функция print-object вызывается"
" с экземпляром null-lock в качестве аргумента. Класс null-lock имеет два"
" применимых основных метода для print-object: метод, прикрепленный к lock, и"
" метод, прикрепленный к standard-object."

#: ./en/ch03.md:680
msgid ""
"| Class           | Method for print-object |\n"
"|-----------------|-------------------------|\n"
"| lock            |   primary               |\n"
"| standard-object |   primary               |"
msgstr ""
"| Класс              | Метод для print-object |\n"
"|------------------------|------------------------------------|\n"
"| lock                 |   primary                      |\n"
"| standard-object |   primary                     |"

#: ./en/ch03.md:682
msgid ""
"Here we see two superclasses of null-lock offering competing traits; that "
"is, primary methods for the same generic function. This is a conflict, but "
"its resolution is simple and obvious. One of the methods is more specific "
"than the other. The precedence of a method is directly related to the "
"precedence of the classes for which it is applicable. In the class "
"precedence list of null-lock, the class lock precedes standard-object, so "
"the method supplied by lock overrides the method supplied by standard-object."
msgstr ""
"Рассмотрим, что происходит, когда обобщенная функция print-object вызывается"
" с экземпляром null-lock в качестве аргумента. Класс null-lock имеет два"
" применимых основных метода для print-object: метод, прикрепленный к lock, и"
" метод, прикрепленный к standard-object."

#: ./en/ch03.md:684
msgid ""
"The reason that lock is more specific than standard-object is that a class "
"has precedence over its superclasses. The class standard-object is a "
"superclass of the class lock."
msgstr ""
"Причина, по которой блокировка является более конкретной, чем"
" standard-object, заключается в том, что класс имеет приоритет над своими"
" суперклассами. Класс standard-object является надклассом класса lock."

#: ./en/ch03.md:686
msgid "### Class Precedence Lists of Null and Simple Locks"
msgstr "### Списки приоритетов классов нулевых и простых блокировок"

#: ./en/ch03.md:690
msgid ""
"The class precedence list is the arbiter of conflicting traits. CLOS "
"determines the class precedence list for every class, based on the "
"organization of classes that the programmer has set up. During this process, "
"CLOS must answer two questions: \n"
"*  From what classes does this class inherit? A class inherits from itself "
"and all its superclasses. This includes its direct superclasses, each of "
"their direct superclasses, and so on. CLOS derives this information from the "
"set of class definitions. \n"
"*  What is the precedence order among these classes? The answer to this "
"question is also derived from the class definitions. CLOS uses an algorithm "
"to determine the precedence, and the algorithm always obeys the following "
"class precedence rule:"
msgstr ""
"Список приоритетов(предшествования) классов является арбитром конфликтующих"
" признаков. CLOS определяет список приоритетов классов для каждого класса на"
" основе организации классов, настроенной программистом. В ходе этого процесса"
" CLOS должен ответить на два вопроса:\n"
"* От каких классов наследуется этот класс? Класс наследуется от самого себя и"
" всех своих суперклассов. Сюда входят его прямые суперклассы, каждый из их"
" прямых суперклассов и так далее. CLOS получает эту информацию из набора"
" определений классов.\n"
"* Каков порядок старшинства среди этих классов? Ответ на этот вопрос также"
" получен из определений классов. CLOS использует алгоритм для определения"
" приоритета, и этот алгоритм всегда подчиняется следующему правилу приоритета"
" класса:"

#: ./en/ch03.md:694
msgid ""
"|   **Rule 1 of class precedence:**                  \n"
"|----------------------------------------------------\n"
"|A class always has precedence over its superclasses."
msgstr ""
"| **Правило 1 приоритета/предшествования класса:** \n"
"|------------------------------------------------------\n"
"|Класс всегда имеет приоритет над своими суперклассами."

#: ./en/ch03.md:696
msgid ""
"We have mentioned that all user-defined classes have standard-object as a "
"superclass. In addition, all classes have the class t as a superclass. The "
"class t is the root of all classes. Just as all types are subtypes of t, all "
"classes are subclasses of t."
msgstr ""
"Мы упоминали, что все пользовательские классы имеют standard-object в"
" качестве суперкласса. Кроме того, все классы имеют класс t в качестве"
" суперкласса. Класс t является корнем всех классов. Точно так же, как все"
" типы являются подтипами t, все классы являются подклассами t."

#: ./en/ch03.md:698
msgid ""
"Consider the example of simple-lock. This class inherits from itself, simple-"
"lock, and its superclasses, lock, standard-object, and t. When CLOS applies "
"Rule 1 to each of these class definitions, the result is a set of ordering "
"constraints:"
msgstr ""
"Рассмотрим пример simple-lock(простой блокировки). Этот класс наследует сам"
" от себя simple-lock и его суперклассы lock, standard-object и т.д. Когда"
" CLOS применяет Правило 1 к каждому из этих определений классов, результатом"
" является набор ограничений упорядочения:"

#: ./en/ch03.md:705
msgid ""
"\t> simple-lock has precedence over lock \n"
"\t> simple-lock has precedence over standard-object \n"
"\t> simple-lock has precedence over t \n"
"\t> lock has precedence over standard-object \n"
"\t> lock has precedence over t \n"
"\t> standard-object has precedence over t "
msgstr ""
"\t> simple-lock(простая блокировка) имеет приоритет над lock(блокировкой)\n"
"\t> simple-lock(простая блокировка) имеет приоритет над"
" standard-object(стандартным объектом)\n"
"\t> simple-lock(простая блокировка) имеет приоритет над t\n"
"\t> lock(блокировка) имеет приоритет над standard-object\n"
"\t> lock имеет приоритет над t\n"
"\t> standard-object имеет приоритет над t"

#: ./en/ch03.md:714
msgid ""
"The class precedence list must satisfy all these constraints. The resulting "
"class precedence list for simple-lock is\n"
"<pre>\n"
"(simple-lock lock standard-object t) \n"
"</pre>\n"
"Similarly, the class precedence list of null-lock is \n"
"<pre>\n"
"(null-lock lock standard-object t) \n"
"</pre>"
msgstr ""
"Список приоритетов классов должен удовлетворять всем этим ограничениям."
" Результирующий список приоритетов классов для simple-lock(простой"
" блокировки):\n"
"<pre>\n"
"(simple-lock lock standard-object t) \n"
"</pre>\n"
"Точно так же список приоритетов классов для null-lock(нулевой блокировки)\n"
"<pre>\n"
"(null-lock lock standard-object t) \n"
"</pre>"

#: ./en/ch03.md:716
msgid ""
"It is a simple matter to determine the class precedence lists for these two "
"classes. It is more difficult for classes that have more than one direct "
"superclass. We introduce another class precedence rule to address that "
"situation, in \"Class Precedence Lists of Ordered Locks ,\" page 48."
msgstr ""
"Определить списки приоритетов для этих двух классов несложно. Это сложнее для"
" классов, которые имеют более одного прямого суперкласса. Мы вводим еще одно"
" правило приоритета класса для решения этой ситуации в «Списки приоритета"
" класса упорядоченных блокировок», стр. 48."

#: ./en/ch03.md:718
msgid "### The Generic Dispatch Procedure"
msgstr "### Обобщенная процедура отправки"

#: ./en/ch03.md:720
msgid ""
"When a generic function is called, CLOS takes charge of selecting the "
"implementation that is appropriate to the arguments. This entails finding "
"the applicable methods, then sorting them by order of precedence, and "
"finally calling one or more of them. This procedure is called generic "
"dispatch. It happens automatically whenever a generic function is called."
msgstr ""
"Когда вызывается обобщенная функция, CLOS берет на себя ответственность за"
" выбор реализации, соответствующей аргументам. Это влечет за собой поиск"
" применимых методов, затем их сортировку по порядку приоритета и, наконец,"
" вызов одного или нескольких из них. Эта процедура называется обобщенной"
" отправкой(generic dispatch). Это происходит автоматически всякий раз, когда"
" вызывается обобщенная функция."

#: ./en/ch03.md:722
msgid ""
"You are responsible for defining the classes and methods in the first place, "
"with an understanding of how the generic dispatch works. CLOS takes care of "
"the mechanics behind the generic dispatch."
msgstr ""
"Вы несете ответственность за определение классов и методов, в первую очередь,"
" с пониманием того, как работает обобщенная диспетчеризация. CLOS заботится о"
" механике обобщенной отправки(диспетчеризации)."

#: ./en/ch03.md:724
msgid "\t>  What You Do               What CLOS Does"
msgstr "\t>  Что вы делаете                Что делает CLOS"

#: ./en/ch03.md:726
msgid ""
"\t> Define the classes.        Computes the class precedence list based on "
"the class definitions."
msgstr ""
"\t> Определите классы.            Вычисляет список приоритетов классов на"
" основе определений классов."

#: ./en/ch03.md:728
msgid ""
"\t> Define the methods.        Saves the methods for use when a generic "
"function is called."
msgstr ""
"\t> Определите методы.            Сохраняет методы для использования при"
" вызове обобщенной функции."

#: ./en/ch03.md:737
msgid ""
"\t> Call generic functions.    Determines the types of the arguments.\n"
"\t>                            Locates the set of applicable methods. \n"
"\t>                            Sorts the methods from most specific to most "
"general,\n"
"\t>                            based on the class precedence list. \n"
"\t>                            Calls before-methods. \n"
"\t>                            Calls the most specific primary method. \n"
"\t>                            Calls after-methods. \n"
"\t>                            Returns the value(s) of the primary method."
msgstr ""
"\t> Вызываете обобщенные функции. Определяет типы аргументов.\n"
"\t>                               Находит набор применимых методов.\n"
"\t>                               Сортирует методы от наиболее конкретных к"
" наиболее общим на основе списка приоритетов классов.\n"
"\t>                               Вызывает before-методы.\n"
"\t>                               Вызывает наиболее конкретный основной"
" метод.\n"
"\t>                               Вызывает after-методы.\n"
"\t>                               Возвращает значение(я) основного метода."

#: ./en/ch03.md:739
msgid ""
"Although calling a generic function sounds like a slow and complex process, "
"good CLOS implementations optimize it, precomputing many of the steps. In "
"fact, in some implementations, calling a generic function is nearly as fast "
"as calling an ordinary function. Such optimizations can make CLOS efficient "
"enough for use in an operating system, for example."
msgstr ""
"Хотя вызов обобщенной функции кажется медленным и сложным процессом, хорошие"
" реализации CLOS оптимизируют его, предварительно вычисляя многие шаги."
" Фактически, в некоторых реализациях вызов обобщенной функции почти так же"
" быстр, как и вызов обычной функции. Такая оптимизация может сделать CLOS"
" достаточно эффективной для использования, например, в операционной системе."

#: ./en/ch03.md:741
msgid ""
"We discuss the order of execution of before-methods and after-methods in "
"\"Order of Before- and After-Methods,\" page 50."
msgstr ""
"Мы обсуждаем порядок выполнения методов до(before-) и после(after-) в разделе"
" «Порядок выполнения методов до и после», стр. 50."

#: ./en/ch03.md:743
msgid "## 3.8 EXTENDING THE LOCKING PROGRAM"
msgstr "## 3.8 РАСШИРЕНИЕ ПРОГРАММЫ БЛОКИРОВКИ"

#: ./en/ch03.md:745
msgid ""
"The design of the locking application is now complete, and the "
"implementation of simple locks and null locks is done. We now want to add a "
"new kind of lock to the existing locking application. In this section, we "
"illustrate defining a \"mixin class\" to be used as a building block and "
"\"aggregate classes\" built on the mixin and another class."
msgstr ""
"На этом разработка блокирующего приложения завершена, реализованы простые и"
" нулевые блокировки. Теперь мы хотим добавить новый тип блокировки к"
" существующему приложению блокировки. В этом разделе мы иллюстрируем"
" определение «класса миксина»(\"mixin class\"), который будет использоваться"
" в качестве строительного блока, и «агрегированных классов»(\"aggregate"
" classes\"), построенных на миксине и другом классе."

#: ./en/ch03.md:747
msgid "### Avoiding Deadlock with Ordered Locks"
msgstr ""
"### Предотвращение взаимоблокировок(Deadlock) с помощью упорядоченных"
" блокировок(Ordered Locks)"

#: ./en/ch03.md:750
msgid ""
"Some operations require you to access more than one shared resource. You "
"might want to delete an item from one data structure and add it to another "
"data structure. If the data structures are shared resources with locks "
"protecting them against simultaneous access, you must own the locks on both "
"resources while you do the adding and deleting opera- \n"
"tions."
msgstr ""
"Некоторые операции требуют доступа более чем к одному общему ресурсу. Вы"
" можете удалить элемент из одной структуры данных и добавить его в другую"
" структуру данных. Если структуры данных являются общими ресурсами с"
" блокировками, защищающими их от одновременного доступа, вы должны владеть"
" блокировками для обоих ресурсов при выполнении операций добавления и"
" удаления."

#: ./en/ch03.md:752
msgid ""
"Here is another scenario: To obtain butter you need to be holding both the "
"butter dish and the butter knife at the same time. When you hold the butter "
"dish and knife, you are protecting them from simultaneous use by other "
"people (in other words, you \"own the locks\" on the two butter resources)."
msgstr ""
"Вот еще один сценарий: чтобы получить масло, вам нужно одновременно держать"
" блюдо масла и нож для масла. Когда вы держите блюдо масла и нож, вы"
" защищаете их от одновременного использования другими людьми (другими"
" словами, вы «владеете блокировками» на двух ресурсах масла)."

#: ./en/ch03.md:754
msgid ""
"When you need to own two locks at the same time, there is a risk of "
"deadlock. Suppose one person holds the butter dish and is waiting for the "
"butter knife. Meanwhile, another person holds the butter knife and is "
"waiting for the butter dish. Neither person can obtain butter until the "
"other has finished. In this case, both people will realize that deadlock has "
"occurred, and one person will probably release one of the resources in "
"contention. This allows the other person to obtain butter and then to "
"release both resources for other people to use. In this solution, the people "
"detect the deadlock and resolve it."
msgstr ""
"Когда вам нужно владеть двумя блокировками одновременно, существует риск"
" взаимоблокировки. Предположим, один человек держит блюдо с маслом и ждет нож"
" для масла. Тем временем другой человек держит нож для масла и ждет блюдо с"
" маслом. Ни один человек не может получить масло, пока другой не закончит. В"
" этом случае оба человека поймут, что возникла тупиковая ситуация( deadlock),"
" и один человек, вероятно, освободит один из конфликтующих ресурсов. Это"
" позволяет другому человеку получить масло, а затем высвободить оба ресурса"
" для использования другими людьми. В этом решении люди обнаруживают"
" взаимоблокировку и разрешают ее."

#: ./en/ch03.md:756
msgid ""
"When a process needs to seize more than one simple lock, there is the risk "
"of deadlock. Remember that, if a simple lock cannot immediately seize a "
"resource, it waits until the resource is free."
msgstr ""
"Когда процессу необходимо захватить более одной простой блокировки,"
" существует риск взаимоблокировки. Помните, что если простая блокировка не"
" может немедленно захватить ресурс, она ждет, пока ресурс освободится."

#: ./en/ch03.md:758
msgid ""
"Instead of implementing deadlock detection and resolution, we can seek to "
"avoid deadlock. We use a technique in which all processes must seize a group "
"of locks in a prescribed order. We could apply this approach at the dinner "
"table by making a rule that to obtain butter, you must pick up the butter "
"dish before picking up the butter knife. If all people obey this rule, no "
"person will be holding the butter knife and waiting for the butter dish, so "
"no deadlock will happen."
msgstr ""
"Вместо реализации обнаружения и разрешения взаимоблокировок мы можем"
" попытаться избежать взаимоблокировки. Мы используем технику, в которой все"
" процессы должны захватывать группу блокировок в заданном порядке. Мы могли"
" бы применить этот подход к обеденному столу, установив правило, согласно"
" которому, чтобы получить масло, вы должны взять блюдо для масла, прежде чем"
" взять в руки нож для масла. Если все люди будут соблюдать это правило, никто"
" не будет держать нож для масла и ждать блюдо с маслом, поэтому тупика не"
" произойдет."

#: ./en/ch03.md:760
msgid ""
"We can invent a new kind of lock, called an ordered lock, to assist "
"programmers in using this technique. This enables you to assign a locking "
"order to a set of locks. The ordered locking mechanism is a programming tool "
"that provides run time error-checking to make sure that the order is not "
"violated. It checks running code to see whether the program runs the risk of "
"deadlock, and signals an error in that case."
msgstr ""
"Мы можем изобрести новый тип блокировки, называемый упорядоченной"
" блокировкой(ordered lock), чтобы помочь программистам использовать эту"
" технику. Она позволит назначить порядок блокировки для набора блокировок."
" Механизм упорядоченной блокировки — это инструмент программирования,"
" обеспечивающий проверку ошибок во время выполнения, чтобы убедиться, что"
" порядок не нарушен. Он проверяет работающий код, чтобы увидеть, не рискует"
" ли программа зайти в тупик, и в этом случае сигнализирует об ошибке."

#: ./en/ch03.md:763
msgid ""
"Thus, if we anticipate that processes need to seize both lock-A and lock-B "
"before doing an operation, we can use ordered locks. Each ordered lock has a "
"lock level. The ordered locking mechanism enforces the rule that a process "
"cannot seize an ordered lock if the process already owns a lock at a higher "
"level. We might assign a lock level of 1 to lock-A \n"
"and a lock level of 2 to lock-B to ensure that lock-A must be seized before "
"lock-B. In this scheme, all programs should be written to seize lock-A, then "
"seize lock-B, perform the operation, and finally release both locks. If any "
"process owns lock-B and attempts to seize lock-A, the ordered locking "
"mechanism signals an error at run time. This approach ensures that no "
"process can be in the state of owning lock-B and waiting for lock-A."
msgstr ""
"Таким образом, если мы ожидаем, что перед выполнением операции процессам"
" потребуется захватить как блокировку A, так и блокировку B, мы можем"
" использовать упорядоченные блокировки. Каждая заказанная блокировка имеет"
" уровень(level) блокировки. Механизм упорядоченной блокировки применяет"
" правило, согласно которому процесс не может захватить упорядоченную"
" блокировку, если процесс уже владеет блокировкой более высокого уровня. Мы"
" могли бы назначить уровень блокировки 1 для блокировки-A и уровень"
" блокировки 2 для блокировки-B, чтобы гарантировать, что блокировка-A должна"
" быть занята до блокировки-B. В этой схеме все программы должны быть написаны"
" так, чтобы захватить блокировку-A, затем захватить блокировку-B, выполнить"
" операцию и, наконец, снять обе блокировки. Если какой-либо процесс владеет"
" блокировкой B и пытается захватить блокировку A, механизм упорядоченной"
" блокировки сообщает об ошибке во время выполнения. Такой подход гарантирует,"
" что ни один процесс не может находиться в состоянии владения блокировкой B и"
" ожидания блокировки A."

#: ./en/ch03.md:765
msgid "### Defining a Mixin Class"
msgstr "### Определение класса Mixin"

#: ./en/ch03.md:767
msgid ""
"We anticipate needing both ordered null locks and ordered simple locks. The "
"behavior that these two classes will have in common is the ordered locking "
"behavior. Here it is useful to create a mixin class that supports the "
"ordered locking behavior. We call that class ordered-lock-mixin. "
msgstr ""
"Мы предполагаем, что нам понадобятся как упорядоченные нулевые блокировки,"
" так и упорядоченные простые блокировки. Общее поведение этих двух классов —"
" упорядоченное поведение блокировки. Здесь полезно создать класс"
" mixin(примесь), который поддерживает упорядоченное поведение блокировки. Мы"
" называем этот класс упорядоченной блокировкой-примесью(ordered-lock-mixin)."

#: ./en/ch03.md:770
msgid ""
"This mixin class is not expected to stand alone; we do not create instances "
"of it. Instead, we define two aggregate classes that combine this mixin "
"class with other lock classes, and create instances of them. The aggregate "
"classes are named ordered-null-lock and ordered-lock. The terms \"mixin\" "
"and \"aggregate\" are informal designations that describe \n"
"the intended purpose of the class."
msgstr ""
"Ожидается, что этот класс миксинов не будет самостоятельным; мы не создаем"
" его экземпляры. Вместо этого мы определяем два агрегатных класса, которые"
" объединяют этот класс mixin с другими классами блокировки, и создаем их"
" экземпляры. Агрегатные классы называются ordered-null-lock(упорядоченной"
" нулевой блокировкой) и  ordered-lock(упорядоченной блокировкой). Термины"
" «mixin/примесь» и «aggregate/агрегат» являются неформальными обозначениями,"
" описывающими предполагаемую цель класса."

#: ./en/ch03.md:772
msgid ""
"We do not specify any superclasses for ordered-lock-mixin. There is a single "
"slot named level. We can initialize that slot when creating instances and "
"use a reader function to read its value. We do not expect to change the "
"level of an ordered lock once the lock has been created, so there is no "
"writer provided for the level slot. Our implementation allows a process to "
"seize an ordered lock only if the process does not own another ordered lock "
"at a higher level."
msgstr ""
"Мы не указываем никаких суперклассов для ordered-lock-mixin. Существует"
" единственный слот с именем level. Мы можем инициализировать этот слот при"
" создании экземпляров и использовать функцию чтения для чтения его значения."
" Мы не ожидаем изменения уровня упорядоченной блокировки после создания"
" блокировки, поэтому для слота level не предусмотрено средство записи. Наша"
" реализация позволяет процессу захватывать упорядоченную блокировку только в"
" том случае, если процесс не владеет другой упорядоченной блокировкой на"
" более высоком уровне."

#: ./en/ch03.md:780
msgid ""
"<pre>\n"
"(defclass ordered-lock-mixin () \n"
"  ((level :initarg :level \n"
"          :reader lock-level \n"
"          :type integer)) \n"
"  (:documentation \"Avoids deadlock by checking lock order.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:782
msgid ""
"The purpose of a mixin class is to customize the behavior of the classes "
"built on it. Generally, mixins do not interfere with or override inherited "
"behavior. Instead, mixins usually supply before-methods and after-methods to "
"augment inherited primary methods with customized behavior. Mixins might "
"also provide primary methods for additional generic functions."
msgstr ""
"Назначение класса mixinа — настроить поведение построенных на нем классов."
" Как правило, mixin(примеси) не мешают унаследованному поведению и не"
" переопределяют его. Вместо этого примеси обычно предоставляют методы"
" до(before-) и после(after-), чтобы дополнить унаследованные первичные методы"
" настраиваемым поведением. Миксины также могут предоставлять первичные методы"
" для дополнительных обобщенных функций."

#: ./en/ch03.md:785
msgid ""
"Notice the new slot option :type. This slot option declares that you expect "
"the value of the slot to be of a certain type. Type declarations on slots "
"are ignored by some implementations, whereas other implementations gain "
"efficiency when declarations are used. Type declarations are also a way of "
"documenting the slot. You cannot, however, depend on \n"
"CLOS doing type checking when a value is stored in the slot. Although some "
"CLOS implementations might choose to do type checking, they are not required "
"to do so. This behavior is consistent with Common Lisp itself, which has a "
"loose type-checking behavior."
msgstr ""
"Обратите внимание на новую опцию слота :type. Эта опция слота объявляет, что"
" вы ожидаете, что значение слота будет определенного типа. Объявления типов в"
" слотах игнорируются некоторыми реализациями, в то время как другие"
" реализации повышают эффективность при использовании объявлений. Объявления"
" типов также являются способом документирования слота. Однако вы не можете"
" полагаться на то, что CLOS выполняет проверку типов, когда значение"
" сохраняется в слоте. Хотя некоторые реализации CLOS могут выбрать проверку"
" типов, они не обязаны это делать. Такое поведение согласуется с самим Common"
" Lisp, у которого нестрогая проверка типов."

#: ./en/ch03.md:787
msgid "### Defining Aggregate Classes"
msgstr "### Определение агрегатных(Aggregate) классов"

#: ./en/ch03.md:789
msgid ""
"Here we define two aggregate classes by including the desired set of "
"superclasses:"
msgstr ""
"Здесь мы определяем два агрегатных класса, включая желаемый набор"
" суперклассов:"

#: ./en/ch03.md:797
msgid ""
"<pre>\n"
"(defclass ordered-lock (ordered-lock-mixin simple-lock) \n"
"  () \n"
"  (:documentation \n"
"   \"Avoids deadlock by ensuring that a process seizes \n"
"locks in a specific order. \n"
"When seizing, waits if the lock is busy.\"))"
msgstr ""

#: ./en/ch03.md:805
msgid ""
"(defclass ordered-null-lock (ordered-lock-mixin null-lock) \n"
"  ()\n"
"  (:documentation \n"
"   \"Avoids deadlock by ensuring that a process seizes locks \n"
"in a specific order. Does not actually seize anything, \n"
"but does check that the lock ordering is obeyed.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:807
msgid ""
"An aggregate class includes a set of superclasses that together make up a "
"complete whole, a class that can stand alone. Here, the aggregate class "
"ordered-lock derives most of its behavior from the class simple-lock and "
"customizes it with the ordered lock behavior of the class ordered-lock-"
"mixin. Only rarely does an aggregate class provide additional methods, "
"because that would make the program less modular. Ideally, all the slots and "
"methods are provided by the basic class or by the mixins. The aggregate "
"classes here do not need any further modification."
msgstr ""
"Агрегатный класс включает в себя набор суперклассов, которые вместе"
" составляют законченное целое, класс, который может существовать отдельно."
" Здесь агрегатный класс ordered-lock(упорядоченной блокировки) получает"
" большую часть своего поведения от класса simple-lock(простой блокировки) и"
" настраивает его с поведением упорядоченной блокировки класса"
" ordered-lock-mixin. Лишь изредка агрегатный класс предоставляет"
" дополнительные методы, потому что это сделало бы программу менее модульной."
" В идеале все слоты и методы предоставляются базовым классом или миксинами."
" Агрегирующие классы здесь не нуждаются в каких-либо дополнительных"
" модификациях."

#: ./en/ch03.md:809
msgid "We need to define constructors for these two new kinds of locks: "
msgstr ""
"Нам нужно определить конструкторы для этих двух новых типов блокировок:"

#: ./en/ch03.md:814
msgid ""
"<pre>\n"
"(defun make-ordered-null-lock (name level) \n"
"   (make-instance 'ordered-null-lock :name name \n"
"                                     :level level)) "
msgstr ""

#: ./en/ch03.md:819
msgid ""
"(defun make-ordered-lock (name level) \n"
"   (make-instance 'ordered-lock :name name \n"
"                  ':level level)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:821
msgid "### Class Precedence Lists of Ordered Locks "
msgstr "### Списки приоритетов классов Ordered Locks(упорядоченных блокировок)"

#: ./en/ch03.md:823
msgid ""
"For null locks and simple locks, CLOS could determine the class precedence "
"list by referring only to Rule 1: A class always has precedence over its "
"superclasses."
msgstr ""
"Для нулевых блокировок(null locks) и простых блокировок(simple locks) CLOS"
" может определять список приоритетов классов, ссылаясь только на правило 1:"
" Класс всегда имеет приоритет над своими суперклассами."

#: ./en/ch03.md:825
msgid ""
"When a class has more than one direct superclass, however, this rule is not "
"sufficient for determining the class precedence list. Rule 1 does not "
"indicate how to rank the direct superclasses. For example, when determining "
"the class precedence list for ordered-lock, does ordered-lock-mixin have "
"precedence over simple-lock, or is it the other way around? CLOS uses "
"another rule in this situation:"
msgstr ""
"Однако, когда класс имеет более одного прямого суперкласса, этого правила"
" недостаточно для определения списка приоритетов классов. Правило 1 не"
" указывает, как ранжировать прямые суперклассы. Например, при определении"
" списка приоритетов классов для ordered-lock, имеет ли ordered-lock-mixin"
" приоритет над simple-lock или наоборот? В этой ситуации CLOS использует"
" другое правило:"

#: ./en/ch03.md:830
msgid ""
"| Rule 2 of class precedence:                                     \n"
"|-----------------------------------------------------------------\n"
"| Each class definition sets the precedence order of its direct   \n"
"| superclasses.                                                   "
msgstr ""
"| Правило 2 приоритета класса:                                              \n"
"|---------------------------------------------------------------------------\n"
"| Каждое определение класса устанавливает порядок приоритета своего прямого \n"
"| суперкласса.                                                              "

#: ./en/ch03.md:835
msgid ""
"The order of the direct superclasses in the defclass form states their "
"relative precedence. For example, the class definition of ordered-lock "
"includes two direct superclasses:\n"
"ordered-lock-mixin and simple-lock. \n"
"Since ordered-lock-mixin appears first (leftmost) in the list, it is more \n"
"specific than simple-lock. "
msgstr ""
"Порядок прямых суперклассов в форме defclass указывает их относительный"
" приоритет. Например, определение класса ordered-lock включает в себя два"
" прямых суперкласса:\n"
"ordered-lock-mixin и simple-lock.\n"
"Поскольку ordered-lock-mixin появляется первым (крайним слева) в списке, он"
" более специфичен, чем simple-lock."

#: ./en/ch03.md:837
msgid ""
"When we take into account the two rules, we can determine the class "
"precedence list for the two aggregate classes. The class precedence list of "
"ordered-lock is "
msgstr ""
"Когда мы принимаем во внимание два правила, мы можем определить список"
" приоритетов классов для двух агрегрегатных классов. Список приоритетов"
" классов ordered-lock является"

#: ./en/ch03.md:841
msgid ""
"<pre>\n"
"(ordered-lock ordered-lock-mixin simple-lock lock standard-object t) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:846
msgid ""
"The class precedence list of ordered-null-lock is \n"
"<pre>\n"
"(ordered-null-lock ordered-lock-mixin null-lock lock standard-object t) \n"
"</pre>"
msgstr ""
"Списоком приоритетов классов ordered-null-lock является\n"
"<pre>\n"
"(ordered-null-lock ordered-lock-mixin null-lock lock standard-object t) \n"
"</pre>"

#: ./en/ch03.md:848
msgid "### Specializing describe for Ordered Locks "
msgstr "### Специализированное описание для упорядоченных блокировок"

#: ./en/ch03.md:850
msgid ""
"Before delving into the implementation of ordered locks, we specialize "
"describe to display the lock level of an ordered lock. Because the lock "
"level is a critical aspect of an ordered lock, it is important for describe "
"to give that information."
msgstr ""
"Прежде чем углубляться в реализацию упорядоченных блокировок, мы"
" специализируемся на отображении уровня блокировки упорядоченной блокировки."
" Поскольку уровень блокировки является критическим аспектом упорядоченной"
" блокировки, для описания важно предоставить эту информацию."

#: ./en/ch03.md:855
msgid ""
"<pre>\n"
"(defmethod describe :after ((l ordered-lock-mixin)) \n"
"   (format t \"~&Its lock level is ~D.\" (lock-level l))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:857
msgid ""
"When we try to describe an instance of ordered-lock, CLOS finds the "
"following applicable methods: "
msgstr ""
"Когда мы пытаемся описать экземпляр ordered-lock, CLOS находит следующие"
" применимые методы:"

#: ./en/ch03.md:864
msgid ""
"|   Class           |  Method for describe  |\n"
"|-------------------|-----------------------|\n"
"|ordered-lock-mixin | after                 |\n"
"|simple-lock        | after                 |\n"
"|lock               | primary               |\n"
"|standard-object    | primary               |"
msgstr ""
"| Класс         | Метод для описания |\n"
"|-------------------|---------------------------------|\n"
"|ordered-lock-mixin | after                 |\n"
"|simple-lock        | after                 |\n"
"|lock               | primary               |\n"
"|standard-object    | primary               |"

#: ./en/ch03.md:866
msgid ""
"There are two applicable primary methods. The primary method supplied by "
"lock is the more specific of the two, so it is called."
msgstr ""
"Существует два применимых основных метода. Основной метод, предоставляемый"
" lock, является более специфичным из двух, поэтому вызывается он."

#: ./en/ch03.md:868
msgid ""
"There are two applicable after-methods. Both of them are called. They are "
"called in most-specific-last order. Here, the after-method for simple-lock "
"is called first because it is the less specific of the two. When it returns, "
"the after-method for ordered-lock-mixin is called."
msgstr ""
"Существует два применимых after-метода. Оба они вызываются. Они вызываются в"
" порядке: наиболее-специфичный-последним. Здесь метод after для simple-lock"
" вызывается первым, потому что он менее специфичен из двух. Когда он"
" возвращается, вызывается метод after для ordered-lock-mixin."

#: ./en/ch03.md:870
msgid ""
"Here we create an ordered lock and call describe on it, to show the effect "
"of the generic dispatch on this set of methods:"
msgstr ""
"Здесь мы создаем упорядоченную блокировку и вызываем для нее describe, чтобы"
" показать влияние generic dispatch(обобщенной отправки) на этот набор методов:"

#: ./en/ch03.md:874
msgid ""
"<pre>\n"
"(setq *lock-C* (make-ordered-lock \"C\" 3)) \n"
"=> #<ORDERED-LOCK C 29451> "
msgstr ""

#: ./en/ch03.md:881
msgid ""
"(describe *lock-C*) \n"
"#<ORDERED-LOCK C 29451> is a lock of type ORDERED-LOCK named C. \n"
"It is now free. \n"
"Its lock level is 3. \n"
"=> no values \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:883
msgid "### Order of Before- and After-Methods "
msgstr "### Порядок методов \"До\"(Before-) и \"После\"(After-)"

#: ./en/ch03.md:885
msgid ""
"The generic dispatch procedure finds all applicable methods, which might "
"include several before-methods, primary methods, and after methods. The "
"generic dispatch procedure calls the following methods:"
msgstr ""
"Обобщенная процедура отправки находит все применимые методы, которые могут"
" включать в себя несколько методов до(before-), первичных методов и методов"
" после(after). Общая процедура отправки вызывает следующие методы:"

#: ./en/ch03.md:889
msgid ""
"1. All before-methods in most-specific-first order. This allows a more "
"specific class to do an operation before anything else happens, where "
"\"anything else\" includes inherited before-methods, the primary method, and "
"after-methods. \n"
"2. The most specific primary method. This allows a more specific class to "
"override an inherited primary method, if desired. \n"
"3. All after-methods in most-specific-last order. This allows a more "
"specific class to do an operation after everything else happens, where "
"\"everything else\" includes before-methods, the primary method, and "
"inherited after-methods."
msgstr ""
"1. Все before- методы в наиболее специфичном порядке. Это позволяет более"
" конкретному классу выполнять операцию до того, как произойдет что-либо еще,"
" где \"что-либо еще\" включает унаследованные методы before-(до), основной"
" метод и методы after-(после).\n"
"2. Наиболее специфичный первичный метод. Это позволяет более конкретному"
" классу при желании переопределять унаследованный основной метод.\n"
"3. Все after-методы в порядке: наиболее специфичный последним. Это позволяет"
" более конкретному классу выполнять операцию после того, как произойдет все"
" остальное, где \"все остальное\" включает в себя методы before-(до),"
" основной метод и унаследованные методы after-(после)."

#: ./en/ch03.md:891
msgid ""
"In other words, a class can do something in advance of the behavior "
"inherited from less-specific classes; it can also do something after the "
"behavior inherited from less-specific classes occurs. This kind of nesting "
"should feel natural to programmers familiar with Lisp."
msgstr ""
"Другими словами, класс может сделать что-то до поведения, унаследованного от"
" менее специфичных классов; он также может сделать что-то после того, как"
" произойдет поведение, унаследованное от менее специфичных классов. Такой вид"
" вложенности должен казаться естественным программистам, знакомым с Lisp."

#: ./en/ch03.md:893
msgid ""
"Imagine that the classes ordered-lock-mixin, simple-lock, and lock all "
"provide a before-method and an after-method. Figure 3.3 shows the order in "
"which the methods would be called."
msgstr ""
"Представьте, что классы ordered-lock-mixin, simple-lock и lock предоставляют"
" метод before и метод after. На рисунке 3.3 показан порядок, в котором будут"
" вызываться методы."

#: ./en/ch03.md:901
msgid ""
"\t> before-method for ordered-lock-mixin \n"
"\t> before-method for simple-lock \n"
"\t> before-method for lock \n"
"\t> most specific primary method \n"
"\t> after-method for lock \n"
"\t> after-method for simple-lock \n"
"\t> after-method for ordered-lock-mixin "
msgstr ""
"\t> before-method для ordered-lock-mixin \n"
"\t> before-method для simple-lock \n"
"\t> before-method для lock \n"
"\t> most specific primary method \n"
"\t> after-method для lock \n"
"\t> after-method для simple-lock \n"
"\t> after-method для ordered-lock-mixin \n"

#: ./en/ch03.md:904
msgid ""
"![Figure 3.3: Nesting of before- and after-methods.](images/f03-03.jpg)\n"
"**Figure 3.3: Nesting of before- and after-methods.**"
msgstr ""
"![Рисунок 3.3: Вложенность методов \"до\"(before-) и"
" \"после\"(after-).](images/f03-03.jpg )"
"**Рисунок 3.3: Вложенность методов \"до\"(before-) и \"после\"(after-).**"

#: ./en/ch03.md:906
msgid ""
"In practice, any of these before- or after-methods can be present or absent. "
"When a generic function is called, the only requirement is that there must "
"be at least one applicable primary method. If there is none, an error is "
"signaled. "
msgstr ""
"На практике любой из этих методов до(before-) или после(after-) может"
" присутствовать или отсутствовать. Когда вызывается обобщенная функция,"
" единственным требованием является наличие по крайней мере одного применимого"
" основного метода. Если такового нет, выдается сигнал об ошибке."

#: ./en/ch03.md:909
msgid ""
"### Implementing Ordered Locking Behavior \n"
"We shall implement ordered locking behavior by keeping track of which "
"ordered locks are owned by a process. When a process tries to seize an "
"ordered lock, we shall first check to see whether the process already owns "
"an ordered lock at a higher level. If so, the lock is considered \"out of "
"order\" and invalid; an error is signaled and we do not allow the process to "
"seize that lock. Otherwise, the lock is considered \"in order\" and valid, "
"so we do allow the process to seize it."
msgstr ""
"### Реализация Поведения Упорядоченной  Блокировки(Ordered Locking)\n"
"Мы будем реализовывать поведение упорядоченной блокировки, отслеживая, какие"
" упорядоченные блокировки принадлежат процессу. Когда процесс пытается"
" захватить упорядоченную блокировку, мы сначала проверим, владеет ли процесс"
" уже упорядоченной блокировкой на более высоком уровне. Если это так,"
" блокировка считается \"неисправной\" и недействительной; выдается сообщение"
" об ошибке, и мы не позволяем процессу перехватить эту блокировку. В"
" противном случае блокировка считается \"в порядке\" и действительной,"
" поэтому мы разрешаем процессу захватить ее."

#: ./en/ch03.md:911
msgid ""
"We use a hash table to keep track of the ordered locks owned by each "
"process. The first two functions are used to update the table when a process "
"seizes or releases an ordered lock; the second two functions examine the "
"table."
msgstr ""
"Мы используем хэш-таблицу для отслеживания упорядоченных блокировок,"
" принадлежащих каждому процессу. Первые две функции используются для"
" обновления таблицы, когда процесс захватывает или освобождает упорядоченную"
" блокировку; вторые две функции проверяют таблицу."

#: ./en/ch03.md:916
msgid ""
"<pre>\n"
"(defvar *process-lock-table* (make-hash-table) \n"
"  \"Each key is a process identifier; \n"
"value is a list of ordered locks it owns\") "
msgstr ""

#: ./en/ch03.md:921
msgid ""
"(defun add-process-lock (process lock) \n"
"   (without-process-preemption \n"
"       (push lock \n"
"             (gethash process *process-lock-table*)))) "
msgstr ""

#: ./en/ch03.md:928
msgid ""
"(defun delete-process-lock (process lock) \n"
"   (without-process-preemption \n"
"       (let ((hash-entry \n"
"               (gethash process *process-lock-table*))) \n"
"          (setf (gethash process *process-lock-table*) \n"
"                (delete lock hash-entry))))) "
msgstr ""

#: ./en/ch03.md:932
msgid ""
"(defun get-process-locks (process) \n"
"   (without-process-preemption \n"
"       (gethash process *process-lock-table*))) "
msgstr ""

#: ./en/ch03.md:936
msgid ""
"(defun get-highest-lock (process) \n"
"   (first (get-process-locks process))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:938
msgid ""
"In this code, we assume that the gethash and setf of gethash operations are "
"not atomic, so we use without-process-preemption around the use of those "
"functions. Note that get-highest-lock depends on the first lock being the "
"highest lock. We rely on the caller of add-process-lock always adding a "
"higher level of lock; this is what ordered locking is all about. The "
"function delete-process-lock can delete any lock from a given process, but "
"it does not change the order of the remaining locks. "
msgstr ""
"В этом коде мы предполагаем, что gethash и setf операций gethash не являются"
" атомарными, поэтому мы используем without-process-preemption для"
" использования этих функций. Обратите внимание, что get-highest-lock зависит"
" от того, что первая блокировка является самой высокой блокировкой. Мы"
" полагаемся на то, что вызывающий add-process-lock всегда добавляет более"
" высокий уровень блокировки; в этом и заключается суть упорядоченной"
" блокировки. Функция delete-process-lock может удалить любую блокировку из"
" данного процесса, но она не изменяет порядок остальных блокировок."

#: ./en/ch03.md:940
msgid ""
"The hash table is a simple and effective way of storing the association "
"between a process and the ordered locks it owns. In some Lisp "
"implementations, the process itself would be implemented as an instance of a "
"class. In these cases, each process might have a slot in which it stores a "
"list of its ordered locks; this would replace the hash-table mechanism. "
msgstr ""
"Хэш-таблица - это простой и эффективный способ хранения связи между процессом"
" и упорядоченными блокировками, которыми он владеет. В некоторых реализациях"
" Lisp сам процесс будет реализован как экземпляр класса. В этих случаях у"
" каждого процесса может быть слот, в котором он хранит список своих"
" упорядоченных блокировок; это заменит механизм хэш-таблицы."

#: ./en/ch03.md:942
msgid ""
"The functions defined here are the interface to the association between "
"processes and their lists of ordered locks. We shall use that interface "
"within the methods that implement ordered locking. Nothing prevents us from "
"someday switching from the hash table to another representation. We could "
"redefine these functions to do their work differently without affecting the "
"callers of the functions. For example, we could change them from ordinary "
"functions to generic functions and methods without changing the callers."
msgstr ""
"Функции, определенные здесь, являются интерфейсом для связи между процессами"
" и их списками упорядоченных блокировок. Мы будем использовать этот интерфейс"
" в методах, реализующих упорядоченную блокировку. Ничто не мешает нам"
" когда-нибудь переключиться с хэш-таблицы на другое представление. Мы могли"
" бы переопределить эти функции, чтобы они выполняли свою работу по-другому,"
" не влияя на вызывающих функции. Например, мы могли бы изменить их с обычных"
" функций на обобщенные функции и методы, не меняя вызывающих."

#: ./en/ch03.md:944
msgid "### Methods for Ordered Locks"
msgstr "### Методы для упорядоченных блокировок"

#: ./en/ch03.md:946
msgid ""
"Before we allow a process to seize an ordered lock, we check that it does "
"not currently own a lock with a higher level. We do this by defining a "
"before-method for seize. If the before-method determines it is valid for the "
"process to seize the lock, it simply returns. This method does not do any "
"actual locking, but assumes that another method will take care of that. If "
"the before-method determines that it is invalid for the process to seize "
"this lock, it signals an error. Since error never returns, no other method "
"is called. The invocation of the seize generic function is aborted by a "
"nonlocal exit caused by the call to error. Thus, this method can prevent the "
"lock from being seized, if necessary."
msgstr ""
"Прежде чем разрешить процессу захватить упорядоченную блокировку, мы"
" проверяем, что в данный момент он не владеет блокировкой более высокого"
" уровня. Мы делаем это, определяя метод before для seize. Если метод before"
" определяет, что для процесса допустимо захватить блокировку, он просто"
" возвращается. Этот метод не выполняет никакой фактической блокировки, но"
" предполагает, что об этом позаботится другой метод. Если метод before"
" определяет, что для процесса недопустимо захватывать эту блокировку, он"
" сигнализирует об ошибке. Поскольку ошибка никогда не возвращается, никакой"
" другой метод не вызывается. Вызов обобщенной функции seize прерывается"
" нелокальным завершением, вызванным вызовом error. Таким образом, этот метод"
" может предотвратить захват замка, если это необходимо."

#: ./en/ch03.md:962
msgid ""
"<pre>\n"
"(defmethod seize :before ((l ordered-lock-mixin)) \n"
"   \"Checks validity of this process seizing this ordered lock. \n"
"If invalid, signals an error. \n"
"If valid, does nothing and allows primary method to run.\" \n"
"   ;; First check for the mylock mistake to give the specific \n"
"   ;; error for that case, instead of the \"Out of order\" error, \n"
"   (check-for-mylock 1 *current-process*) \n"
"   ;; Now check for a possible infraction of ordered locking, \n"
"   (let ((highest-lock (get-highest-lock *current-process*))) \n"
"      (when (and highest-lock \n"
"                 (<= (lock-level 1) (lock-level highest-lock))) \n"
"         (error \"Out of order: Can't seize ~A while owning ~A\" \n"
"                l highest-lock)))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:964
msgid ""
"After a process has seized an ordered lock, it is necessary to update the "
"*process-lock-table* to associate this lock with the process. We do this "
"update with an after-method for seize:"
msgstr ""
"После того, как процесс захватил упорядоченную блокировку, необходимо"
" обновить *process-lock-table*, чтобы связать эту блокировку с процессом. Мы"
" делаем это обновление с помощью последующего метода для захвата:"

#: ./en/ch03.md:970
msgid ""
"<pre>\n"
"(defmethod seize :after ((l ordered-lock-mixin)) \n"
"   \"Adds the lock to the *process-lock-table*\" \n"
"   (add-process-lock *current-process* l)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:972
msgid ""
"Similarly, after releasing an ordered lock, we must update the *process-lock-"
"table*. We need another after-method to take care of this update: "
msgstr ""
"Аналогично, после снятия упорядоченной блокировки мы должны обновить"
" *process-lock-table*. Нам нужен другой последующий метод, чтобы позаботиться"
" об этом обновлении:"

#: ./en/ch03.md:980
msgid ""
"<pre>\n"
"(defmethod release :after ((l ordered-lock-mixin) \n"
"                           &optional failure-mode) \n"
"   \"Deletes a lock from the *process-lock-table*\" \n"
"   (declare (ignore failure-mode)) \n"
"   (delete-process-lock *current-process* l)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:982
msgid ""
"The class ordered-lock-mixin provides a before-method that checks for a "
"situation (in fact, for both the \"mylock\" and the \"out of order\" "
"mistakes) and an after-method that notes a situation (the new association "
"between the lock and the process). These are typical uses of before- and "
"after-methods."
msgstr ""
"Класс ordered-lock-mixin предоставляет метод before, который проверяет"
" наличие ситуации (фактически, как для ошибок \"mylock\", так и для ошибок"
" \"out of order\"), и метод after, который отмечает ситуацию (новая связь"
" между блокировкой и процессом). Это типичное использование методов"
" \"до\"(before-) и \"после\"(after-)."

#: ./en/ch03.md:984
msgid ""
"This is a simplified implementation of ordered locks, since this code does "
"not deal with the possibility of aborts happening at a bad time, leaving the "
"process table inconsistent with the actual state of the lock. These details "
"are omitted because they are irrelevant to the discussion of object-oriented "
"programming."
msgstr ""
"Это упрощенная реализация упорядоченных блокировок, поскольку в этом коде не"
" рассматривается возможность прерываний, происходящих в неподходящее время, в"
" результате чего таблица процессов не соответствует фактическому состоянию"
" блокировки. Эти подробности опущены, поскольку они не имеют отношения к"
" обсуждению объектно-ориентированного программирования."

#: ./en/ch03.md:986
msgid "## 3.9 HOW CLIENT PROGRAMS USE LOCKS "
msgstr "## 3.9 КАК КЛИЕНТСКИЕ ПРОГРАММЫ ИСПОЛЬЗУЮТ БЛОКИРОВКИ"

#: ./en/ch03.md:988
msgid ""
"So far, our locks have not been connected with any shared resource. One way "
"to make a resource lockable is to incorporate a lock into the data structure "
"representing the resource. You then write functions for accessing the data "
"structure that first seize the lock, then access the data structure, and "
"finally release the lock."
msgstr ""
"До сих пор наши блокировки не были связаны ни с каким общим ресурсом. Один из"
" способов сделать ресурс блокируемым - включить блокировку в структуру"
" данных, представляющую ресурс. Затем вы пишете функции для доступа к"
" структуре данных, которые сначала захватывают блокировку, затем получают"
" доступ к структуре данных и, наконец, снимают блокировку."

#: ./en/ch03.md:990
msgid "### Locking a Shared Queue"
msgstr "### Блокировка общей очереди(Shared Queue)"

#: ./en/ch03.md:992
msgid ""
"Consider how a print spooler might work. When a user requests a hardcopy "
"printout, the print spooler stores the print request in a queue until the "
"printer is ready, then sends the request to the printer. The print spooler "
"maintains a queue of print requests. Several processes can access this "
"queue, so it is important to guarantee that the queue is updated in a "
"consistent way. This is a good candidate for a client program of our locking "
"application. "
msgstr ""
"Рассмотрим, как может работать диспетчер очереди печати. Когда пользователь"
" запрашивает распечатку на бумажном носителе, диспетчер очереди печати"
" сохраняет запрос на печать в очереди до тех пор, пока принтер не будет"
" готов, а затем отправляет запрос на принтер. Диспетчер очереди печати"
" поддерживает очередь запросов на печать. Несколько процессов могут получить"
" доступ к этой очереди, поэтому важно гарантировать, что очередь обновляется"
" согласованным образом. Это хороший кандидат для клиентской программы нашего"
" приложения блокировки."

#: ./en/ch03.md:994
msgid ""
"A simple lock is the right kind of lock here. These processes will not need "
"to own more than one lock at a time, so deadlock should not be a problem."
msgstr ""
"Простая блокировка(simple lock) - это правильный вид блокировки здесь. Этим"
" процессам не нужно будет владеть более чем одной блокировкой одновременно,"
" поэтому взаимоблокировка не должна быть проблемой."

#: ./en/ch03.md:996
msgid ""
"We can implement our queue of print requests by defining a class that "
"includes a slot for the lock and a slot for the list of print requests:"
msgstr ""
"Мы можем реализовать нашу очередь запросов на печать, определив класс,"
" который включает слот для блокировки и слот для списка запросов на печать:"

#: ./en/ch03.md:1004
msgid ""
"<pre>\n"
"(defclass print-request-queue () \n"
"  ((lock :accessor print-queue-lock \n"
"         :initform (make-simple-lock \"Print Queue\")) \n"
"   (requests :accessor print-requests\n"
"             :initform nil)) \n"
"  (:documentation \"Queue of pending print requests.\"))"
msgstr ""

#: ./en/ch03.md:1008
msgid ""
"(defun make-print-queue () \n"
"   (make-instance 'print-request-queue)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1010
msgid ""
"Here we create the print-request queue and define the constructor make-print-"
"queue. The constructor takes no arguments, so the two slots are initialized "
"to their default initial values. The lock slot is initialized with a simple "
"lock named \"Print Queue\" and the requests slot is initialized to the empty "
"list."
msgstr ""
"Здесь мы создаем очередь запросов на печать и определяем конструктор"
" make-print-queue. Конструктор не принимает аргументов, поэтому два слота"
" инициализируются их начальными значениями по умолчанию. Слот блокировки"
" инициализируется простой блокировкой с именем \"Очередь печати\", а слот"
" запросов инициализируется пустым списком."

#: ./en/ch03.md:1014
msgid ""
"<pre>\n"
"(defvar *print-queue* (make-print-queue)) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1016
msgid ""
"The following functions for modifying the queue take care of seizing the "
"lock, modifying the data structure, and releasing the lock. The unwind-"
"protect ensures that the lock gets released even if the operation is aborted."
msgstr ""
"Следующие функции для изменения очереди обеспечивают захват блокировки,"
" изменение структуры данных и снятие блокировки. Функция защиты от"
" разматывания гарантирует, что блокировка будет снята, даже если операция"
" будет прервана."

#: ./en/ch03.md:1025
msgid ""
"<pre>\n"
"(defun enqueue-print-request (r) \n"
"   (let ((lock (print-queue-lock *print-queue*))) \n"
"      (unwind-protect \n"
"           (progn (seize lock) \n"
"                  (push r (print-requests *print-queue*))) \n"
"         (release lock :no-error))))\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1027
msgid ""
"The dequeue-print-request function takes a request as an argument instead of "
"simply popping the first request off the list. This allows the caller—the "
"print spooler—to choose which request to print first. "
msgstr ""
"Функция dequeue-print-request принимает запрос в качестве аргумента вместо"
" того, чтобы просто удалять первый запрос из списка. Это позволяет вызывающей"
" стороне — диспетчеру очереди печати — выбирать, какой запрос печатать первым."

#: ./en/ch03.md:1038
msgid ""
"<pre>\n"
"(defun dequeue-print-request (r) \n"
"   (let ((lock (print-queue-lock *print-queue*))) \n"
"      (unwind-protect \n"
"           (progn \n"
"              (seize lock) \n"
"              (setf (print-requests *print-queue*) \n"
"                    (delete r (print-requests *print-queue*)))) \n"
"         (release lock :no-error))))\n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1040
msgid "### Supporting the Typical Use of Locks: with-lock "
msgstr "### Поддержка типичного использования блокировок: with-lock"

#: ./en/ch03.md:1042
msgid ""
"When we step back and look at the first client program, we see that both "
"enqueue-print-request and dequeue-print-request demonstrate the canonical "
"use of locks: first seizing the lock, then performing an operation, then "
"releasing the lock."
msgstr ""
"Когда мы отступаем назад и смотрим на первую клиентскую программу, мы видим,"
" что как запрос на печать в очереди, так и запрос на снятие с очереди"
" демонстрируют каноническое использование блокировок: сначала захват"
" блокировки, затем выполнение операции, затем снятие блокировки."

#: ./en/ch03.md:1044
msgid ""
"We can add a with-lock macro to the locking application to make it more "
"convenient for programs to use locks:"
msgstr ""
"Мы можем добавить макрос with-lock в приложение блокировки, чтобы программам"
" было удобнее использовать блокировки:"

#: ./en/ch03.md:1054
msgid ""
"<pre>\n"
"(defmacro with-lock ((lock) &body body) \n"
"   (let ((lock-var (gensym))) \n"
"      `(let ((,lock-var ,lock)) \n"
"        (unwind-protect \n"
"             (progn (seize ,lock-var) \n"
"                    ,@body) \n"
"           (release ,lock-var :no-error))))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1056
msgid ""
"This macro allows the developer of the client program to simplify the two "
"functions considerably: "
msgstr ""
"Этот макрос позволяет разработчику клиентской программы значительно упростить"
" обе функции:"

#: ./en/ch03.md:1061
msgid ""
"<pre>\n"
"(defun enqueue-print-request (r) \n"
"   (with-lock ((print-queue-lock *print-queue*)) \n"
"      (push r (print-requests *print-queue*))))"
msgstr ""

#: ./en/ch03.md:1067
msgid ""
"(defun dequeue-print-request (r) \n"
"   (with-lock ((print-queue-lock *print-queue*)) \n"
"      (setf (print-requests *print-queue*) \n"
"            (delete r (print-requests *print-queue*))))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1069
msgid "### Specializing describe for Print-Request Queues "
msgstr ""
"### Специализация describe для очередей запросов на печать(Print-Request"
" Queues)"

#: ./en/ch03.md:1071
msgid ""
"It is good style for the client program to specialize describe for the class "
"print-request-queue. Notice that this method does not seize the print-"
"request-queue before describing it. This means that, if the queue has an "
"owner, that process might be presently modifying the queue, so the pending "
"print requests might be changing."
msgstr ""
"Это хороший стиль для клиентской программы - специализировать describe для"
" класса print-request-queue. Обратите внимание, что этот метод не захватывает"
" print-request-queue перед его описанием. Это означает, что, если у очереди"
" есть владелец, этот процесс может в настоящее время изменять очередь,"
" поэтому ожидающие запросы на печать могут изменяться."

#: ./en/ch03.md:1073
msgid ""
"The reason we do not seize the queue is that we believe it is more valuable "
"for describe to show the owner of a lock if it is busy, rather than waiting "
"until the queue is free. If we waited for the queue to become free, it would "
"be impossible to use describe for debugging in cases where one process waits "
"while owning the lock, because describe would also wait."
msgstr ""
"Причина, по которой мы не захватываем очередь, заключается в том, что мы"
" считаем, что для describe(описания) более ценно показывать владельца"
" блокировки, если она занята, а не ждать, пока очередь освободится. Если бы"
" мы ждали, пока очередь освободится, было бы невозможно использовать describe"
" для отладки в случаях, когда один процесс ожидает, владея блокировкой,"
" потому что describe также будет ждать."

#: ./en/ch03.md:1086
msgid ""
"<pre>\n"
"(defmethod describe ((queue print-request-queue)) \n"
"   (let ((owner (lock-owner (print-queue-lock queue))) \n"
"         (requests (print-requests queue))) \n"
"      (if owner \n"
"          (format t \"~SProcess ~A owns queue.~%\" owner)) \n"
"      (format t (if (null requests) \n"
"                    \"~SThere are no print requests.~%\" \n"
"                    \"~SPending print requests:~%\")) \n"
"      (dolist (x requests) \n"
"         (format t \"~S~A \" x)))) \n"
"</pre>"
msgstr ""

#: ./en/ch03.md:1088
msgid "## 3.10 REVIEWING THE LOCK CLASSES "
msgstr "## 3.10 ОБЗОР КЛАССОВ БЛОКИРОВОК"

#: ./en/ch03.md:1090
msgid ""
"Imagine that you are going to describe the structure of the locking program "
"to another programmer. When describing the organization of an object-"
"oriented program, you would probably need to answer questions like these:"
msgstr ""
"Представьте, что вы собираетесь описать структуру программы блокировки"
" другому программисту. При описании организации объектно-ориентированной"
" программы вам, вероятно, потребуется ответить на подобные вопросы:"

#: ./en/ch03.md:1094
msgid ""
"\t> What is the set of classes? \n"
"\t> What does each class contribute to the whole? \n"
"\t> How do the classes interact? "
msgstr ""
"\t> Что представляет собой набор классов?\n"
"\t> Какой вклад вносит каждый класс в целое?\n"
"\t> Как взаимодействуют классы?"

#: ./en/ch03.md:1096
msgid ""
"Once we have collected this information, we shall take a close look at the "
"class ordered-lock, to see how it works. "
msgstr ""
"Как только мы соберем эту информацию, мы внимательно рассмотрим класс"
" ordered-lock, чтобы увидеть, как он работает."

#: ./en/ch03.md:1098
msgid "### What Is the Set of Classes?"
msgstr "### Что представляет собой набор классов?"

#: ./en/ch03.md:1100
msgid ""
"The first two classes are building blocks that are not intended to stand "
"alone. The remaining four classes support the complete locking protocol and "
"can stand alone. This distinction is important."
msgstr ""
"Первые два класса - это строительные блоки, которые не предназначены для"
" самостоятельной работы. Остальные четыре класса поддерживают полный протокол"
" блокировки и могут работать автономно. Это различие очень важно."

#: ./en/ch03.md:1102
msgid "\t>  Class                 Description"
msgstr "\t>  Class                  Описание класса"

#: ./en/ch03.md:1104
msgid "\t>  lock                  Foundation of all locks."
msgstr "\t>  lock                   Основа всех блокировок"

#: ./en/ch03.md:1107
msgid ""
"\t>  ordered-lock-mixin    A mixin that supports ordered locking behavior; "
"an integral part of\n"
"\t>                        all ordered locks."
msgstr ""
"\t> ordered-lock-mixin     Примесь, поддерживающая упорядоченное поведение"
" блокировки; неотъемлемая \n"
"\t>                                часть всех упорядоченных блокировок."

#: ./en/ch03.md:1110
msgid ""
"\t>  simple-lock           A lock that is either busy or free. When busy, it "
"stores its owner.\n"
"\t>                        Constructor is make-simple-lock."
msgstr ""
"\t> simple-lock            Блокировка, которая либо занята, либо свободна."
" Когда она занята, она сохраняет \n"
"\t>                             своего владельца. Конструктор"
" make-simple-lock."

#: ./en/ch03.md:1113
msgid ""
"\t> null-lock              A lock that is always free. It obeys the locking "
"protocol without seizing\n"
"\t>                        anything. Constructor is make-null-lock."
msgstr ""
"\t> null-lock              Блокировка, которая всегда свободна. Она"
" подчиняется протоколу блокировки, ничего \n"
"\t>                           не захватывая. Конструктор make-null-lock."

#: ./en/ch03.md:1116
msgid ""
"\t> ordered-lock           A lock that supports ordered locking and is "
"either busy or free.\n"
"\t>                        Constructor is make-ordered-lock."
msgstr ""
"\t> ordered-lock           Блокировка, которая поддерживает упорядоченную"
" блокировку и либо занята, либо \n"
"\t>                              свободна. Конструктор make-ordered-lock."

#: ./en/ch03.md:1119
msgid ""
"\t> ordered-null-lock      A lock that supports ordered locking but is "
"always free. It does not\n"
"\t>                        seize anything. Constructor is make-ordered-null-"
"lock. "
msgstr ""
"\t>ordered-null-lock       Блокировка, поддерживающая упорядоченную"
" блокировку, но всегда свободная. Ничего \n"
"\t>                              не захватывает. Конструктор"
" make-ordered-null-lock."

#: ./en/ch03.md:1121
msgid "### What Does Each Class Contribute? "
msgstr "### Какой вклад вносит каждый класс?"

#: ./en/ch03.md:1123
msgid ""
"A class can contribute slots and methods. Also, slot options are inherited; "
"that is, they affect the classes built on the class that gives the slot "
"option. For example, the slot options :initarg and :initform are inherited "
"by subclasses. If a class provides accessor methods, they are applicable for "
"subclasses as well. Here we concentrate on the slots and the methods that "
"support the locking protocol. We start by listing the slots that each class "
"supplies: "
msgstr ""
"Класс может предоставлять слоты и методы. Также наследуются опции слота; то"
" есть они влияют на классы, созданные на основе класса, предоставляющего"
" параметр(опцию) слота. Например, параметры слота :initarg и :initform"
" наследуются подклассами. Если класс предоставляет методы доступа, они"
" применимы и для подклассов. Здесь мы сосредоточимся на слотах и ​​методах,"
" поддерживающих протокол блокировки. Начнем с перечисления слотов, которые"
" предоставляет каждый класс:"

#: ./en/ch03.md:1132
msgid ""
"|   Class               |  Slots   |\n"
"|-----------------------|----------|\n"
"| lock                  | name     |\n"
"| ordered-lock-mixin    | level    |\n"
"| simple-lock           | owner    |\n"
"| null-lock             | none     |\n"
"| ordered-lock          | none     |\n"
"| ordered-null-lock     | none     |"
msgstr ""

#: ./en/ch03.md:1134
msgid "We now list the methods for seize and release: "
msgstr ""
"Теперь мы перечислим методы для seize(захвата) и release(освобождения):"

#: ./en/ch03.md:1143
msgid ""
"|    Class              | seize       |  release |\n"
"|-----------------------|-------------|----------|\n"
"| lock                  | none        | none     |\n"
"| ordered-lock-mixin    |before, after| after    |\n"
"| simple-lock           | primary     | primary  |\n"
"| null-lock             | primary     | primary  |\n"
"| ordered-lock          | none        | none     |\n"
"| ordered-null-lock     | none        | none     |"
msgstr ""

#: ./en/ch03.md:1145
msgid ""
"We now list the methods for describe and print-object. Notice that we "
"include the class standard-object here, because it supplies methods for "
"these generic functions:"
msgstr ""
"Теперь мы перечислим методы для describe и print-object. Обратите внимание,"
" что мы включаем здесь класс standard-object, поскольку он предоставляет"
" методы для этих обобщенных функций:"

#: ./en/ch03.md:1155
msgid ""
"|     Class             | describe    |print-object |\n"
"|-----------------------|-------------|-------------|\n"
"| standard-object       | primary     | primary     |\n"
"| lock                  | primary     | primary     |\n"
"| ordered-lock-mixin    | after       | none        |\n"
"| simple-lock           | after       | none        |\n"
"| null-lock             | none        | none        |\n"
"| ordered-lock          | none        | none        |\n"
"| ordered-null-lock     | none        | none        |"
msgstr ""

#: ./en/ch03.md:1157
msgid "### How Do the Classes Interact? "
msgstr "### Как Взаимодействуют Классы?"

#: ./en/ch03.md:1159
msgid ""
"The interaction of classes happens via inheritance. The key to understanding "
"how one class inherits from its superclasses is the class precedence list of "
"that class. We have catalogued what each class contributes to the whole. Now "
"we can describe any one class in detail by looking at its class precedence "
"list and collecting the contributions of each class in the list."
msgstr ""
"Взаимодействие классов происходит через наследование. Ключом к пониманию"
" того, как один класс наследует от своих суперклассов, является список"
" приоритетов этого класса. Мы составили каталог того, что каждый класс вносит"
" в общее дело. Теперь мы можем подробно описать любой класс, просмотрев"
" список приоритетов его классов и собрав вклад каждого класса в список."

#: ./en/ch03.md:1161
msgid ""
"The class precedence list of each class includes the class itself and all of "
"its superclasses, ordered from most to least specific. Although all user-"
"defined classes have standard-object and t at the end of their class "
"precedence lists, we omit these system-supplied classes here, because they "
"are a given."
msgstr ""
"Список приоритетов классов каждого класса включает в себя сам класс и все его"
" суперклассы, упорядоченные от наиболее специфичных к наименее специфичным."
" Хотя все пользовательские классы имеют standard-object и t в конце своих"
" списков приоритета классов, мы опускаем здесь эти системные классы,"
" поскольку они являются заданными."

#: ./en/ch03.md:1172
msgid ""
"| Class                | Class Precedence List                |\n"
"|----------------------|--------------------------------------|\n"
"| lock                 | (lock)                               |\n"
"| ordered-lock-mixin   | (ordered-lock-mixin)                 |\n"
"| simple-lock          | (simple-lock lock)                   |\n"
"| null-lock            | (null-lock lock)                     |\n"
"| ordered-lock         | (ordered-lock ordered-lock-mixin     |\n"
"|                      |  simple-lock lock)                   |\n"
"| ordered-null-lock    | (ordered-null-lock ordered-lock-mixin| \n"
"|                      |  null-lock lock)                     |"
msgstr ""

#: ./en/ch03.md:1174
msgid "### Examining Ordered Locks"
msgstr "### Проверка Упорядоченных Блокировок"

#: ./en/ch03.md:1176
msgid ""
"We use the information gathered in the previous sections to take a closer "
"look at the class ordered-lock. What slots does it have? Look at each class "
"in its class precedence list to see what slots they provide. The following "
"table shows that ordered-lock has three slots: level, owner, and name. (The "
"classes standard-object and t have no slots and are not shown.)"
msgstr ""
"Мы используем информацию, собранную в предыдущих разделах, чтобы более"
" подробно рассмотреть класс ordered-lock. Какие слоты в нем есть? Посмотрите"
" на каждый класс в его списке приоритетов классов, чтобы увидеть, какие слоты"
" они предоставляют. В следующей таблице показано, что упорядоченная"
" блокировка имеет три слота: level(уровень), owner(владелец) и name(имя)."
" (Классы standard-object и t не имеют слотов и не показаны.)"

#: ./en/ch03.md:1183
msgid ""
"|     Class          | Slots  |\n"
"|--------------------|--------|\n"
"| ordered-lock       | none   |\n"
"| ordered-lock-mixin | level  |\n"
"| simple-lock        | owner  |\n"
"| lock               | name   |"
msgstr ""

#: ./en/ch03.md:1185
msgid ""
"How does the class ordered-lock implement the seize generic function? Look "
"at the classes in its class precedence list to see what methods they provide "
"for seize: "
msgstr ""
"Как класс ordered-lock реализует обобщенную функцию seize? Посмотрите на"
" классы в его списке приоритетов классов, чтобы узнать, какие методы они"
" предоставляют для seize:"

#: ./en/ch03.md:1192
msgid ""
"|   Class           | Method for seize |\n"
"|-------------------|------------------|\n"
"| ordered-lock      | none             |\n"
"| ordered-lock-mixin| before, after    |\n"
"| simple-lock       | primary          |\n"
"| lock              | none             |"
msgstr ""

#: ./en/ch03.md:1194
msgid ""
"When seize is called on an instance of ordered-lock, the following methods "
"are called:"
msgstr ""
"Когда seize вызывается для экземпляра ordered-lock, вызываются следующие"
" методы:"

#: ./en/ch03.md:1198
msgid ""
"1. The before-method provided by ordered-lock-mixin, which checks the "
"validity of allowing this process to seize this ordered lock \n"
"2. The primary method provided by simple-lock, which stores the process "
"identifier in the owner slot \n"
"3. The after-method provided by ordered-lock-mixin, which updates the "
"*process-lock-table* to note that this process now owns this ordered lock"
msgstr ""
"1. Метод before, предоставляемый ordered-lock-mixin, который проверяет"
" действительность разрешения этому процессу захватить эту упорядоченную"
" блокировку\n"
"2. Основной метод, предоставляемый simple-lock, который сохраняет"
" идентификатор процесса в слоте владельца\n"
"3. Последующий метод, предоставляемый ordered-lock-mixin, который обновляет"
" *process-lock-table*, чтобы отметить, что этот процесс теперь владеет этой"
" упорядоченной блокировкой"

#: ./en/ch03.md:1200
msgid ""
"We can go through this same procedure to inspect any lock class, to find out "
"what slots it has and how it implements any of these generic functions."
msgstr ""
"Мы можем пройти через ту же процедуру, чтобы проверить любой класс"
" блокировки, чтобы выяснить, какие слоты у него есть и как он реализует любую"
" из этих универсальных функций."

#: ./en/ch03.md:1202
msgid "### 3.11 THE EXTERNAL AND INTERNAL PERSPECTIVES "
msgstr "### 3.11 ВНЕШНЯЯ И ВНУТРЕННЯЯ ПЕРСПЕКТИВЫ"

#: ./en/ch03.md:1204
msgid ""
"We originally intended to write the methods that would support the locking "
"protocol. In the course of developing the program, we defined additional "
"methods, a macro, and several functions. Here we categorize each of these "
"Lisp operations according to their purpose: Which are part of the external "
"interface, and which are internal? "
msgstr ""
"Первоначально мы намеревались написать методы, которые поддерживали бы"
" протокол блокировки. В ходе разработки программы мы определили"
" дополнительные методы, макрос и несколько функций. Здесь мы классифицируем"
" каждую из этих операций Lisp в соответствии с их назначением: какие из них"
" являются частью внешнего интерфейса, а какие являются внутренними?"

#: ./en/ch03.md:1206
msgid "### External Locking Protocol "
msgstr "### Внешний Протокол Блокировки"

#: ./en/ch03.md:1208
msgid ""
"The external locking protocol consists of the constructors and the locking "
"operations. Client programs are expected to create their own locks by using "
"these constructors and to use seize and release to manipulate the locks. "
msgstr ""
"Внешний Протокол блокировки состоит из конструкторов и операций блокировки."
" Ожидается, что клиентские программы будут создавать свои собственные"
" блокировки с помощью этих конструкторов и использовать захват и освобождение"
" для управления блокировками."

#: ./en/ch03.md:1213
msgid ""
"|  seize           |  release              |\n"
"|------------------|-----------------------|\n"
"|make-simple-lock  | make-null-lock        |\n"
"|make-ordered-lock | make-ordered-null-lock| "
msgstr ""

#: ./en/ch03.md:1215
msgid "### Support for Other Protocols "
msgstr "### Поддержка других протоколов"

#: ./en/ch03.md:1217
msgid ""
"These methods are intended for external use, but they are not part of the "
"locking protocol. Both describe and print-object have protocols of their "
"own, which our methods follow. "
msgstr ""
"Эти методы предназначены для внешнего использования, но они не являются"
" частью протокола блокировки. Как describe, так и print-object имеют"
" собственные протоколы, которым следуют наши методы."

#: ./en/ch03.md:1219
msgid "\t>  describe                     print-object"
msgstr ""

#: ./en/ch03.md:1221
msgid "###  Support for Using Locks "
msgstr "### Поддержка использования блокировок"

#: ./en/ch03.md:1223
msgid ""
"This macro is intended for external use. It is a syntactic extension to the "
"locking protocol."
msgstr ""
"Этот макрос предназначен для внешнего использования. Это синтаксическое"
" расширение протокола блокировки."

#: ./en/ch03.md:1225
msgid "\t>    with-lock"
msgstr ""

#: ./en/ch03.md:1227
msgid "### For Internal Use Only"
msgstr "### Только Для Внутреннего Использования"

#: ./en/ch03.md:1229
msgid ""
"We defined methods for generic functions, a macro, a special variable, and "
"several functions that are not part of the external interface to locking. "
"They are used within the implementation of locking or for debugging. The "
"following are intended for internal use only:"
msgstr ""
"Мы определили методы для обобщенных функций, макроса, специальной переменной"
" и нескольких функций, которые не являются частью внешнего интерфейса для"
" блокировки. Они используются в рамках реализации блокировки или для отладки."
" Нижеследующее предназначено только для внутреннего использования:"

#: ./en/ch03.md:1235
msgid ""
"\t>   lock-name                    lock-level \n"
"\t>   lock-owner                   (setf lock-owner) \n"
"\t>   setf-if                      get-process-locks \n"
"\t>   get-highest-lock             add-process-lock \n"
"\t>   delete-process-lock          *process-lock-table*"
msgstr ""

#: ./en/ch03.md:1237
msgid ""
"There is no guarantee to the clients of the locking program that internal "
"functions like these will always exist or always work in the same way they "
"work now. Similarly, the definitions of the classes could be modified later. "
"For example, the names of the slots can change, and slots can be added or "
"removed. These purely internal details are in the domain of the implementor, "
"who is free to change them for any reason."
msgstr ""
"Нет никакой гарантии для клиентов программы блокировки, что внутренние"
" функции, подобные этим, всегда будут существовать или всегда будут работать"
" так же, как они работают сейчас. Аналогичным образом, определения классов"
" могут быть изменены позже. Например, названия слотов могут изменяться, а"
" слоты могут быть добавлены или удалены. Эти чисто внутренние детали"
" находятся в ведении разработчика, который волен изменять их по любой причине."

#: ./en/ch03.md:1239
msgid "### Distinguishing the Internal from the External"
msgstr "### Отличать Внутреннее от внешнего"

#: ./en/ch03.md:1241
msgid ""
"CLOS does not enforce the distinction between the external and internal "
"perspectives. It is up to the programmer to design a program with this "
"separation as a design goal. The documentation of the program should "
"advertise only the external interface. "
msgstr ""
"CLOS не проводит различия между внешней и внутренней перспективами."
" Программист должен разрабатывать программу с таким разделением в качестве"
" цели проектирования. Документация программы должна предоставлять только"
" внешний интерфейс."

#: ./en/ch03.md:1243
msgid ""
"You can distinguish internal from external names with packages by setting up "
"a package for your program and exporting from the package only those symbols "
"that are intended to be external names. Common Lisp provides convenient ways "
"for a program to use the exported symbols of a package without encountering "
"the other symbols; these techniques include use-package and the single-colon "
"syntax for symbols. Using packages is a general Common Lisp technique, and "
"we do not cover it further in this book."
msgstr ""
"Вы можете различить внутренние имена от внешних с помощью пакетов, настроив"
" пакет для вашей программы и экспортировав из пакета только те символы,"
" которые предназначены для внешних имен. Common Lisp предоставляет программе"
" удобные способы использования экспортированных символов пакета, не"
" сталкиваясь с другими символами; эти методы включают использование пакета и"
" синтаксис символов с одним двоеточием. Использование пакетов - это общая"
" техника Common Lisp, и мы не рассматриваем его далее в этой книге."

#: ./en/ch03.md:1245
msgid "## 3.12 GUIDELINES ON DESIGNING PROTOCOLS"
msgstr "## 3.12 РУКОВОДСТВО ПО РАЗРАБОТКЕ ПРОТОКОЛОВ"

#: ./en/ch03.md:1247
msgid ""
"We have been quite strict with our definition of the locking protocol. This "
"strictness benefits the users, who can depend on the protocol's working as "
"advertised, and the implementor, who can modify the implementation without "
"disrupting the user community. CLOS offers the framework for defining a "
"protocol, but it is the responsibility of the programmer to invent a "
"protocol for a new application. In addition to recommending using packages, "
"we provide these guidelines to help you keep the internal functions separate "
"from the external protocol:"
msgstr ""
"Мы были довольно строги с нашим определением протокола блокировки. Такая"
" строгость выгодна пользователям, которые могут зависеть от работы протокола"
" в соответствии с объявлениями, и разработчику, который может изменять"
" реализацию, не нарушая работу сообщества пользователей. CLOS предлагает"
" набор инструментов для определения протокола, но ответственность за"
" изобретение протокола для нового приложения лежит на программисте. В"
" дополнение к рекомендациям по использованию пакетов, мы предоставляем эти"
" рекомендации, чтобы помочь вам отделить внутренние функции от внешнего"
" протокола:"

#: ./en/ch03.md:1251
msgid ""
"*   Restrict the user's access to the internal data structures. Our describe "
"methods give a good English description of simple locks and ordered locks. "
"The output does not reveal the names of the slots, which is an internal "
"implementation detail. The default method for describe probably would "
"display the names and values of the slots, but our methods avoid displaying "
"that internal view of the locks. \n"
"*   Provide constructor functions for creating the data structures. There "
"are two ways to create instances: use a constructor function or use make-"
"instance. In either case, the end result is the same, but a constructor "
"function encourages users to think of the object in more abstract, "
"conceptual terms. In contrast, make-instance gives away details of the "
"implementation. First, it publicizes that the conceptual object is "
"implemented as an instance of a class. If make-instance were part of the "
"advertised protocol, it would be awkward to change some aspects of the "
"implementation. It would be impossible to change the name of the class or "
"its initargs, or to switch to a defstruct representation of data, without "
"changing the advertised protocol. \n"
"*  Design the protocol to anticipate the needs of the users. When the "
"protocol offers all the power and flexibility that is needed by the user "
"community, there is little temptation for people to delve into the "
"impiementation. But sometimes a protocol is sufficient for the majority of "
"its users, while frustrating a small number of users by the lack of a needed "
"feature. These users might be motivated to search for an internal function "
"that supports that feature. If users begin to depend on an internal "
"function, the implementor is no longer free to change it. The valuable "
"distinction between interface and implementation becomes muddied. "
msgstr ""
"* Ограничить доступ пользователя к внутренним структурам данных. Наши методы"
" описания дают хорошее английское описание простых блокировок и упорядоченных"
" блокировок. Выходные данные не раскрывают названия слотов, что является"
" внутренней деталью реализации. Метод для describe(описания) по умолчанию,"
" вероятно, отображал бы имена и значения слотов, но наши методы избегают"
" отображения этого внутреннего представления блокировок.\n"
"* Предоставить функции конструктора для создания структур данных. Существует"
" два способа создания экземпляров: использовать функцию конструктора или"
" использовать make-instance. В любом случае конечный результат один и тот же,"
" но функция конструктора побуждает пользователей думать об объекте в более"
" абстрактных, концептуальных терминах. Напротив, make-instance выдает"
" подробную информацию о реализации. Во-первых, в нем сообщается, что"
" концептуальный объект реализован как экземпляр класса. Если бы make-instance"
" был частью рекламируемого(предоставляемого) протокола, было бы неудобно"
" изменять некоторые аспекты реализации. Было бы невозможно изменить имя"
" класса или его initargs, или переключиться на представление данных defstruct"
" без изменения объявленного протокола.\n"
"* Разработайте протокол таким образом, чтобы предвидеть потребности"
" пользователей. Когда протокол предлагает всю мощь и гибкость, необходимые"
" сообществу пользователей, у людей мало соблазна углубляться в реализацию. Но"
" иногда протокола достаточно для большинства его пользователей, в то время"
" как небольшое число пользователей разочаровывается отсутствием необходимой"
" функции. Эти пользователи могут быть мотивированы на поиск внутренней"
" функции, поддерживающей эту функциональность. Если пользователи начинают"
" зависеть от внутренней функции, разработчик больше не волен изменять ее."
" Ценное различие между интерфейсом и реализацией становится"
" смазанным(размытым).\n"

#: ./en/ch03.md:1253
msgid ""
"For example, our original design for locking anticipates the needs of "
"programs (the operations for creating, seizing, and releasing) and the needs "
"of people (hence the methods that print and describe locks). This design "
"seems quite adequate on paper, but one day we might find a user who wants to "
"change the name of a lock. A persistent user could investigate the "
"implementation, find out that the name is stored in a slot, and use the "
"primitive slot-value to change the value of that slot. (Even when there is "
"no accessor for a slot, you can access a slot by calling slot-value. We "
"discuss this in \"Accessors Versus slot-value,\" page 72.) "
msgstr ""
"Например, наш оригинальный проект блокировки предвосхищает потребности"
" программ (операции создания, захвата и освобождения) и потребности людей"
" (отсюда и методы, которые печатают и описывают блокировки). На бумаге этот"
" проект кажется вполне адекватным, но однажды мы можем найти пользователя,"
" который захочет изменить название блокировки. Постоянный пользователь может"
" исследовать реализацию, выяснить, что имя хранится в слоте, и использовать"
" примитив slot-value, чтобы изменить значение этого слота. (Даже если для"
" слота нет средства доступа, вы можете получить доступ к слоту, вызвав"
" slot-value. Мы обсуждаем это в разделе \"Средства доступа(Accessors) против"
" slot-value(значения слота)\", стр. 72.)"

#: ./en/ch03.md:1255
msgid ""
"*   Allow the protocol to evolve to meet the reasonable needs of users. "
"Realistically, it is usually impossible to anticipate all needs of the users "
"in advance. When you hear of a need for a feature, you can consider adding a "
"new interface to the protocol. Some requests for features are reasonable, "
"such as changing the name of a lock or adding a \"reset-lock\" generic "
"function to the locking protocol. You might judge some as unreasonable, such "
"as wanting to convert a simple lock into an ordered lock. If you decide the "
"feature should be available, you can extend the protocol in a compatible and "
"controlled way."
msgstr ""
"* Разрешить протоколу развиваться в соответствии с разумными потребностями"
" пользователей. На самом деле, как правило, невозможно заранее предвидеть все"
" потребности пользователей. Когда вы услышите о необходимости какой-либо"
" функции, вы можете рассмотреть возможность добавления нового интерфейса к"
" протоколу. Некоторые запросы на функции являются разумными, например,"
" изменение имени блокировки или добавление обобщенной функции"
" \"reset-lock\"(сброс блокировки) в протокол блокировки. Вы можете счесть"
" некоторые из них неразумными, например, желание преобразовать простую"
" блокировку в упорядоченную блокировку. Если вы решите, что эта функция"
" должна быть доступна, вы можете расширить протокол совместимым и"
" контролируемым способом."

#: ./en/ch03.md:1258
msgid ""
"We have said that there are two choices for users who find the existing "
"protocol useful but not exactly appropriate for their applications: \n"
"They can dive into the internals and make use of them at their own risk, or "
"they can submit a request to the implementor to add new features. The first "
"avenue is not recommended, and the second might involve a delay or even a "
"refusal by the implementor."
msgstr ""
"Мы уже говорили, что есть два варианта для пользователей, которые находят"
" существующий протокол полезным, но не совсем подходящим для их приложений:\n"
"Они могут погрузиться во внутренние компоненты и использовать их на свой"
" страх и риск, или они могут отправить запрос разработчику на добавление"
" новых функций. Первый путь не рекомендуется, а второй может повлечь за собой"
" задержку или даже отказ со стороны исполнителя."

#: ./en/ch03.md:1260
msgid ""
"There is another alternative. You can offer a lot of flexibility and power "
"by designing the protocol so that other people can extend it. This is an "
"entirely different approach; it entails designing and documenting a set of "
"classes to be building blocks for user programs. This goal is more ambitious "
"and requires careful design work to achieve, but the benefits can be "
"valuable. We add one final guideline that describes this approach. "
msgstr ""
"Есть и другая альтернатива. Вы можете предложить большую гибкость и мощь,"
" разработав протокол таким образом, чтобы другие люди могли его расширять."
" Это совершенно другой подход; он предполагает разработку и документирование"
" набора классов, которые будут строительными блоками для пользовательских"
" программ. Эта цель более амбициозна и требует тщательной проектной работы"
" для достижения, но преимущества могут быть ценными. Мы добавим еще одно"
" заключительное руководство, описывающее этот подход."

#: ./en/ch03.md:1262
msgid ""
"Design some protocols to be extensible by the user. The usual way for a user "
"to extend an existing protocol is to define new classes that include some "
"combination of the existing classes. This way users can take advantage of "
"the existing modules and tailor them to their own purposes. Users should not "
"interfere with the workings of the classes provided by the protocol; instead "
"of writing methods for the advertised classes, users write methods for their "
"own customized classes. "
msgstr ""
"Разработайте некоторые протоколы так, чтобы они могли быть расширяемы"
" пользователем. Обычный способ для пользователя расширить существующий"
" протокол - это определить новые классы, которые включают некоторую"
" комбинацию существующих классов. Таким образом, пользователи могут"
" воспользоваться преимуществами существующих модулей и адаптировать их к"
" своим собственным целям. Пользователи не должны вмешиваться в работу"
" классов, предоставляемых протоколом; вместо написания методов для"
" объявленных классов пользователи пишут методы для своих собственных"
" настроенных(пользовательских) классов."

#: ./en/ch03.md:1264
msgid ""
"This last approach paves the way for future extensions of the program, "
"whether those extensions are done by other in-house programmers or by "
"customers of the product. "
msgstr ""
"Этот последний подход прокладывает путь для будущих расширений программы,"
" независимо от того, выполняются ли эти расширения другими штатными"
" программистами или заказчиками продукта."

#: ./en/ch03.md:1266
msgid ""
"Consider how this approach can be used by people who develop and sell "
"computer systems for others to program. The original developer supplies "
"documented modules that use knowledge of the internals of the machine ("
"including hardware and microcode) and exploit the machine's power to best "
"advantage. The users can define new classes built on the advertised modules "
"and can customize the new, aggregate classes; they are freed from writing "
"the lower level of code themselves. Meanwhile, the developers retain the "
"freedom to change the underlying mechanism, to track upgrades to the "
"internals of the machine. Developers have only two requirements: they must "
"document the interface, and then adhere to it."
msgstr ""
"Подумайте, как этот подход может быть использован людьми, которые"
" разрабатывают и продают компьютерные системы для программирования других."
" Первоначальный разработчик предоставляет документированные модули, которые"
" используют знания о внутренних компонентах машины (включая аппаратное"
" обеспечение и микрокод) и максимально эффективно используют возможности"
" машины. Пользователи могут определять новые классы, построенные на основе"
" объявленных модулей, и могут настраивать новые, агрегированные классы; они"
" освобождаются от самостоятельного написания кода более низкого уровня. В то"
" же время разработчики сохраняют свободу изменять базовый механизм,"
" отслеживать обновления внутренних компонентов машины. У разработчиков есть"
" только два требования: они должны задокументировать интерфейс, а затем"
" придерживаться его."

#: ./en/ch03.md:1269
msgid ""
"One portion of the locking example illustrates leaving a hook in the code "
"for future extensibility. We defined a method for check-for-mylock for the "
"class simple-lock; the method signals an error if the process attempting to "
"seize a lock already owns that lock. It would be an easy matter to define a "
"new class of lock built on simple-lock that does not \n"
"signal an error in the mylock situation. We could define the new class and "
"give it exactly one method: a primary method for check-for-mylock that does "
"not do anything. This method would override the method for simple-lock and "
"thus prevent an error from being signaled. Note that, if we had defined "
"check-for-mylock as an ordinary function, it would not be a hook, because "
"clients could not specialize it for a given class. "
msgstr ""
"Одна часть примера блокировки иллюстрирует оставление крючка(хука/hook) в"
" коде для будущей расширяемости. Мы определили метод для check-for-mylock для"
" класса simple-lock; метод сигнализирует об ошибке, если процесс, пытающийся"
" захватить блокировку, уже владеет этой блокировкой. Было бы легко определить"
" новый класс блокировки, построенный на simple-lock, который не сигнализирует"
" об ошибке в ситуации mylock. Мы могли бы определить новый класс и дать ему"
" ровно один метод: основной метод для check-for-mylock(проверки на mylock),"
" который ничего не делает. Этот метод переопределит метод simple-lock и,"
" таким образом, предотвратит передачу сигнала об ошибке. Обратите внимание,"
" что, если бы мы определили check-for-mylock как обычную функцию, она не была"
" бы крючком(хуком), потому что клиенты не могли бы специализировать её для"
" данного класса."
