#. extracted from ./en/appendix-a.md
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.7.2\n"

#: ./en/appendix-a.md:3
msgid ""
"# Appendix A \n"
"# Glossary of CLOS Terminology"
msgstr ""

#: ./en/appendix-a.md:5
msgid "**Accessor**"
msgstr ""

#: ./en/appendix-a.md:9
msgid ""
"\t\tA generic function for reading or writing the value of a slot. The term "
"\"accessor\" includes\n"
"\t\tboth readers and writers. The :accessor slot option to defclass causes "
"methods for a reader\n"
"\t\tand a writer for that slot to be generated automatically. "
msgstr ""

#: ./en/appendix-a.md:11
msgid "**After-method**"
msgstr ""

#: ./en/appendix-a.md:15
msgid ""
"\t\tA method whose role is to be called after the primary method, usually to "
"do some sort of\n"
"\t\tcleanup work. The standard method combination recognizes an after-method "
"by the method\n"
"\t\tqualifier :after in the defmethod form. "
msgstr ""

#: ./en/appendix-a.md:17
msgid "**Aggregate class**"
msgstr ""

#: ./en/appendix-a.md:21
msgid ""
"\t\tA descriptive term for a class composed of several building block "
"classes. An aggregate\n"
"\t\tclass usually derives all its structure and behavior from its "
"superclasses and does not\n"
"\t\tprovide further customizations. "
msgstr ""

#: ./en/appendix-a.md:23
msgid "**Applicable method**"
msgstr ""

#: ./en/appendix-a.md:27
msgid ""
"\t\tA method whose required parameters are all satisfied by the "
"corresponding arguments to\n"
"\t\tthe generic function. When a generic function is called, CLOS locates "
"the set of applicable\n"
"\t\tmethods."
msgstr ""

#: ./en/appendix-a.md:29
msgid "**Argument**"
msgstr ""

#: ./en/appendix-a.md:31
msgid "\t\tAn object given as input to a function. "
msgstr ""

#: ./en/appendix-a.md:33
msgid "**Around-method**"
msgstr ""

#: ./en/appendix-a.md:40
msgid ""
"\t\tA method whose role is to surround all other kinds of methods. An around-"
"method usually\n"
"\t\tperforms some computation and uses call-next-method to invoke the before-"
"methods, primary\n"
"\t\tmethod, and after-methods. An around-method can set up an environment to "
"be in effect\n"
"\t\tduring the execution of the other methods, such as setting up a catch, "
"binding a special\n"
"\t\tvariable, or owning a lock. The standard method combination recognizes "
"an around-method by\n"
"\t\tthe method qualifier :around in the defmethod form. "
msgstr ""

#: ./en/appendix-a.md:42
msgid "**Basic class**"
msgstr ""

#: ./en/appendix-a.md:46
msgid ""
"\t\tA descriptive term for a class that is the root, or foundation, of a set "
"of classes. A\n"
"\t\tbasic class provides characteristics that all its subclasses have in "
"common, such as their\n"
"\t\ttype (for example, all locks are of type lock), and default methods. "
msgstr ""

#: ./en/appendix-a.md:48
msgid "**Before-method**"
msgstr ""

#: ./en/appendix-a.md:52
msgid ""
"\t\tA method whose role is to be called before the primary method, usually "
"to do some sort of\n"
"\t\tset-up work in advance of the primary method. The standard method "
"combination recognizes\n"
"\t\ta before-method by the method qualifier :before in the defmethod form. "
msgstr ""

#: ./en/appendix-a.md:54
msgid "**Built-in class**"
msgstr ""

#: ./en/appendix-a.md:58
msgid ""
"\t\tA predefined class that is implemented in a special system-dependent way;"
" in other words,\n"
"\t\tit is not implemented as a user-defined class. Many of the classes "
"corresponding to Common\n"
"\t\tLisp types (such as array, list, number, and t) are implemented as built-"
"in classes. "
msgstr ""

#: ./en/appendix-a.md:60
msgid "**Built-in method combination type** "
msgstr ""

#: ./en/appendix-a.md:64
msgid ""
"\t\tA predefined method combination type provided by CLOS. The default "
"method combination type\n"
"\t\tis called standard. The others are operator method combination types, "
"including: +, and,\n"
"\t\tappend, list, max, min, nconc, or, and progn. "
msgstr ""

#: ./en/appendix-a.md:66
msgid "**Class**"
msgstr ""

#: ./en/appendix-a.md:71
msgid ""
"\t\tA Common Lisp type that defines the structure and behavior of a set of "
"objects, which are\n"
"\t\tcalled instances of the class. The structure of the class lies in its "
"slots. The behavior\n"
"\t\tis implemented by methods. Classes can be \"built on\" other classes, to "
"inherit structure\n"
"\t\tand behavior from them. "
msgstr ""

#: ./en/appendix-a.md:73
msgid "**Class precedence list**"
msgstr ""

#: ./en/appendix-a.md:81
msgid ""
"\t\tA list of classes containing the class itself and all its superclasses, "
"ordered from most\n"
"\t\tto least specific. CLOS computes a class precedence list for each class, "
"based on the\n"
"\t\tdefclass forms of the class and all of its superclasses. The class "
"precedence list governs\n"
"\t\thow methods, slots, and other characteristics are inherited. When one "
"class is more specific\n"
"\t\tthan another, it has precedence (or dominance) over the other class. "
"Thus, if the two\n"
"\t\tclasses offer competing traits, the more specific class takes precedence "
"over the less\n"
"\t\tspecific class. "
msgstr ""

#: ./en/appendix-a.md:83
msgid "**Client**"
msgstr ""

#: ./en/appendix-a.md:86
msgid ""
"\t\tA Lisp program that uses a CLOS program; the client calls generic "
"functions defined by the\n"
"\t\tCLOS program. "
msgstr ""

#: ./en/appendix-a.md:88
msgid "**CLOS implementation**"
msgstr ""

#: ./en/appendix-a.md:92
msgid ""
"\t\tA body of code that supports CLOS as defined by the CLOS specification "
"and runs on a\n"
"\t\tparticular operating system. This term is useful for discussing "
"portability issues (issues\n"
"\t\tof writing programs with the intention of running them on different "
"operating systems). "
msgstr ""

#: ./en/appendix-a.md:94
msgid "**Constructor** "
msgstr ""

#: ./en/appendix-a.md:98
msgid ""
"\t\tA function used to create new instances. Constructors are ordinary Lisp "
"functions that\n"
"\t\tcall make-instance. Constructors provide a more abstract interface than "
"does make-instance,\n"
"\t\tand they can use the full power of Lisp argument processing. "
msgstr ""

#: ./en/appendix-a.md:100
msgid "**Default method**"
msgstr ""

#: ./en/appendix-a.md:104
msgid ""
"\t\tA descriptive term for a method whose purpose is to be inherited by a "
"family of classes.\n"
"\t\tCLOS provides several default methods, which we call \"system-supplied "
"default methods\" to\n"
"\t\tdistinguish them from methods that users define."
msgstr ""

#: ./en/appendix-a.md:106
msgid "**Direct subclass** "
msgstr ""

#: ./en/appendix-a.md:109
msgid ""
"\t\tA direct subclass is the inverse of a direct superclass. If the class "
"shape is a direct\n"
"\t\tsuperclass of the class triangle, then triangle is a direct subclass of "
"shape. "
msgstr ""

#: ./en/appendix-a.md:111
msgid "**Direct superclass** "
msgstr ""

#: ./en/appendix-a.md:117
msgid ""
"\t\tA class that is included in the defclass form of another class. The "
"relationship between\n"
"\t\ta class and its direct superclass is like that between a child and its "
"parent, in that\n"
"\t\tthere is no intervening  ancestor. A class inherits structure and "
"behavior from its direct\n"
"\t\tsuperclasses. Class inheritance is transitive, so a class inherits from "
"each of its direct\n"
"\t\tsuperclasses, their direct superclasses, and so on. "
msgstr ""

#: ./en/appendix-a.md:119
msgid "**Effective method** "
msgstr ""

#: ./en/appendix-a.md:123
msgid ""
"\t\tThe Lisp code that comprises the implementation of a generic function "
"for a given set\n"
"\t\tof arguments. An effective method combines the applicable methods "
"according to the method\n"
"\t\tcombination type. "
msgstr ""

#: ./en/appendix-a.md:125
msgid "**Generic dispatch** "
msgstr ""

#: ./en/appendix-a.md:131
msgid ""
"\t\tThe CLOS mechanism that occurs when a generic function is called. The "
"generic dispatch\n"
"\t\tchooses the implementation appropriate for the arguments. This entails "
"selecting the set\n"
"\t\tof applicable methods, ranking the applicable methods in precedence "
"order, combining the\n"
"\t\tapplicable methods into an effective method, calling the effective "
"method, and returning\n"
"\t\tthe values of the effective method. "
msgstr ""

#: ./en/appendix-a.md:133
msgid "**Generic function**"
msgstr ""

#: ./en/appendix-a.md:139
msgid ""
"\t\tA Lisp function whose implementation is distributed across one or more "
"methods. To the\n"
"\t\tcaller, a generic function looks like an ordinary Lisp function. It "
"accepts arguments,\n"
"\t\tperforms some operation, and returns values. Invisibly to the caller, an "
"internal and\n"
"\t\tautomatic procedure (the generic dispatch) occurs when a generic "
"function is called;\n"
"\t\tthis entails choosing the method or methods appropriate to the "
"arguments. "
msgstr ""

#: ./en/appendix-a.md:141
msgid "**Implementation**"
msgstr ""

#: ./en/appendix-a.md:147
msgid ""
"\t\tThe inner workings of a program or function. This information is usually "
"known to the\n"
"\t\tdeveloper of the program but is concealed from callers. The "
"implementation of an ordinary\n"
"\t\tfunction consists of the body of the defun, whereas the implementation "
"of a generic\n"
"\t\tfunction is distributed across a set of methods. See also \"CLOS "
"implementation\" in this\n"
"\t\tglossary. "
msgstr ""

#: ./en/appendix-a.md:149
msgid "**Individual method** "
msgstr ""

#: ./en/appendix-a.md:154
msgid ""
"\t\tA method that specializes one of its parameters on an individual Lisp "
"object. The\n"
"\t\tlambda-list of an individual method contains a parameter specializer "
"name such as\n"
"\t\t(eql form). This method is applicable if the corresponding argument is "
"eql to the\n"
"\t\tobject that is the value of form (and if all other specialized "
"parameters are satisfied). "
msgstr ""

#: ./en/appendix-a.md:156
msgid "**Inheritance** "
msgstr ""

#: ./en/appendix-a.md:159
msgid ""
"\t\tThe sharing of characteristics or behavior among related classes. CLOS "
"supports inheriting\n"
"\t\tmethods, slots, most slot options, and one class option. "
msgstr ""

#: ./en/appendix-a.md:161
msgid "**Initarg** "
msgstr ""

#: ./en/appendix-a.md:167
msgid ""
"\t\tAn argument given to make-instance to control the initialization of "
"instances. An initarg\n"
"\t\tcan be used to fill a slot with a value, or by an initialization method, "
"or both. Initargs\n"
"\t\tcan be used in related initialization tasks, such as updating an "
"instance when a class is\n"
"\t\tredefined, changing the class of an instance, and reinitializing an "
"instance. Initarg is\n"
"\t\tshorthand for \"initialization argument.\" "
msgstr ""

#: ./en/appendix-a.md:169
msgid "**Initform** "
msgstr ""

#: ./en/appendix-a.md:172
msgid ""
"\t\tA default value for a slot. The :initform slot option to defclass is "
"used to provide a\n"
"\t\tdefault value for a slot."
msgstr ""

#: ./en/appendix-a.md:174
msgid "**Instance** "
msgstr ""

#: ./en/appendix-a.md:181
msgid ""
"\t\tA Lisp object. With the advent of CLOS, every Lisp object is an instance "
"of a class. Objects\n"
"\t\tof the Common Lisp types, such as numbers, arrays, and lists, are "
"instances of classes whose\n"
"\t\tname is the same as the name of the type specifier. Other objects are "
"instances of\n"
"\t\tuser-defined classes. All instances of a given class have the same type, "
"the same structure,\n"
"\t\tand the same behavior. (Note that individual methods can be used to "
"cause one particular\n"
"\t\tinstance to behave differently from the other instances of its class.) "
msgstr ""

#: ./en/appendix-a.md:183
msgid "**Interface** "
msgstr ""

#: ./en/appendix-a.md:186
msgid ""
"\t\tThe information about a function (whether it is ordinary or generic) "
"that callers need to\n"
"\t\tknow, including: its expected arguments, the job it does, and its "
"returned values. "
msgstr ""

#: ./en/appendix-a.md:188
msgid "**Lambda-list** "
msgstr ""

#: ./en/appendix-a.md:191
msgid ""
"\t\tA list that specifies the names of parameters of a function. Methods and "
"generic functions\n"
"\t\thave lambda-lists, as do ordinary Lisp functions. "
msgstr ""

#: ./en/appendix-a.md:193
msgid "**Local slot** "
msgstr ""

#: ./en/appendix-a.md:197
msgid ""
"\t\tA slot that stores information about the state of an instance. A local "
"slot is defined when\n"
"\t\tthe :allocation :instance slot option to defclass is provided, or when "
"the :allocation slot\n"
"\t\toption is omitted. "
msgstr ""

#: ./en/appendix-a.md:199
msgid "**Metaobject** "
msgstr ""

#: ./en/appendix-a.md:202
msgid ""
"\t\tAn object that represents a CLOS element, such as a class object, method "
"object, or generic\n"
"\t\tfunction object."
msgstr ""

#: ./en/appendix-a.md:204
msgid "**Metaclass** "
msgstr ""

#: ./en/appendix-a.md:207
msgid ""
"\t\tA class whose instances are class objects, such as standard-class, built-"
"in-class, and\n"
"\t\tstructure-class."
msgstr ""

#: ./en/appendix-a.md:209
msgid "**Method**"
msgstr ""

#: ./en/appendix-a.md:215
msgid ""
"\t\tLisp code that implements a portion of (or the entire) implementation of "
"a generic function\n"
"\t\tfor a set of arguments. Like functions, methods take arguments, perform "
"some computation,\n"
"\t\tpossibly produce side effects, and return values. Unlike functions, "
"methods are never called\n"
"\t\tdirectly; they are called by the generic dispatch procedure. Each method "
"has a role, which\n"
"\t\tstates its purpose in the generic function and controls how it interacts "
"with other methods. "
msgstr ""

#: ./en/appendix-a.md:217
msgid "**Method combination type** "
msgstr ""

#: ./en/appendix-a.md:221
msgid ""
"\t\tA mechanism that specifies, for a generic function, what method roles "
"are allowed, how the\n"
"\t\tapplicable methods are combined into an effective method, and how the "
"values of the generic\n"
"\t\tfunction are computed. A method combination type is a Lisp object named "
"by a symbol."
msgstr ""

#: ./en/appendix-a.md:223
msgid "**Method qualifier** "
msgstr ""

#: ./en/appendix-a.md:227
msgid ""
"\t\tA symbol appearing in the defmethod form that indicates the method's "
"role. The symbols\n"
"\t\t:after, :before, and :around are three examples. A method whose "
"qualifier is :after is an\n"
"\t\tafter-method."
msgstr ""

#: ./en/appendix-a.md:229
msgid "**Method role** "
msgstr ""

#: ./en/appendix-a.md:233
msgid ""
"\t\tThe way this method interacts with the other applicable methods. The "
"method combination\n"
"\t\ttype uses the method's role when combining it with the other methods "
"into the effective\n"
"\t\tmethod."
msgstr ""

#: ./en/appendix-a.md:235
msgid "**Mixin class** "
msgstr ""

#: ./en/appendix-a.md:241
msgid ""
"\t\tA descriptive term for a class intended to be a building block for other "
"classes. It\n"
"\t\tusually supports some aspect of behavior orthogonal to the behavior "
"supported by other\n"
"\t\tclasses in the program; typically, this customization is supported in "
"before- and after-\n"
"\t\tmethods. A mixin class is not intended to interfere with other behavior, "
"so it usually\n"
"\t\tdoes not override primary methods supplied by other classes."
msgstr ""

#: ./en/appendix-a.md:243
msgid "**Multi-method** "
msgstr ""

#: ./en/appendix-a.md:247
msgid ""
"\t\tA method that specializes more than one parameter. The technique of "
"using multi-methods\n"
"\t\tis intended for operations whose implementation truly depends on the "
"type of more than\n"
"\t\tone argument."
msgstr ""

#: ./en/appendix-a.md:249
msgid "**Multiple inheritance** "
msgstr ""

#: ./en/appendix-a.md:256
msgid ""
"\t\tA system in which a class can share the characteristics and behavior of "
"more than one\n"
"\t\tdirect superclass. CLOS supports multipie inheritance, in that a class "
"can have any number\n"
"\t\tof direct superclasses. This flexibility makes all sorts of class "
"organizations possible,\n"
"\t\twhereas single inheritance is limited to strictly hierachical "
"organizations. CLOS controls\n"
"\t\tthe multiple inheritance by using a class precedence list, which "
"unambiguously states the\n"
"\t\tprecedence of each class with respect to the others."
msgstr ""

#: ./en/appendix-a.md:258
msgid "**Operator method combination types** "
msgstr ""

#: ./en/appendix-a.md:263
msgid ""
"\t\tA method combination type that defines a framework that combines all "
"applicable primary\n"
"\t\tmethods inside a Lisp function, macro, or special form. CLOS offers a "
"set of built-in\n"
"\t\toperator method combination types, and you can define new ones with the "
"short from of\n"
"\t\tdefine-method-combination."
msgstr ""

#: ./en/appendix-a.md:265
msgid "**Parameter**"
msgstr ""

#: ./en/appendix-a.md:270
msgid ""
"\t\tA specification of the expected input of a function, generic function, "
"method, or other\n"
"\t\tkind of Lisp operator. Each parameter specifies a variable name, which "
"is bound to the\n"
"\t\tcorresponding argument when the function is called. Methods can have "
"specialized parameters,\n"
"\t\twhich indicate the method's applicability, as well as variable names."
msgstr ""

#: ./en/appendix-a.md:272
msgid "**Parameter specializer** "
msgstr ""

#: ./en/appendix-a.md:278
msgid ""
"\t\tThe object indicated by a parameter specializer name. If a parameter "
"specializer name is\n"
"\t\ta class name, the parameter specializer is the class object named by "
"that name. If a\n"
"\t\tparameter specializer name is a list (eql form), the parameter "
"specializer is the list\n"
"\t\t(eql object), where object is the result of evaluating form at the time "
"the method is\n"
"\t\tdefined."
msgstr ""

#: ./en/appendix-a.md:280
msgid "**Parameter specializer name** "
msgstr ""

#: ./en/appendix-a.md:284
msgid ""
"\t\tThe portion of a specialized parameter appearing in a method's lambda-"
"list that indicates\n"
"\t\tthe applicability of the method. A parameter specializer name can be a "
"class name or a\n"
"\t\tlist (eql form)."
msgstr ""

#: ./en/appendix-a.md:286
msgid "**Primary method**"
msgstr ""

#: ./en/appendix-a.md:292
msgid ""
"\t\tA method whose role is to perform the bulk of the work of a generic "
"function. In the\n"
"\t\tstandard method combination, only the most specific applicable primary "
"method is called;\n"
"\t\thowever, a primary method can use call-next-method to cause the next "
"most specific\n"
"\t\tapplicable primary method to be called. The standard method combination "
"recognizes a\n"
"\t\tprimary method by the absence of any method qualifier in the defmethod "
"form. "
msgstr ""

#: ./en/appendix-a.md:294
msgid "**Procedural definition**"
msgstr ""

#: ./en/appendix-a.md:300
msgid ""
"\t\tA technique in which a high-level task is broken down into separate "
"generic functions,\n"
"\t\teach of which is responsible for a clearly defined portion of the task. "
"Usually there\n"
"\t\tis a default behavior for the generic functions. Programmers use these "
"generic functions\n"
"\t\tas entry points; they can control portions of the task by specializing "
"one or more of\n"
"\t\tthe generic functions."
msgstr ""

#: ./en/appendix-a.md:302
msgid "**Protocol**"
msgstr ""

#: ./en/appendix-a.md:306
msgid ""
"\t\tA definition of the behavior of a set of objects. Some protocols are "
"intended for\n"
"\t\tprogrammers who are developing client programs, whereas other protocols "
"are intended\n"
"\t\tfor programmers who wish to extend a program."
msgstr ""

#: ./en/appendix-a.md:308
msgid "**Reader**"
msgstr ""

#: ./en/appendix-a.md:311
msgid ""
"\t\tA generic function for reading the value of a slot. Reader methods can "
"be generated\n"
"\t\tautomatically, through use of the :accessor or :reader slot options to "
"defclass."
msgstr ""

#: ./en/appendix-a.md:313
msgid "**Shared slot**"
msgstr ""

#: ./en/appendix-a.md:317
msgid ""
"\t\tA slot that stores information about the state of a class (or of all "
"instances of the\n"
"\t\tclass). A shared slot is defined when the :allocation :class slot option "
"to defclass is\n"
"\t\tprovided."
msgstr ""

#: ./en/appendix-a.md:319
msgid "**Single inheritance**"
msgstr ""

#: ./en/appendix-a.md:323
msgid ""
"\t\tA system in which a class can be built on no more than one other class, "
"which in turn\n"
"\t\tcan be built on no more than one other class, and so on. Single "
"inheritance results in\n"
"\t\ta strictly hierarchical organization. Common Lisp defstruct supports "
"single inheritance."
msgstr ""

#: ./en/appendix-a.md:325
msgid "**Slot**"
msgstr ""

#: ./en/appendix-a.md:331
msgid ""
"\t\tA place where state information is stored. A slot has a name and a "
"value. The :allocation\n"
"\t\tslot option to defclass controls whether a slot is local or shared. A "
"local slot stores\n"
"\t\tinformation about the state of an instance, and a shared slot stores "
"information about the\n"
"\t\tstate of a class (or of all instances of the class). The value of a slot "
"can be read and\n"
"\t\twritten by accessors."
msgstr ""

#: ./en/appendix-a.md:333
msgid "**Specialized parameter** "
msgstr ""

#: ./en/appendix-a.md:337
msgid ""
"\t\tA parameter expressed as a list whose first element is a variable, and "
"whose second\n"
"\t\telement is a parameter specializer name. Any required parameter in a "
"method's lambda-list\n"
"\t\tmay be specialized."
msgstr ""

#: ./en/appendix-a.md:339
msgid "**standard-object**"
msgstr ""

#: ./en/appendix-a.md:342
msgid ""
"\t\tA class that is implicitly included in the class precedence list of "
"every user-defined\n"
"\t\tclass. Several default methods are attached to the class standard-"
"object. "
msgstr ""

#: ./en/appendix-a.md:344
msgid "**standard method combination type** "
msgstr ""

#: ./en/appendix-a.md:347
msgid ""
"\t\tThe default method combination type: It supports around- methods, before-"
"methods, primary\n"
"\t\tmethods, and after-methods."
msgstr ""

#: ./en/appendix-a.md:349
msgid "**Subclass**"
msgstr ""

#: ./en/appendix-a.md:352
msgid ""
"\t\tThe inverse of superclass. If the class t is a superclass of the class "
"triangle, then\n"
"\t\ttriangle is a subclass oft."
msgstr ""

#: ./en/appendix-a.md:354
msgid "**Superclass** "
msgstr ""

#: ./en/appendix-a.md:357
msgid ""
"\t\tA class from which another class inherits. The superclasses of a class "
"include all of its\n"
"\t\tdirect superclasses, all of their direct superclasses, and so on."
msgstr ""

#: ./en/appendix-a.md:359
msgid "**Unbound slot** "
msgstr ""

#: ./en/appendix-a.md:362
msgid ""
"\t\tA slot that has no value. A slot that was neither initialized nor "
"written to is unbound.\n"
"\t\tCLOS signals an error if an attempt is made to read the value of an "
"unbound slot."
msgstr ""

#: ./en/appendix-a.md:364
msgid "**Writer** "
msgstr ""

#: ./en/appendix-a.md:369
msgid ""
"\t\tA generic function for writing the value of a slot. Writer methods can "
"be generated\n"
"\t\tautomatically, through use of the :accessor or :writer slot options to "
"defclass.\n"
"\t\tUsually, the name of a writer is a list such as (setf reader); such a "
"writer is\n"
"\t\tcalled with the setf syntax, which is (setf [reader object) new-value). "
msgstr ""
