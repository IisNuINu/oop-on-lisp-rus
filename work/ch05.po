#. extracted from ./en/ch05.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-03 23:48+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch05.md:2
msgid "# Controlling the Generic Dispatch"
msgstr "# Управление Generic Dispatch(общей отправкой)"

#: ./en/ch05.md:4
msgid ""
"All the sample programs we have written so far rely on before-methods, "
"primary methods, and after-methods. We can call these techniques the \"core "
"framework\" of CLOS. This chapter describes how to use several advanced "
"techniques that expand the core framework or replace it entirely."
msgstr ""
"Все примеры программ, которые мы написали до сих пор, основаны на методах"
" before-(до), первичных методах и after-(после) методах. Мы можем назвать эти"
" методы \"основной структурой\" CLOS. В этой главе описывается, как"
" использовать несколько передовых методов, которые расширяют основную"
" структуру или полностью заменяют ее."

#: ./en/ch05.md:6
msgid "## 5.1 THE CORE FRAMEWORK"
msgstr "## 5.1 ОСНОВНАЯ РАБОЧАЯ СРЕДА(FRAMEWORK)"

#: ./en/ch05.md:8
msgid "In the core framework, the flow of control is as follows: "
msgstr ""
"В базовой рабочей среде(framework) поток управления выглядит следующим"
" образом:"

#: ./en/ch05.md:12
msgid ""
"1. All applicable before-methods are called in most-specific-first order \n"
"2. The most specific applicable primary method is called \n"
"3. All applicable after-methods are called in most-specific-last order"
msgstr ""
"1. Все применимые методы before вызываются в порядке"
" наиболее-специфичный-первым\n"
"2. Наиболее конкретный применимый первичный метод называется\n"
"3. Все применимые методы after вызываются в порядке"
" наиболее-специфичный-последний"

#: ./en/ch05.md:14
msgid ""
"In the core framework, any values of before- or after-methods are ignored, "
"and the generic function returns the values of the primary method. If there "
"is no applicable primary method, an error is signaled. "
msgstr ""
"В базовой рабочей среде(core framework) любые значения методов before или"
" after игнорируются, а обобщенная функция возвращает значения основного"
" метода. Если нет применимого основного метода, выдается сообщение об ошибке."

#: ./en/ch05.md:16
msgid "## 5.2 DECLARATIVE AND IMPERATIVE TECHNIQUES"
msgstr "## 5.2 ДЕКЛАРАТИВНЫЕ И ИМПЕРАТИВНЫЕ МЕТОДЫ"

#: ./en/ch05.md:18
msgid ""
"Within the context of the core framework, you declare the role of a method ("
"by its qualifier). We call this a declarative technique. You assign a role "
"to a method and rely on the generic dispatch procedure to call the "
"applicable methods according to their roles within the core framework."
msgstr ""
"В контексте базовой рабочей среды(core framework) вы объявляете роль метода"
" (по его квалификатору). Мы называем это декларативной техникой. Вы"
" назначаете роль методу и полагаетесь на общую процедуру отправки для вызова"
" применимых методов в соответствии с их ролями в базовой рабочей среде."

#: ./en/ch05.md:20
msgid ""
"This declarative technique works well for programs that fit naturally into "
"the core framework. However, sometimes you need to control the generic "
"dispatch procedure more directly. CLOS offers some imperative techniques "
"that enable you to control explicitly which method is called next. The "
"imperative techniques are"
msgstr ""
"Этот декларативный метод хорошо работает для программ, которые естественным"
" образом вписываются в базовую рабочую среду. Однако иногда вам необходимо"
" более непосредственно управлять общей процедурой отправки(generic dispatch)."
" CLOS предлагает несколько императивных методов, которые позволяют вам явно"
" контролировать, какой метод вызывается следующим. Обязательными методами"
" являются"

#: ./en/ch05.md:23
msgid ""
"*   Providing an around-method to \"wrap around\" the core framework \n"
"*   Calling a shadowed primary method"
msgstr ""
"* Предоставление around-метода для \"обертывания\" базовой рабочей среды\n"
"* Вызов затененного основного(primary) метода"

#: ./en/ch05.md:25
msgid ""
"CLOS also provides additional declarative techniques, both involving a "
"departure from the familiar method roles of the core framework. You can "
"specify that the generic dispatch should support different method roles and "
"use a different framework entirely."
msgstr ""
"CLOS также предоставляет дополнительные декларативные методы, оба из которых"
" предполагают отход от привычных ролей методов базовой рабочей среды. Вы"
" можете указать, что общая отправка должна поддерживать разные роли методов и"
" полностью использовать другую рабочую среду(framework)."

#: ./en/ch05.md:27
msgid ""
"CLOS supplies a set of built-in frameworks, which are called method "
"combination types. The method combination type controls what method roles "
"are supported, the order in which the various kinds of methods are called, "
"and how the values of the generic function are generated. You can either use "
"one of the built-in method combination types or invent a new one. Thus, the "
"new declarative techniques are"
msgstr ""
"CLOS предоставляет набор встроенных рабочих сред(frameworks/фреймворков),"
" которые называются типами комбинации методов. Тип комбинации методов"
" определяет, какие роли методов поддерживаются, порядок, в котором вызываются"
" различные типы методов, и как генерируются значения обобщенной функции. Вы"
" можете либо использовать один из встроенных типов комбинаций методов, либо"
" изобрести новый. Таким образом, новые декларативные методы являются"

#: ./en/ch05.md:30
msgid ""
"*   Using a built-in method combination type \n"
"*   Inventing and using a new method combination type"
msgstr ""
"* Использование встроенного типа комбинации методов\n"
"* Изобретение и использование нового типа комбинации методов"

#: ./en/ch05.md:32
msgid "## 5.3 AROUND-METHODS"
msgstr "## 5.3 AROUND-(ОКРУЖАЮЩИЕ) МЕТОДЫ"

#: ./en/ch05.md:34
msgid ""
"An around-method expands the core framework by wrapping a layer of code "
"around it. An around-method usually performs some computation and calls call-"
"next-method to invoke the methods of the core framework. To specify that a "
"method is an around-method, include the keyword :around as the method "
"qualifier in the defmethod form."
msgstr ""
"Метод around-(окружающий) расширяет базовую рабочую среду, обертывая(around)"
" ее слоем кода. Метод around обычно выполняет некоторые вычисления и вызывает"
" call-next-method для вызова методов базовой рабочей среды. Чтобы указать,"
" что метод является around, включите ключевое слово :around в качестве"
" квалификатора метода в форме defmethod."

#: ./en/ch05.md:37
msgid ""
"Around-methods offer a new kind of power that can be useful. They can set up "
"an environment to be in effect during the execution of the other methods. "
"For example, an around-method can set up a catch or bind a special variable. "
"An around-method can use with-lock to seize \n"
"and hold a lock while the other methods are called. Although you could use a "
"before-method to seize a lock and an after-method to release it, that would "
"not have the same effect as using with-lock in an around-method: using with-"
"lock ensures that the lock is released even if an abort occurs."
msgstr ""
"Around-(Окружающие) методы предлагают новый вид силы, который может быть"
" полезен. Они могут настроить среду, которая будет действовать во время"
" выполнения других методов. Например, обходной метод может настроить catch"
" или привязать специальную переменную. Around-метод может использовать"
" with-lock для захвата и удержания блокировки во время вызова других методов."
" Хотя вы могли бы использовать метод before для захвата блокировки и метод"
" after для ее снятия, это не имело бы того же эффекта, что использование"
" with-lock в around-методе: использование with-lock гарантирует, что"
" блокировка будет снята, даже если произойдет прерывание."

#: ./en/ch05.md:39
msgid ""
"When only one around-method is applicable, CLOS calls that around-method "
"first and returns its values as the values of the generic function. (This is "
"an important distinction from before- and after-methods, whose values are "
"ignored.) If that around-method calls call-next-method, the entire core "
"framework is called, and call-next-method returns the values of the core "
"framework to the around-method."
msgstr ""
"Когда применим только один around метод, CLOS сначала вызывает этот"
" around-метод и возвращает его значения как значения обобщенной функции. (Это"
" важное отличие от методов before и after, значения которых игнорируются.)"
" Если этот around-метод вызывает call-next-method, вызывается вся базовая"
" рабочая среда, а call-next-method возвращает значения базовой рабочей среды"
" в around-method."

#: ./en/ch05.md:41
msgid ""
"Around-methods are different from the methods we have seen so far, because "
"around-methods control which method is called next. If an around-method uses "
"call-next-method, the \"next method\" is called. If an around-method does "
"not use call-next-method, however, no other methods are called. Thus, an "
"around-method can prevent other methods from being called."
msgstr ""
"Around-методы отличаются от методов, которые мы видели до сих пор, потому что"
" around-методы управляют тем, какой метод вызывается следующим. Если"
" around-метод использует call-next-method, вызывается \"следующий метод\"."
" Однако, если around-метод не использует call-next-method, никакие другие"
" методы не вызываются. Таким образом, around-метод может препятствовать"
" вызову других методов."

#: ./en/ch05.md:43
msgid ""
"In the general case, any number of around-methods can be applicable. In "
"summary, the generic dispatch works like this:"
msgstr ""
"В общем случае может быть применимо любое количество around-методов. Таким"
" образом, общая отправка(generic dispatch) работает следующим образом:"

#: ./en/ch05.md:45
msgid ""
"1. CLOS calls the most specific around-method; its values are the values of "
"the generic function."
msgstr ""
"1. CLOS вызывает наиболее специфичный around-метод; его значения являются"
" значениями обобщенной функции."

#: ./en/ch05.md:49
msgid ""
"2. When an around-method calls call-next-method \n"
"*   If there are other applicable around-methods, the next most specific "
"around-method is called, and its values are returned by call-next-method. \n"
"*    If not, the entire core framework (before-methods, the primary method, "
"and after-methods) is called, and its values are returned by call-next-"
"method."
msgstr ""
"2. Когда around-метод вызывает call-next-method\n"
"   * Если существуют другие применимые around-методы, вызывается следующий"
" наиболее   специфичный around-метод, и его значения возвращаются"
" call-next-method.\n"
"   * Если нет, вызывается вся базовая рабочая среда (методы before-(до),"
" основной метод и методы after-(после)), и ее значения возвращаются"
" call-next-method. "

#: ./en/ch05.md:51
msgid "### Example of an Around-Method"
msgstr "### Пример Around-метода"

#: ./en/ch05.md:53
msgid ""
"As a simple example, we might provide an around-method to keep track of how "
"long an installation process takes. The role of the around-method is well "
"suited to the task of timing an installation. The following method is "
"applicable to all supported products and operating systems, and its role in "
"the generic dispatch ensures that it wraps around the entire installation. "
"This method ordering allows it to start the timing before the other methods "
"run, and finish the timing after the other methods return. "
msgstr ""
"В качестве простого примера мы могли бы предоставить around-метод для"
" отслеживания того, сколько времени занимает процесс установки. Роль"
" around-метода хорошо подходит для задачи определения времени установки."
" Следующий метод применим ко всем поддерживаемым продуктам и операционным"
" системам, и его роль в generic dispatch(общей отправке) гарантирует, что он"
" охватывает всю установку. Этот порядок методов позволяет ему запускать"
" синхронизацию до запуска других методов и завершать синхронизацию после"
" возврата других методов."

#: ./en/ch05.md:68
msgid ""
"<pre>\n"
"(defmethod install :around \n"
"    ((sw basic-product) (os basic-os)) \n"
"   (declare (ignore sw os)) \n"
"   (let* ((start-time (get-internal-real-time)) \n"
"          (result (call-next-method))) \n"
"      (if (null result) ; normal completion \n"
"          (format t \"^Installation completed in ~A seconds.\" \n"
"                  (round (- (get-internal-real-time) \n"
"                            start-time) \n"
"                         internal-time-units-per-second)) \n"
"          (format t \"^Installation failed.\")) \n"
"      result))\n"
"</pre>"
msgstr ""

#: ./en/ch05.md:70
msgid ""
"The timing example illustrates some interesting aspects of around-methods: "
msgstr ""
"Пример синхронизации иллюстрирует некоторые интересные аспекты around-методов:"

#: ./en/ch05.md:75
msgid ""
"*   This method uses the value returned by call-next-method. This shows a "
"means for communication between methods that we have not seen in the core "
"framework. The around-method uses the result of the core framework to decide "
"which output to produce, and then returns the result. It is customary, "
"although not required, for around-methods to return the value or values of "
"call-next-method. \n"
"*    This method works correctly only if there is no other applicable around-"
"method. If there were a more specific around-method, it would be called "
"before this one, so this method would not be timing the complete "
"installation. This is one example of how around-methods can be tricky; "
"often, you need explicit knowledge of the other applicable methods in order "
"to write an around-method. Thus, using around-methods can lead to nonmodular "
"code. \n"
"*     This around-method specializes on two basic classes, yet it is the "
"first method called by the generic dispatch (since there are no other "
"applicable around-methods). An around-method allows you to define code "
"associated with less specific classes to perform some computation in advance "
"of the other kinds of methods provided by more specific classes. \n"
"*     Although this method always calls call-next-method, it is possible for "
"an around-method to choose not to call call-next-method. Therefore, an "
"around-method can prevent before-methods, the primary method, and after-"
"methods from being called. In contrast, a before-method cannot prevent other "
"methods from being called without using error or another function that "
"abandons the current computation. "
msgstr ""
"*    Этот метод использует значение, возвращаемое call-next-method. Это"
" показывает средства связи между методами, которые мы не видели в базовой"
" рабочей среде. Around-метод использует результат базовой рабочей среды,"
" чтобы решить, какой вывод производить, а затем возвращает результат. Для"
" around-методов обычно, хотя и не обязательно, возвращать значение или"
" значения call-next-method.\n"
"*    Этот метод работает корректно только в том случае, если нет другого"
" применимого обходного метода. Если бы существовал более конкретный"
" around-метод, он был бы вызван перед этим, поэтому этот метод не рассчитывал"
" бы время полной установки. Это один из примеров того, как around-методы"
" могут быть сложными; часто вам требуется явное знание других применимых"
" методов, чтобы написать around-метод. Таким образом, использование"
" around-(окружающих) методов может привести к немодулярному коду.\n"
"*      Этот around-метод специализируется на двух базовых классах, но это"
" первый метод, вызываемый общей диспетчеризацией(generic dispatch) (поскольку"
" других применимых around-методов нет). Around-метод позволяет вам определять"
" код, связанный с менее конкретными классами, для выполнения некоторых"
" вычислений перед другими типами методов, предоставляемых более конкретными"
" классами.\n"
"*     Хотя этот метод всегда вызывает call-next-method, around-метод может"
" выбрать не вызывать call-next-method. Следовательно, around-метод может"
" предотвратить вызов методов before-(до), основного метода и методов"
" after-(после). Напротив, метод before не может предотвратить вызов других"
" методов без использования ошибки или другой функции, которая прерывает"
" текущее вычисление."

#: ./en/ch05.md:77
msgid "## 5.4 CALLING A SHADOWED PRIMARY METHOD "
msgstr "## 5.4 ВЫЗОВ ЗАТЕНЕННОГО ОСНОВНОГО МЕТОДА"

#: ./en/ch05.md:79
msgid ""
"This section describes the second imperative technique. CLOS allows you to "
"expand the second step of the core framework: the calling of the primary "
"method. In the core framework, only the most specific primary method is "
"called. Any other applicable primary methods are \"shadowed\" by the most "
"specific one. However, the most specific primary method can call call-next-"
"method to invoke the next most specific primary method. The shadowed method "
"can return values, and its caller can continue to execute and make use of "
"those values."
msgstr ""
"В этом разделе описывается вторая императивная техника. CLOS позволяет вам"
" расширить второй шаг базовой рабочей среды: вызов основного метода. В"
" базовой платформе вызывается только самый конкретный основной метод. Любые"
" другие применимые первичные методы \"затеняются\" наиболее специфичным из"
" них. Однако наиболее специфичный основной метод может вызвать"
" call-next-method для вызова следующего наиболее специфичного основного"
" метода. Затененный метод может возвращать значения, и его вызывающий может"
" продолжать выполняться и использовать эти значения."

#: ./en/ch05.md:81
msgid ""
"CLOS signals an error if a generic function is called and there is no "
"applicable primary method. Also, if a method calls call-next-method and "
"there is no next method, CLOS signals an error. You can use next-method-p "
"within the body of a method to find out whether there is another applicable "
"primary method."
msgstr ""
"CLOS сигнализирует об ошибке, если вызывается обобщенная функция и нет"
" применимого основного метода. Кроме того, если метод вызывает"
" call-next-method, а следующего метода нет, CLOS сигнализирует об ошибке. Вы"
" можете использовать next-method-p в теле метода, чтобы выяснить, существует"
" ли другой применимый основной метод."

#: ./en/ch05.md:83
msgid ""
"Any primary method can call call-next-method, which results in the calling "
"of the next most specific primary method. Actually, a primary method can "
"call call-next-method more than once, and each time the same \"next method\" "
"is called."
msgstr ""
"Любой первичный метод может вызвать call-next-method, что приводит к вызову"
" следующего наиболее конкретного первичного метода. На самом деле, основной"
" метод может вызывать call-next-method более одного раза, и каждый раз"
" вызывается один и тот же \"следующий метод\"."

#: ./en/ch05.md:85
msgid "## 5.5 USING A DIFFERENT METHOD COMBINATION TYPE"
msgstr "## 5.5 ИСПОЛЬЗОВАНИЕ ДРУГОГО ТИПА КОМБИНАЦИИ МЕТОДОВ"

#: ./en/ch05.md:90
msgid ""
"CLOS enables you to specify that the generic dispatch should use an entirely "
"different framework and recognize different method roles. Each generic "
"function has a method combination type, which defines the framework that the "
"generic dispatch follows. The method combination type controls \n"
"*   The method qualifiers that are supported and what their roles are \n"
"*   The order in which the methods are called \n"
"*   The way the values of the generic function are generated"
msgstr ""
"CLOS позволяет указать, что generic dispatch(общая отправка) должна"
" использовать совершенно другую рабочую среду и распознавать разные роли"
" методов. Каждая обобщающая функция имеет тип комбинации методов, который"
" определяет рабочую структуру, которой следует generic dispatch(общая"
" отправка). Тип комбинации методов управляет\n"
"*   Поддерживаемые квалификаторы методов и каковы их роли\n"
"*   Порядок, в котором вызываются методы\n"
"*   Способ генерации значений обобщенной функции"

#: ./en/ch05.md:92
msgid ""
"At one point in the generic dispatch, CLOS takes the set of applicable "
"methods and combines them into the Lisp code that is the implementation of "
"the generic function. This Lisp code is called the effective method. CLOS "
"calls the effective method and returns its values to the caller of the "
"generic function. The method combination type controls how the applicable "
"methods are combined into the effective method. "
msgstr ""
"В какой-то момент generic dispatch(общей отправки) CLOS берет набор"
" применимых методов и объединяет их в код Lisp, который является реализацией"
" обобщенной функции. Этот код на Лиспе называется эффективным методом. CLOS"
" вызывает эффективный метод и возвращает его значения вызывающей обобщенной"
" функции. Тип комбинации методов определяет, как применимые методы"
" объединяются в эффективный метод."

#: ./en/ch05.md:94
msgid "### The Default Method Combination Type: standard"
msgstr "### Тип комбинации методов по умолчанию: стандартный"

#: ./en/ch05.md:96
msgid ""
"The default method combination type is named standard. It supports methods "
"with no qualifiers (primary methods) and methods with any one of these "
"qualifiers: :before, :after, or :around. The standard method combination "
"type supports using call-next-method in around-methods and in primary "
"methods. We have already discussed the order in which the methods are called "
"and how the values are generated, and we summarize this information in "
"\"Summary of the Standard Method Combination Type,\" page 113."
msgstr ""
"Тип комбинации методов по умолчанию называется standard. Он поддерживает"
" методы без квалификаторов (первичные методы) и методы с любым из этих"
" квалификаторов: :before, :after или :around. Стандартный тип комбинации"
" методов поддерживает использование call-next-method в around-methods и в"
" primary methods. Мы уже обсуждали порядок, в котором вызываются методы и как"
" генерируются значения, и мы суммируем эту информацию в разделе \"Краткое"
" описание стандартного типа комбинации методов\", стр. 113."

#: ./en/ch05.md:98
msgid ""
"We can give a rough idea of the effective method of a generic function that "
"uses standard method combination. Suppose the set of applicable methods "
"includes two before-methods, two primary methods, and two after-methods. In "
"this example, there are no applicable around-methods, and call-next-method "
"is not used. The effective method calls the before-methods in most-specific-"
"first order, the most specific primary method, and the after-methods in most-"
"specific-last order. The values of the primary method are returned. Thus, "
"the effective method resembles this:"
msgstr ""
"Мы можем дать приблизительное представление об эффективном методе обобщенной"
" функции, которая использует стандартную комбинацию методов. Предположим, что"
" набор применимых методов включает в себя два before-метода, два первичных"
" метода и два after-метода. В этом примере нет применимых around-методов, и"
" call-next-method не используется. Эффективный метод вызывает before-методы в"
" порядке most-specific-first(наиболее специфичный первым), наиболее"
" специфичный первичный метод и after-методы в порядке"
" most-specific-last(наиболее специфичный последним). Возвращаются значения"
" основного метода. Таким образом, эффективный метод напоминает этот:"

#: ./en/ch05.md:107
msgid ""
"<pre>\n"
"(multiple-value-progl\n"
" (progn (most-specific-before-method args) \n"
"        (least-specific-before-method args) \n"
"        (most-specific-primary-mettiod args)) \n"
" (least-specific-after-method args) \n"
" (most-specific-after-method args)) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:109
msgid "### The progn Method Combination Type"
msgstr "###  Тип комбинации методов progn"

#: ./en/ch05.md:111
msgid ""
"Suppose we need to implement a function for cleanly shutting down a computer "
"resource, such as a network interface. The network interface is an instance "
"of a class, which is constructed from several superclasses. The shutdown "
"generic function should allow each class the opportunity to do cleanup work "
"in preparation for the shutdown. One class might turn off the hardware, and "
"other classes might clear the pending input and output queues and inform the "
"higher layers of the network that the device is no longer operational."
msgstr ""
"Предположим, нам нужно реализовать функцию для чистого отключения"
" компьютерного ресурса, такого как сетевой интерфейс. Сетевой интерфейс - это"
" экземпляр класса, который создается из нескольких суперклассов. Обобщенная"
" функция shutdown должна предоставлять каждому классу возможность выполнить"
" очистку при подготовке к завершению работы. Один класс может отключить"
" аппаратное обеспечение, а другие классы могут очистить ожидающие очереди"
" ввода и вывода и сообщить более высоким уровням сети, что устройство больше"
" не работает."

#: ./en/ch05.md:113
msgid ""
"For this generic function it is reasonable to use a framework that calls all "
"applicable primary methods in most-specific-first order. This framework "
"allows any class to provide a method for shutdown. You can visualize such a "
"framework as a Lisp form that uses progn to call all applicable primary "
"methods: "
msgstr ""
"Для этой обобщенной функции разумно использовать фреймворк(рабочую среду),"
" который(ая) вызывает все применимые первичные методы в порядке"
" most-specific-first(наиболее специфичный первым). Эта рабочая среда"
" позволяет любому классу предоставлять метод для завершения работы. Вы можете"
" визуализировать такую структуру в виде формы Lisp, которая использует progn"
" для вызова всех применимых основных методов:"

#: ./en/ch05.md:119
msgid ""
"<pre>\n"
"(progn (method-1 args) ; inform higher layers \n"
"       (method-2 args) ; flush pending queues \n"
"       (method-3 args)) ; turn off hardware \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:121
msgid ""
"CLOS offers a set of built-in method combination types, and progn is one of "
"them. Except for the standard method combination type, none of the built-in "
"method combination types recognize before- or after- methods."
msgstr ""
"CLOS предлагает набор встроенных типов комбинирования методов, и progn"
" является одним из них. За исключением стандартного типа комбинации методов,"
" ни один из встроенных типов комбинации методов не распознает методы до или"
" после."

#: ./en/ch05.md:123
msgid "### Using the progn Method Combination Type"
msgstr "### Использование комбинированного типа метода progn"

#: ./en/ch05.md:125
msgid ""
"To specify that a generic function should use a different type of method "
"combination, we use the :method-combination option to defgeneric, as shown "
"here:"
msgstr ""
"Чтобы указать, что обобщенная функция должна использовать другой тип"
" комбинации методов, мы используем параметр :method-combination для"
" defgeneric, как показано здесь:"

#: ./en/ch05.md:131
msgid ""
"<pre>\n"
"(defgeneric shutdown (interface) \n"
"    (:method-combination progn)) \n"
"</pre>\n"
"To write primary methods that are intended to be used with the progn method "
"combination type, we supply the symbol progn as the method qualifier: "
msgstr ""
"<pre>\n"
"(defgeneric shutdown (interface) \n"
"    (:method-combination progn)) \n"
"</pre>\n"
"Чтобы написать первичные методы, которые предназначены для использования с"
" типом комбинации методов progn, мы предоставляем символ progn в качестве"
" квалификатора метода:"

#: ./en/ch05.md:136
msgid ""
"<pre>\n"
"(defmethod shutdown progn ((interface interface)) \n"
"    body) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:138
msgid ""
"CLOS signals an error if you define a method whose qualifier is not "
"recognized by the method combination type in use by the generic function."
msgstr ""
"CLOS сигнализирует об ошибке, если вы определяете метод, квалификатор"
" которого не распознается типом комбинации методов, используемым обобщенной"
" функцией."

#: ./en/ch05.md:140
msgid "##  5.6 BUILT-IN METHOD COMBINATION TYPES "
msgstr "## 5.6 ВСТРОЕННЫЕ ТИПЫ КОМБИНАЦИЙ МЕТОДОВ"

#: ./en/ch05.md:142
msgid ""
"In addition to standard (the default method combination type), CLOS provides "
"the following built-in method combination types: "
msgstr ""
"В дополнение к стандарту (тип комбинации методов по умолчанию), CLOS"
" предоставляет следующие встроенные типы комбинации методов:"

#: ./en/ch05.md:146
msgid ""
"\t    >    +               and           append \n"
"\t    >    list            max           min\n"
"\t    >    nconc           or            progn "
msgstr ""

#: ./en/ch05.md:148
msgid ""
"Notice that these method combination types have the same names as Lisp "
"functions or special forms; we call them operator method combination types. "
"Each one defines a framework that combines the applicable primary methods "
"inside a call to the Lisp operator of the same name."
msgstr ""
"Обратите внимание, что эти типы комбинаций методов имеют те же имена, что и"
" функции Lisp или специальные формы; мы называем их оператором типов"
" комбинаций методов. Каждый из них определяет фреймворк(рабочую среду),"
" который(ая) объединяет применимые первичные методы внутри вызова"
" одноименного оператора Lisp."

#: ./en/ch05.md:150
msgid ""
"The primary methods are combined in most-specific-first order. For  example, "
"if there are three primary methods, numbered from most to least specific, "
"the effective method resembles this: "
msgstr ""
"Первичные методы объединены в наиболее специфичном первом порядке. Например,"
" если есть три основных метода, пронумерованных от наиболее до наименее"
" специфичных, эффективный метод выглядит следующим образом:"

#: ./en/ch05.md:156
msgid ""
"<pre>\n"
"(operator  (primary-method-1 args) \n"
"           (primary-method-2 args) \n"
"           (primary-method-3 args))\n"
"</pre>"
msgstr ""

#: ./en/ch05.md:158
msgid ""
"The semantics of operator method combination types are defined by the Lisp "
"operator of the same name. For example, when the progn method combination "
"type is used, the operator is the progn special form. Thus, the framework "
"follows the semantics of progn: all the methods are called, and the values "
"of the last method are returned. Similarly, when the list method combination "
"type is used, the result is a list of the values of all the methods."
msgstr ""
"Семантика типов комбинаций методов оператора определяется одноименным"
" оператором Lisp. Например, когда используется комбинированный тип метода"
" progn, оператором является специальная форма progn. Таким образом, рабочая"
" среда(фреймворк) следует семантике progn: вызываются все методы, и"
" возвращаются значения последнего метода. Аналогично, когда используется"
" комбинированный тип метода list, результатом является список значений всех"
" методов."

#: ./en/ch05.md:160
msgid "### Primary Methods in Operator Method Combination Types "
msgstr "### Первичные методы в операторах Типов комбинаций методов"

#: ./en/ch05.md:163
msgid ""
"In standard method combination, an unqualified method is a primary method. "
"This is not so, however, when operator method combination types are used; "
"they do not accept unqualified methods. A primary method intended to be used "
"with an operator method combination type \n"
"must have the method qualifier that is the name of the method combination "
"type."
msgstr ""
"В стандартной комбинации методов неквалифицированный метод является основным"
" методом. Однако это не так, когда используются операторы комбинации типов"
" методов; они не принимают неквалифицированные методы. Основной метод,"
" предназначенный для использования с оператором типов комбинации методов,"
" должен иметь квалификатор метода, который является именем типа комбинации"
" методов."

#: ./en/ch05.md:165
msgid ""
"For example, the generic function total-electric-supply uses the + method "
"combination type: "
msgstr ""
"Например, обобщенная функция total-electric-supply использует тип комбинации"
" методов +:"

#: ./en/ch05.md:170
msgid ""
"<pre>\n"
"(defgeneric total-electric-supply (region) \n"
"   (:method-combination +)) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:172
msgid ""
"A primary method for total-electric-supply must have the symbol + as its "
"method qualifier: "
msgstr ""
"Основной метод для total-electric-supply должен иметь символ + в качестве"
" определителя метода:"

#: ./en/ch05.md:177
msgid ""
"<pre>\n"
"(defmethod total-electric-supply + ((city city)) \n"
"   body) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:179
msgid ""
"The operator method combination types do not support using call-next-method "
"in primary methods."
msgstr ""
"Операторы Типов комбинации методов не поддерживают использование"
" call-next-method в первичных методах."

#: ./en/ch05.md:181
msgid "### Around-Methods in Operator Method Combination Types "
msgstr "### Around-методы в операторах Типов комбинации методов"

#: ./en/ch05.md:183
msgid ""
"The operator method combination types support around-methods, and the use of "
"call-next-method in them. A method with the keyword :around as its qualifier "
"is an around-method. In the effective method, any around-methods surround "
"the call to the operator."
msgstr ""
"Операторы Типов комбинаций методов поддерживают around-методы и использование"
" в них call-next-method. Метод с ключевым словом :around в качестве"
" определителя является around-методом. В эффективном методе любые"
" around-методы окружают вызов оператора."

#: ./en/ch05.md:185
msgid ""
"Usually, when you use an operator method combination type, you supply only "
"primary methods. However, around-methods are supported for the same reason "
"that they are supported in standard method combination: to allow you an "
"extra degree of control over the generic dispatch procedure. For example, "
"you might provide one method that prints an English description of the "
"result and then returns the result:"
msgstr ""
"Обычно, когда вы используете оператор типа комбинации методов, вы"
" предоставляете только первичные методы. Однако around(окружающие)-методы"
" поддерживаются по той же причине, по которой они поддерживаются в"
" стандартной комбинации методов: чтобы предоставить вам дополнительную"
" степень контроля над  процедурой общей отправки(dispatch procedure)."
" Например, вы могли бы предоставить один метод, который печатает описание"
" результата на английском языке, а затем возвращает результат:"

#: ./en/ch05.md:193
msgid ""
"<pre>\n"
"(defmethod total-electric-supply raround ((region region)) \n"
"   (let ((supply (call-next-method))) \n"
"      (format t \"Available electricity in ~A is: ~A\" \n"
"              region supply) \n"
"      supply)) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:195
msgid ""
"Usually, around-methods return whatever values are returned by call-next-"
"method, although this is not required. "
msgstr ""
"Обычно around-методы возвращают любые значения, возвращаемые"
" call-next-method, хотя это и не обязательно."

#: ./en/ch05.md:197
msgid "### Summary of Operator Method Combination Types "
msgstr "### Краткое описание операторов типов комбинаций методов"

#: ./en/ch05.md:199
msgid "The operator method combination types do the following:"
msgstr "Операторы Типов комбинаций методов выполняют следующее:"

#: ./en/ch05.md:205
msgid ""
"*  Support primary methods and around-methods, but not before- or after-"
"methods \n"
"*  Support the use of call-next-method in around-methods, but not in primary "
"methods \n"
"*  Call any around-methods in the same way as does the standard method "
"combination type \n"
"*  Combine all applicable primary methods inside a call to the Lisp operator "
"whose name is the same as the name of the method combination type, and call "
"these methods in most-specific-first order \n"
"*  Require at least one primary method and signal an error if none exists"
msgstr ""
"* Поддерживайте первичные методы и around(окружающие)-методы, но не методы"
" before-(до) или after-(после)\n"
"* Поддержка использования call-next-method в around-методах, но не в основных"
" методах\n"
"* Вызывайте любые around-методы таким же образом, как и стандартный тип"
" комбинации методов\n"
"* Объедините все применимые первичные методы внутри вызова оператора Lisp,"
" имя которого совпадает с именем типа комбинации методов, и вызывайте эти"
" методы в наиболее специфичном первом порядке.\n"
"* Требуется по крайней мере один основной метод и сигнализировать об ошибке,"
" если таковой не существует"

#: ./en/ch05.md:207
msgid "## 5.7 DEFINING A NEW METHOD COMBINATION TYPE"
msgstr "## 5.7 ОПРЕДЕЛЕНИЕ НОВОГО ТИПА КОМБИНАЦИИ МЕТОДОВ"

#: ./en/ch05.md:209
msgid ""
"CLOS makes it easy to define a new operator method combination type—a "
"framework that combines all applicable primary methods inside a Lisp "
"function, macro, or special form."
msgstr ""
"CLOS позволяет легко определить новый оператор типа комбинации методов —"
" рабочей среды(фреймворк), которая объединяет все применимые первичные методы"
" внутри функции Lisp, макроса или специальной формы."

#: ./en/ch05.md:211
msgid ""
"The macro define-method-combination has a short form and a long form. The "
"short form has a simple syntax and is adequate for defining many of the "
"commonly used types of method combination. "
msgstr ""
"Макрос define-method-combination имеет короткую форму и длинную форму."
" Краткая форма имеет простой синтаксис и подходит для определения многих"
" часто используемых типов комбинации методов."

#: ./en/ch05.md:213
msgid "### Short Form of define-method-combination"
msgstr ""
"### Краткая форма define-method-combination(определения-метода-комбинации)"

#: ./en/ch05.md:216
msgid ""
"The short form of define-method-combination defines an operator method "
"combination type. Any of the built-in operator method combination types "
"could have been defined using the short form of define-method-combination. "
"For example, if the progn method combination type \n"
"were not already defined, we could define it as follows:"
msgstr ""
"Краткая форма define-method-combination определяет оператор типа комбинации"
" методов. Любой из встроенных операторов типов комбинации методов мог быть"
" определен с использованием краткой формы define-method-combination."
" Например, если бы тип комбинации методов progn еще не был определен, мы"
" могли бы определить его следующим образом:"

#: ./en/ch05.md:222
msgid ""
"<pre>\n"
"(define-method-combination progn \n"
"   :operator progn \n"
"   :identity-with-one-argument t) \n"
"</pre>"
msgstr ""

#: ./en/ch05.md:224
msgid ""
"The first argument is the name of the method combination type. The :operator "
"keyword specifies the operator that receives the values of the methods. It "
"is often reasonable to give the method combination type the same name as the "
"operator. The :identity-with-one-argument t option means \"this is an "
"identity when it is called with one argument.\" This option requests the "
"compiler to optimize for cases when there is only one applicable method; it "
"indicates that the value of that method should be returned as the value of "
"the generic function, rather than calling the operator. This makes sense for "
"operators such as progn, and, +, max, and all the other built-in operator "
"method combination types. "
msgstr ""
"Первый аргумент - это имя типа комбинации методов. Ключевое слово :operator"
" указывает оператор, который получает значения методов. Часто бывает разумно"
" присвоить типу комбинации методов то же имя, что и оператору. Параметр"
" :identity-with-one-argument t означает \"это идентификатор, когда он"
" вызывается с одним аргументом\". Этот параметр запрашивает у компилятора"
" оптимизацию для случаев, когда существует только один применимый метод; он"
" указывает, что значение этого метода должно быть возвращено как значение"
" обобщенной функции, а не как вызов оператора. Это имеет смысл для таких"
" операторов, как progn, and, +, max и всех других встроенных операторов типов"
" комбинаций методов."

#: ./en/ch05.md:226
msgid ""
"Operator method combination types support primary methods and around-"
"methods, but not before- and after-methods. Around-methods may use call-next-"
"method, but primary methods may not. Primary methods must have a method "
"qualifier that is the same symbol as the name of the method combination "
"type. For related information, see \"Built-in Method Combination Types,\" "
"page 107."
msgstr ""
"Операторы Типов комбинаций методов поддерживают первичные методы и"
" around-методы, но не методы before-(до) и after-(после). Around-методы могут"
" использовать call-next-method, но первичные методы не могут. Первичные"
" методы должны иметь квалификатор метода, который является тем же символом,"
" что и имя типа комбинации методов. Дополнительную информацию см. в разделе"
" \"Типы комбинаций встроенных методов\", стр. 107."

#: ./en/ch05.md:228
msgid "### Long Form of define-method-combination"
msgstr "### Длинная форма define-method-combination"

#: ./en/ch05.md:230
msgid ""
"The long form of define-method-combination supports a rich and powerful "
"syntax for defining a new framework. You can use it when none of the built-"
"in method combination types (including standard) are appropriate, and the "
"framework cannot be defined with the short form of define-method-"
"combination. Because we believe that most applications will fit well with "
"one of the built-in method combination types, we do not cover the syntax of "
"the long form of define-method-combination in this book. See the CLOS "
"specification for more information. "
msgstr ""
"Длинная форма define-method-combination поддерживает богатый и мощный"
" синтаксис для определения новой рабочей среды(framework). Вы можете"
" использовать его, когда ни один из встроенных типов комбинации методов"
" (включая стандартный) не подходит, и рабочая среда(фреймворк) не может быть"
" определен с помощью краткой формы define-method-combination. Поскольку мы"
" считаем, что большинству приложений подойдет один из встроенных типов"
" комбинирования методов, мы не рассматриваем синтаксис длинной формы"
" define-method-combination в этой книге. Смотрите спецификацию CLOS для"
" получения дополнительной информации."

#: ./en/ch05.md:232
msgid "## 5.8 GUIDELINES ON CONTROLLING THE GENERIC DISPATCH"
msgstr "## 5.8 РУКОВОДСТВО ПО КОНТРОЛЮ ЗА GENERIC DISPATCH(ОБЩЕЙ ОТПРАВКОЙ)"

#: ./en/ch05.md:234
msgid ""
"The declarative technique relies on a consistent framework in which the "
"methods are called according to their roles within the framework; the role "
"of a method is declared by its qualifier. The generic dispatch automates the "
"process of calling the appropriate applicable methods. You can predict the "
"order of the methods without looking at the code in the bodies of the "
"methods."
msgstr ""
"Декларативный метод опирается на согласованную структуру, в которой методы"
" вызываются в соответствии с их ролями внутри структуры; роль метода"
" объявляется его классификатором. Общая отправка(generic dispatch)"
" автоматизирует процесс вызова соответствующих применимых методов. Вы можете"
" предсказать порядок методов, не глядя на код в телах методов."

#: ./en/ch05.md:236
msgid ""
"In contrast, the imperative technique allows the methods themselves to alter "
"the course of the generic dispatch by calling call-next-method. This "
"technique offers a different kind of power, while adding a considerable "
"degree of complexity to the program. Usually, you need to understand the "
"implementation of inherited behavior in order to use call-next-method; in a "
"sense, this is a violation of modularity. However, you cannot write some "
"programs without resorting to the imperative technique. We recommend that "
"you use around-methods and call-next-method only when that power is truly "
"necessary."
msgstr ""
"Напротив, императивный метод позволяет самим методам изменять ход общей"
" отправки, вызывая call-next-method. Этот метод предлагает другой вид"
" мощности, в то же время значительно усложняя программу. Обычно вам нужно"
" понять реализацию унаследованного поведения, чтобы использовать"
" call-next-method; в некотором смысле это нарушение модульности. Однако вы не"
" можете писать некоторые программы, не прибегая к императивному методу. Мы"
" рекомендуем вам использовать around-методы и вызывать следующий"
" метод(call-next-method) только тогда, когда эта мощь действительно"
" необходима."

#: ./en/ch05.md:238
msgid ""
"In the shutdown example, we used the declarative technique of using the "
"progn type of method combination. We could have written the program "
"differently, however, using the standard method combination type. Here, we "
"describe two alternate implementations of shutdown and discuss the design "
"considerations that led us to choose progn instead of the standard method "
"combination type."
msgstr ""
"В примере завершения работы мы использовали декларативный метод использования"
" комбинации методов типа progn. Однако мы могли бы написать программу"
" по-другому, используя стандартный тип комбинации методов. Здесь мы опишем"
" две альтернативные реализации shutdown и обсудим конструктивные соображения,"
" которые привели нас к выбору progn вместо стандартного типа комбинации"
" методов."

#: ./en/ch05.md:240
msgid ""
"*   Imperative Technique: call-next-method. Each class could supply a "
"primary method that does whatever computation is desired and then calls call-"
"next-method to pass control to the next most specific primary method. The "
"least specific method must return without calling call-next-method."
msgstr ""
"*   Императивный метод: call-next-method(вызов следующего метода). Каждый"
" класс может предоставить первичный метод, который выполняет любые желаемые"
" вычисления, а затем вызывает call-next-method для передачи управления"
" следующему наиболее конкретному первичному методу. Наименее специфичный"
" метод должен возвращать без вызова call-next-method."

#: ./en/ch05.md:242
msgid ""
"This scheme has several disadvantages. It is necessary to examine all the "
"methods to understand the implementation. Any one method can break the "
"implementation by not calling call-next-method. Also, this is not a "
"consistent model; it requires the least specific method not to call call-"
"next-method, whereas all other methods must call call-next-method. (Each "
"method should use next-method-p to determine whether there is a less "
"specific method to call.) Finally, this scheme probably requires several "
"extra function calls, which add overhead."
msgstr ""
"Эта схема имеет несколько недостатков. Необходимо изучить все методы, чтобы"
" понять реализацию. Любой метод может нарушить реализацию, не вызывая"
" call-next-method. Кроме того, это непротиворечивая модель; она требует,"
" чтобы наименее специфичный метод не вызывал call-next-method, тогда как все"
" остальные методы должны вызывать call-next-method. (Каждый метод должен"
" использовать next-method-p, чтобы определить, существует ли менее"
" специфичный метод для вызова.) Наконец, эта схема, вероятно, требует"
" нескольких дополнительных вызовов функций, которые увеличивают накладные"
" расходы."

#: ./en/ch05.md:244
msgid ""
"*   Declarative technique: be fore-methods. Each class could provide a "
"before-method. Before-methods run in most-specific-first order, so the "
"desired order of methods can be achieved this way. Since the standard method "
"combination requires a primary method, at least one class must provide a "
"primary method. The primary method does not have to do anything; it can "
"simply return nil."
msgstr ""
"* Декларативный метод: before-методы. Каждый класс мог бы предоставить"
" before-метод. Before-методы выполняются в порядке"
" most-specific-first(наиболее специфичный первым), поэтому желаемый порядок"
" методов может быть достигнут таким образом. Поскольку стандартная комбинация"
" методов требует основного метода, по крайней мере, один класс должен"
" предоставлять основной метод. Основной метод не должен ничего делать; он"
" может просто вернуть nil."

#: ./en/ch05.md:246
msgid ""
"The disadvantage here is that the declared roles of the methods do not "
"accurately reflect their purposes. We expect a primary method to do the bulk "
"of the work, but this primary method is not essential to the implementation; "
"it simply fulfills a requirement of the standard method combination. "
"Usually, a before-method does auxiliary work before the primary method, but "
"these before-methods are not auxiliary to the implementation; they are the "
"implementation. This scheme tries to force a program into the standard "
"method combination framework even though that framework is not appropriate "
"to the program."
msgstr ""
"Недостатком здесь является то, что заявленные роли методов не совсем точно"
" отражают их цели. Мы ожидаем, что основной метод выполнит основную часть"
" работы, но этот основной метод не является существенным для реализации; он"
" просто выполняет требование стандартной комбинации методов. Обычно"
" before-метод выполняет вспомогательную работу перед основным методом, но эти"
" before-методы не являются вспомогательными для реализации; они являются"
" реализацией. Эта схема пытается принудительно поместить программу в"
" стандартную структуру комбинирования методов, даже если эта структура не"
" подходит для программы."

#: ./en/ch05.md:248
msgid ""
"These techniques rely on ad hoc conventions that all methods must follow. "
"The first convention relies on call-next-method, and the second relies on "
"before-methods. Both conventions treat one method differently from the "
"others."
msgstr ""
"Эти методы основаны на специальных соглашениях, которым должны следовать все"
" методы. Первое соглашение основывается на call-next-method, а второе - на"
" методах before. Оба соглашения трактуют один метод иначе, чем другие."

#: ./en/ch05.md:250
msgid ""
"In this example, the declarative technique of defining a new frame-work has "
"one great advantage: It eliminates the need for an ad hoc convention that "
"must be maintained by each method, in favor of a concrete and consistent "
"framework that is automatically maintained by the generic dispatch procedure."
msgstr ""
"В этом примере декларативный метод определения новой структуры имеет одно"
" большое преимущество: он устраняет необходимость в специальном соглашении,"
" которое должно поддерживаться каждым методом, в пользу конкретной и"
" последовательной структуры, которая автоматически поддерживается процедурой"
" общей отправки."

#: ./en/ch05.md:252
msgid "## 5.9 SUMMARY OF THE GENERIC DISPATCH PROCEDURE"
msgstr "## 5.9 КРАТКОЕ ОПИСАНИЕ ПРОЦЕДУРЫ ОБЩЕЙ  ОТПРАВКИ(GENERIC DISPATCH)"

#: ./en/ch05.md:254
msgid ""
"When a generic function is called, the generic dispatch procedure takes "
"charge of choosing the implementation that is appropriate for the arguments "
"of the generic function. This process involves four steps:"
msgstr ""
"Когда вызывается обобщенная функция, процедура общей отправки берет на себя"
" ответственность за выбор реализации, которая подходит для аргументов"
" обобщенной функции. Этот процесс включает в себя четыре этапа:"

#: ./en/ch05.md:259
msgid ""
"1.   Selecting the set of applicable methods \n"
"2.   Ranking the applicable methods by precedence order \n"
"3.   Combining the methods into an effective method, according to the roles "
"of the methods and the method combination type \n"
"4. Calling the effective method and returning its values "
msgstr ""
"1. Выбор набора применимых методов\n"
"2. Ранжирование применимых методов в порядке приоритета\n"
"3. Объединение методов в эффективный метод в соответствии с ролями методов и"
" типом комбинации методов\n"
"4. Вызов эффективного метода и возврат его значений"

#: ./en/ch05.md:261
msgid ""
"For a complete summary of the first and second steps of this procedure, see "
"\"Summary of Method Inheritance,\" page 98."
msgstr ""
"Полное описание первого и второго шагов этой процедуры см. в разделе"
" \"Краткое описание наследования методов\", стр. 98."

#: ./en/ch05.md:263
msgid ""
"In the third step, CLOS chooses the final implementation of the generic "
"function, by combining the methods into a single body of code called the "
"effective method. The input to the third step includes the set of applicable "
"methods ranked by precedence order, and the method combination type. The "
"method combination type describes how to combine the methods, based on their "
"qualifiers. By default, a generic function uses standard method combination "
"type. When you define and use a new type of method combination, you can "
"customize the third step. The method combination type has no effect on any "
"of the other steps."
msgstr ""
"На третьем этапе CLOS выбирает окончательную реализацию обобщенной функции,"
" объединяя методы в единый фрагмент кода, называемый эффективным методом."
" Входные данные для третьего шага включают набор применимых методов,"
" ранжированных по порядку приоритета, и тип комбинации методов. Тип"
" комбинации методов описывает, как комбинировать методы на основе их"
" квалификаторов. По умолчанию обобщенная функция использует стандартный тип"
" комбинации методов. Когда вы определяете и используете новый тип комбинации"
" методов, вы можете настроить третий шаг. Тип комбинации методов не влияет ни"
" на один из других шагов."

#: ./en/ch05.md:265
msgid ""
"CLOS implementations are free to optimize the generic dispatch procedure "
"such that some of these steps are precomputed and thus are not performed on "
"each generic function call."
msgstr ""
"Реализации CLOS могут свободно оптимизировать процедуру общей отправки таким"
" образом, что некоторые из этих шагов предварительно вычисляются и,"
" следовательно, не выполняются при каждом вызове обобщенной функции."

#: ./en/ch05.md:267
msgid "## 5.10 SUMMARY OF THE STANDARD METHOD COMBINATION TYPE"
msgstr "## 5.10 КРАТКОЕ ОПИСАНИЕ СТАНДАРТНОГО ТИПА КОМБИНАЦИИ МЕТОДОВ"

#: ./en/ch05.md:269
msgid ""
"The standard method combination type is the default. All generic functions "
"use this framework, unless the defgeneric form uses the :method-combination "
"option to specify another method combination type."
msgstr ""
"Стандартный тип комбинации методов используется по умолчанию. Все обобщенные"
" функции используют эту структуру, если только форма defgeneric не использует"
" параметр :method-combination для указания другого типа комбинации методов."

#: ./en/ch05.md:271
msgid ""
"This section summarizes how the standard method combination type works, "
"including what method roles it supports, how the various methods are "
"combined into an effective method, and how the values are handled."
msgstr ""
"В этом разделе кратко описывается, как работает стандартный тип комбинации"
" методов, в том числе какие роли методов он поддерживает, как различные"
" методы объединяются в эффективный метод и как обрабатываются значения."

#: ./en/ch05.md:273
msgid "### Recognized Method Roles"
msgstr "### Признанные роли метода"

#: ./en/ch05.md:275
msgid ""
"The standard method combination type recognizes four roles for methods, "
"based on their qualifiers:"
msgstr ""
"Стандартный тип комбинации методов распознает четыре роли для методов на"
" основе их квалификаторов:"

#: ./en/ch05.md:282
msgid ""
"|  Qualifier  | Method Role                              |\n"
"|-------------|------------------------------------------|\n"
"|  none       | A primary method                         |\n"
"| :before     | Called before the primary method         |\n"
"| :after      | Called after the primary method          |\n"
"| :around     | Wrapped around all other kinds of methods| "
msgstr ""
"| Квалификатор | Роль метода                                |\n"
"|--------------|--------------------------------------------|\n"
"| none         | Основной метод                             |\n"
"| :before      | Вызывается перед основным методом          |\n"
"| :after       | Вызывается после основного метода          |\n"
"| :around      | Обернутый вокруг всех других видов методов |"

#: ./en/ch05.md:284
msgid ""
"The standard method combination type supports call-next-method in around-"
"methods and in primary methods."
msgstr ""
"Стандартный тип комбинации методов поддерживает call-next-method(вызов"
" следующего метода) в around-методах и в первичных методах."

#: ./en/ch05.md:286
msgid "### Plow of Control"
msgstr "### Поток управления"

#: ./en/ch05.md:288
msgid ""
"Figure 5.1 shows the flow of control of methods in the standard method "
"combination. Each step poses a question; the answer to the question "
"determines where the flow of control goes next. Notice that in the around "
msgstr ""
"На рисунке 5.1 показан процесс управления методами в стандартной комбинации"
" методов. Каждый шаг ставит вопрос; ответ на вопрос определяет, куда дальше"
" пойдет поток управления. Обратите внимание, что в окружающем"

#: ./en/ch05.md:311
msgid ""
"| START: Input is a list of applicable methods.          |\n"
"|--------------------------------------------------------|\n"
"| BEFORE STEP: Are there any uncalled before-methods?    |\n"
"| YES: Call the most specific uncalled before-method.    |\n"
"| When body returns, repeat this step.                   |\n"
"| NO: i                                                  |\n"
"| PRIMARY STEP: Are there any uncalled primary methods?  |\n"
"| YES: Call the most specific uncalled primary method.   |\n"
"| If body uses call-next-method, repeat this step.       |\n"
"| When body returns, return its values to caller.        |\n"
"| NO: I                                                  |\n"
"| AFTER STEP: Are there any uncalled after-methods?      |\n"
"| YES: Call the least specific uncalled after-method.    |\n"
"| When body returns, repeat this step.                   |\n"
"| NO: i                                                  |\n"
"| DONE: Return control and values to caller.             |\n"
"| AROUND STEP: Are there any uncalled around-methods?    |\n"
"| YES: Call the most specific uncalled around-method.    |\n"
"| If body uses call-next-method, repeat this step.       |\n"
"| If body does not use call-next-method, go to DONE.-    |\n"
"| When body returns, return its values to caller.        |\n"
"| NO:"
msgstr ""
"| START: Ввод - это список применимых методов.                            |\n"
"| BEFORE STEP: Существуют ли какие-либо неиспользуемые методы before?     |\n"
"| YES: Вызовите наиболее конкретный не вызванный ранее метод.             |\n"
"| Когда тело вернется, повторите этот шаг.                                |\n"
"| NO: я                                                                   |\n"
"| PRIMARY STEP: Существуют ли какие-либо неиспользуемые первичные методы? |\n"
"| YES: Вызовите наиболее конкретный не вызываемый основной метод.         |\n"
"| Если body использует call-next-method, повторите этот шаг.              |\n"
"| Когда тело вернется, верните его значения вызывающему.                  |\n"
"| NO: Я                                                                   |\n"
"| AFTER STEP: Существуют ли какие-либо неуместные последующие методы?     |\n"
"| YES: Вызовите наименее специфичный не вызываемый after-метод.           |\n"
"| Когда тело вернется, повторите этот шаг.                                |\n"
"| NO: я                                                                   |\n"
"| DONE: Верните управление и значения вызывающей стороне.                 |\n"
"| AROUND STEP: Существуют ли какие-либо неуместные around-методы?         |\n"
"| YES: Вызовите наиболее конкретный не вызываемый around-метод.           |\n"
"| Если body использует call-next-method, повторите этот шаг.              |\n"
"| Если тело не использует call-next-method, перейдите к DONE.-            |\n"
"| Когда тело вернется, верните его значения вызывающему.                  |\n"
"| NO:"

#: ./en/ch05.md:314
msgid ""
"![Figure 5.1: Flow of control of standard method combination.](images/f02-01."
"jpg)\n"
"**Figure 5.1: Flow of control of standard method combination.**"
msgstr ""
"![Рисунок 5.1: Схема управления комбинацией стандартных"
" методов.](images/f02-01.jpg )\n"
"**Рисунок 5.1: Схема управления комбинацией стандартных методов.**"

#: ./en/ch05.md:316
msgid ""
"and primary steps, there is a question that can be answered only by "
"executing the body of the method: Does the body of this method use call-next-"
"method? If so, the \"next method\" is called. For an around-method, the "
"\"next method\" is the next most specific around-method if there is one; "
"otherwise, it is the entire core framework. For a primary method, the \"next "
"method\" is the next most specific primary method."
msgstr ""
"и первичные шаги, есть вопрос, на который можно ответить, только выполнив"
" тело метода: использует ли тело этого метода call-next-method? Если это так,"
" то вызывается \"следующий метод\". Для around-метода \"следующий метод\" -"
" это следующий наиболее специфичный around-метод, если таковой существует; в"
" противном случае это вся основная рабочая среда. Для основного метода"
" \"следующий метод\" - это следующий наиболее специфичный основной метод."

#: ./en/ch05.md:318
msgid ""
"The dashed lines in Fig. 5.1 show decisions that are controlled by the use "
"of call-next-method. For example, if there is an around-method and call-next-"
"method is not used in the body, the flow of control goes directly to DONE, "
"without calling any before-methods, primary methods, or after-methods. "
msgstr ""
"Пунктирные линии на рис. 5.1 показывают решения, которые контролируются с"
" помощью метода call-next. Например, если существует around-метод и в теле не"
" используется метод call-next, поток управления переходит непосредственно к"
" DONE, без вызова каких-либо методов before, primary или after."

#: ./en/ch05.md:320
msgid ""
"If the body of a method uses call-next-method more than once, the same \"next"
" method\" is called each time."
msgstr ""
"Если тело метода использует call-next-method более одного раза, каждый раз"
" вызывается один и тот же \"следующий метод\"."

#: ./en/ch05.md:322
msgid "### Errors"
msgstr "### Ошибки"

#: ./en/ch05.md:324
msgid ""
"Figure 5.1 does not show the possible error situations. CLOS signals an "
"error if"
msgstr ""
"На рисунке 5.1 не показаны возможные ситуации с ошибками. CLOS сигнализирует"
" об ошибке, если"

#: ./en/ch05.md:328
msgid ""
"*   There is no applicable primary method \n"
"*   A primary method uses call-next-method, and there is no \"next method\" "
"to call \n"
"*   A before- or after-method uses call-next-method"
msgstr ""
"* Не существует применимого основного метода\n"
"* Основной метод использует call-next-method, и нет никакого \"следующего"
" метода\" для вызова\n"
"* Метод before-(до) или after-(после) использует call-next-method"

#: ./en/ch05.md:330
msgid "### Values"
msgstr "### Значения"

#: ./en/ch05.md:332
msgid "In summary, this is how the values of the methods are handled: "
msgstr "Таким образом, вот как обрабатываются значения методов:"

#: ./en/ch05.md:337
msgid ""
"*   Any values of before-methods and after-methods are ignored \n"
"*   Each primary and around-method returns its values to its caller \n"
"*   If there are no applicable around-methods, the final values of the "
"generic function are the values returned by the most specific primary method "
"\n"
"*   If there are any applicable around-methods, the final values of the "
"generic function are the values returned by the most specific around-method "
msgstr ""
"* Любые значения before-методов и after-методов игнорируются\n"
"* Каждый первичный и around-метод возвращает свои значения своему"
" вызывающему\n"
"* Если нет применимых around-методов, конечными значениями обобщенной функции"
" являются значения, возвращаемые наиболее конкретным основным методом\n"
"* Если существуют какие-либо применимые around-методы, конечными значениями"
" обобщенной функции являются значения, возвращаемые наиболее конкретным"
" around-методом"
