#. extracted from ./en/ch11.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 10:32+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch11.md:2
msgid "# Developing an Advanced CLOS Program: Streams"
msgstr "# Разработка продвинутой программы CLOS: Потоки"

#: ./en/ch11.md:4
msgid ""
"This chapter illustrates an object-oriented foundation for implementing "
"Common Lisp streams, whose behavior is specified in Steele's Common LISP: "
"The Language. Streams fit naturally into the object-oriented model. The many "
"varieties of related streams can be modeled with multiple inheritance."
msgstr ""
"Эта глава иллюстрирует объектно-ориентированную основу для реализации потоков"
" Common Lisp, поведение которых указано в книге Стила Common LISP: The"
" Language. Потоки естественным образом вписываются в объектно-ориентированную"
" модель. Множество разновидностей связанных потоков можно смоделировать с"
" помощью множественного наследования."

#: ./en/ch11.md:6
msgid ""
"This example is considerably more challenging than the other examples in "
"this book. Our goal is to demonstrate how to attack a good-sized problem by "
"using CLOS techniques to break up the problem into manageable modules. The "
"design of the stream foundation specifies the responsibility of each module. "
"The implementation consists of the modules themselves, which are classes, "
"generic functions, and methods. The design is the challenging part—but if it "
"is done right, the implementation should be relatively straightforward. (You "
"will notice that the implementation of one of the modules—disk streams—is "
"actually quite complex, but the complexity is due to the handling of the "
"disk device itself, which would be necessary regardless of the design of "
"streams.)"
msgstr ""
"Этот пример значительно сложнее, чем другие примеры в этой книге. Наша цель -"
" продемонстрировать, как атаковать проблему большого размера, используя"
" методы CLOS для разбиения проблемы на управляемые модули. Проект stream"
" foundation(основа потоков) определяет ответственность каждого модуля."
" Реализация состоит из самих модулей, которые являются классами, обобщенными"
" функциями и методами. Разработка/проектирование — это сложная часть, но если"
" все сделано правильно, реализация должна быть относительно простой. (Вы"
" заметите, что реализация одного из модулей — disk streams — на самом деле"
" довольно сложна, но сложность связана с обработкой самого дискового"
" устройства, что было бы необходимо независимо от проектирования потоков.)"

#: ./en/ch11.md:9
msgid ""
"We start by summarizing what Common Lisp streams are, and how they are "
"created and used. We then describe our overall design and show the portions "
"of the implementation that illustrate CLOS and the object-oriented style. "
"This example develops a foundation for streams and illustrates how a handful "
"of the familiar Common Lisp stream functions can be written to use that "
"foundation. For example, we show how read-char, write-char, read-byte, and "
"write-byte can be written using \n"
"this foundation, but we omit the definitions of other functions, such as "
"read-line and write-line."
msgstr ""
"Мы начнем с краткого описания того, что такое потоки(streams) Common Lisp и"
" как они создаются и используются. Затем мы описываем наш общий проект и"
" показываем части реализации, которые иллюстрируют CLOS и"
" объектно-ориентированный стиль. Этот пример создает основу для потоков и"
" иллюстрирует, как несколько знакомых потоковых функций Common Lisp могут"
" быть написаны для использования этой основы. Например, мы показываем, как"
" read-char, write-char, read-byte и write-byte могут быть записаны с"
" использованием этой основы, но мы опускаем определения других функций, таких"
" как read-line и write-line."

#: ./en/ch11.md:11
msgid ""
"The external interface is specified by Common LISP: The Language, in the "
"following chapters and sections:"
msgstr ""
"Внешний интерфейс определяется Common LISP: Язык, в следующих главах и"
" разделах:"

#: ./en/ch11.md:16
msgid ""
"    > Chapter 21        Streams \n"
"    > Section 22.2      Input Functions \n"
"    > Section 22.3      Output Functions \n"
"    > Section 23.2      Opening and Closing Files"
msgstr ""
"    > Глава 21          Потоки(Streams)\n"
"    > Раздел 22.2 	Функции ввода\n"
"    > Раздел 22.3	Функции вывода\n"
"    > Раздел 23.2	Открытие и закрытие файлов"

#: ./en/ch11.md:18
msgid ""
"This example is not intended to be an actual implementation of streams; that "
"is a topic that could fill an entire book. For the most part, we ignore "
"efficiency considerations. Streams need to access devices for I/O, so we "
"assume (and document) a set of low-level primitives for tape and disk I/O "
"that we call in the methods. These primitives are simplified versions of "
"what might exist in a real I/O system. We do not include Lisp code to "
"implement these primitives, because it would be devicedependent, long and "
"complex, and probably not relevant to object-oriented programming."
msgstr ""
"Этот пример не предназначен для реальной реализации потоков; это тема,"
" которая могла бы заполнить целую книгу. По большей части мы игнорируем"
" соображения эффективности. Потокам необходим доступ к устройствам для"
" ввода-вывода, поэтому мы предполагаем (и документируем) набор низкоуровневых"
" примитивов для ленточного и дискового ввода-вывода, которые мы вызываем в"
" методах. Эти примитивы являются упрощенными версиями того, что могло бы"
" существовать в реальной системе ввода-вывода. Мы не включаем код Lisp для"
" реализации этих примитивов, потому что он был бы зависимым от устройства,"
" длинным и сложным и, вероятно, не имеет отношения к"
" объектно-ориентированному программированию."

#: ./en/ch11.md:20
msgid ""
"The value of this example lies in the techniques of decomposing a "
"substantial problem into separate components of functionality, and of "
"specifying a protocol for communication among these components. The details "
"of the method bodies are less important than the overall modularity. As you "
"read, we encourage you to focus on how the pieces fit together, instead of "
"getting bogged down in the details of any one piece."
msgstr ""
"Ценность этого примера заключается в методах декомпозиции существенной"
" проблемы на отдельные функциональные компоненты и определения протокола для"
" взаимодействия между этими компонентами. Детали тела метода менее важны, чем"
" общая модульность. По мере чтения мы рекомендуем вам сосредоточиться на том,"
" как части сочетаются друг с другом, вместо того, чтобы увязать в деталях"
" какой-либо одной части."

#: ./en/ch11.md:22
msgid "## 11.1 OVERVIEW OF STREAMS "
msgstr "## 11.1 ОБЗОР ПОТОКОВ(STREAMS)"

#: ./en/ch11.md:24
msgid ""
"The first step in designing and developing an object-oriented program is to "
"understand the problem you are trying to solve. We start by describing all "
"the types of objects we need to model and the operations on the objects. "
"With this information we will be able to design an organization of classes."
msgstr ""
"Первым шагом в проектировании и разработке объектно-ориентированной программы"
" является понимание проблемы, которую вы пытаетесь решить. Мы начнем с"
" описания всех типов объектов, которые нам нужно смоделировать, и операций"
" над объектами. С помощью этой информации мы сможем спроектировать"
" организацию классов."

#: ./en/ch11.md:26
msgid ""
"Common Lisp streams are used to transmit data from a source to a "
"destination. For example, when you are using a text editor, and you give the "
"editor command to save the contents of a buffer to a file, a stream is used "
"to transmit the data. "
msgstr ""
"Потоки Common Lisp используются для передачи данных от источника к месту"
" назначения. Например, когда вы используете текстовый редактор и даете"
" редактору команду сохранить содержимое буфера в файл, для передачи данных"
" используется поток."

#: ./en/ch11.md:29
msgid ""
"### Types of Streams \n"
"There are different types of streams, which are used for different purposes. "
"The following stream types are related to the direction of data flow:"
msgstr ""
"### Типы потоков\n"
"Существуют различные типы потоков, которые используются для разных целей."
" Следующие типы потоков связаны с направлением потока данных:"

#: ./en/ch11.md:32
msgid ""
"    >  input stream             Brings data from an outside source into "
"Lisp. \n"
"    >                           An example is the stream to which *standard-"
"input* is bound. "
msgstr ""
"\t    > input stream(входной поток)    Переносит данные из внешнего источника"
" в Lisp.\n"
"\t    >               	               Примером является поток, к которому"
" привязан *standard-input*.\n"

#: ./en/ch11.md:35
msgid ""
"    >  output stream            Sends data from Lisp to an outside "
"destination. An example is the stream\n"
"    >                           to which *standard-output* is bound."
msgstr ""
"\t    > output stream(выходной поток)  Отправляет данные из Lisp во внешний"
" адресат. Примером может служить поток"
" \t   >                                к которому привязан *стандартный"
" вывод*."

#: ./en/ch11.md:38
msgid ""
"    >  bidirectional stream     Transmits data in both the input and output "
"directions. An example is the\n"
"    >                           stream to which *query-io* is bound."
msgstr ""
"\t    > bidirectional stream           передает данные как во входном, так и"
" в выходном направлениях. Примером\n"
"\t    >                                        (двунаправленный поток)       "
" может служить поток, к которому привязан \n"
"\t    >                                        *query-io*."

#: ./en/ch11.md:40
msgid ""
"The following stream types are related to the type of the data being "
"transmitted, which is the element type of the stream:"
msgstr ""
"Следующие типы потоков связаны с типом передаваемых данных, который является"
" типом элемента потока:"

#: ./en/ch11.md:42
msgid "    > character stream          Transmits characters"
msgstr ""
"\t    > character stream          (поток символьных знаков) Передает"
" символьные знаки"

#: ./en/ch11.md:45
msgid ""
"    > byte stream               Transmits binary bytes of data, where a "
"\"byte\" is an integer with a\n"
"    >                           specified number of bits"
msgstr ""
"\t    > byte stream               (поток байтов)  Передает двоичные байты"
" данных, где \"байт\" - это целое число с\n"
"\t    >                                 указанным количеством битов"

#: ./en/ch11.md:47
msgid ""
"Streams have two ends; they connect two things. One end is connected to "
"Lisp, and the other end is connected to some sort of device. An input stream "
"brings data from the device into Lisp, whereas an output stream sends data "
"from Lisp to the device."
msgstr ""
"Потоки имеют два конца; они соединяют две вещи. Один конец подключен к Lisp,"
" а другой конец подключен к какому-то устройству. Входной поток переносит"
" данные с устройства в Lisp, в то время как выходной поток отправляет данные"
" из Lisp на устройство."

#: ./en/ch11.md:49
msgid ""
"The device might be a disk, magnetic tape, network, terminal, or some other "
"kind of device. In this example, we support disk and magnetic-tape devices. "
"The following stream types are related to the device connected to the stream:"
msgstr ""
"Устройством может быть диск, магнитная лента, сеть, терминал или какое-либо"
" другое устройство. В этом примере мы поддерживаем дисковые устройства и"
" устройства с магнитной лентой. Следующие типы потоков связаны с устройством,"
" подключенным к потоку:"

#: ./en/ch11.md:51
msgid ""
"    > disk stream                Transmits data to and from a disk device "
msgstr ""
"\t    > disk stream                (дисковый поток) Передает данные на"
" дисковое устройство и с него"

#: ./en/ch11.md:53
msgid ""
"    > tape stream                Transmits data to and from a magnetic tape "
"device"
msgstr ""
"\t    > tape stream                (поток ленты) Передает данные на"
" устройство с магнитной лентой и с него"

#: ./en/ch11.md:55
msgid ""
"When you use a stream, that stream has three aspects: a direction, an "
"element type, and a device type. For example, when saving the contents of an "
"editor buffer to a disk file, you are using a stream that is at once a "
"character stream, an output stream, and a disk stream. "
msgstr ""
"Когда вы используете поток, этот поток имеет три аспекта: направление, тип"
" элемента и тип устройства. Например, при сохранении содержимого буфера"
" редактора в файл на диске вы используете поток, который одновременно"
" является потоком символьных знаков(литералов), выходным потоком и дисковым"
" потоком."

#: ./en/ch11.md:57
msgid ""
"Common Lisp defines the notion of directional streams; the predicates input-"
"stream-p, output-stream-p, and bidirectional-stream-p are used to determine "
"the direction of a stream. Common Lisp also defines the notion of element "
"type streams by providing the stream-element-type function to query a stream "
"for its element type. Device streams are not a Common Lisp concept; they "
"belong to the design of our stream foundation."
msgstr ""
"Common Lisp определяет понятие направленных потоков; предикаты"
" input-stream-p, output-stream-p и bidirectional-stream-p используются для"
" определения направления потока. Common Lisp также определяет понятие потоков"
" типа элемента, предоставляя функцию stream-element-type для запроса потока"
" по его типу элемента. Потоки устройств не являются концепцией Common Lisp;"
" они относятся к нашему проекту основания потока(stream foundation)."

#: ./en/ch11.md:59
msgid "### The Stream's Type Determines Its Operations"
msgstr "### Тип Потока Определяет Его Операции"

#: ./en/ch11.md:61
msgid ""
"The type of a stream determines which operations can be performed on that "
"stream. An output stream supports operations such as force-output and finish-"
"output. A character input stream supports read-char; a character output "
"stream supports write-char. A character bidirectional stream supports both "
"the character input and output operations. Similarly, a byte input stream "
"supports read-byte; a byte output stream supports write-byte; and a byte "
"bidirectional stream supports both read-byte and write-byte."
msgstr ""
"Тип потока определяет, какие операции могут быть выполнены в этом потоке."
" Выходной поток поддерживает такие операции, как force-output и"
" finish-output. Поток ввода символьных знаков поддерживает read-char; поток"
" вывода символьных знаков поддерживает write-char. Двунаправленный поток"
" символьных знаков(character bidirectional) поддерживает как операции ввода,"
" так и вывода символов. Аналогично, входной поток байтов поддерживает"
" read-byte; выходной поток байтов поддерживает write-byte; и двунаправленный"
" поток байтов поддерживает как read-byte, так и write-byte."

#: ./en/ch11.md:63
msgid ""
"The device type of a stream also controls the operations that can be "
"performed on the stream. In this example, the magnetic-tape device supports "
"sequential access, and the disk device supports both sequential and random "
"access. Because we have greater control in using the disk device, the disk "
"streams have greater capabilities than do the tape streams, which are "
"limited to sequential operations. "
msgstr ""
"Тип устройства потока также определяет операции, которые могут быть выполнены"
" в потоке. В этом примере устройство с магнитной лентой поддерживает"
" последовательный доступ, а дисковое устройство поддерживает как"
" последовательный, так и произвольный доступ. Поскольку мы имеем больший"
" контроль при использовании дискового устройства, дисковые потоки обладают"
" большими возможностями, чем ленточные(tape) потоки, которые ограничены"
" последовательными операциями."

#: ./en/ch11.md:65
msgid "### Creating and Using Streams"
msgstr "### Создание и использование потоков"

#: ./en/ch11.md:67
msgid ""
"One way to create a stream is to open a file. The function open returns a "
"stream connected to the specified file. The arguments to open control the "
"type of the stream. For example, to create a character output stream (for "
"the purpose of transmitting characters to a file), you could evaluate this "
"form, with an appropriate filename argument:"
msgstr ""
"Один из способов создать поток - это открыть файл. Функция open возвращает"
" поток, подключенный к указанному файлу. Аргументы для открытия управляют"
" типом потока. Например, чтобы создать поток вывода символьных знаков   (с"
" целью передачи символьных знаков в файл), вы могли бы оценить эту форму с"
" соответствующим аргументом filename:"

#: ./en/ch11.md:71
msgid ""
"<pre>\n"
"(open filename :direction :output :element-type 'character) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:73
msgid ""
"The device type of the file stream is extracted from the filename argument. "
"If the filename indicates a disk device, the stream will be a disk stream. "
"When you are finished using the file, you can close the stream. No input or "
"output operations are permitted on a closed stream."
msgstr ""
"Тип устройства файлового потока извлекается из аргумента filename. Если имя"
" файла указывает на дисковое устройство, поток будет дисковым потоком. Когда"
" вы закончите использовать файл, вы можете закрыть поток. Никакие операции"
" ввода или вывода не разрешены в закрытом потоке."

#: ./en/ch11.md:77
msgid ""
"<pre>\n"
"(close filename) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:79
msgid ""
"When you use open, you are creating a file stream. A file stream supports "
"operations on files such as deleting and renaming. Our stream foundation "
"provides the lower-level support for file streams; file streams could be "
"built on this foundation."
msgstr ""
"Когда вы используете open, вы создаете файловый поток. Файловый поток"
" поддерживает операции с файлами, такие как удаление и переименование. Наше"
" основание потока(stream foundation) обеспечивает поддержку файловых потоков"
" более низкого уровня; файловые потоки могут быть построены на этом"
" фундаменте."

#: ./en/ch11.md:81
msgid "## 11.2 DESIGN OF OUR STREAM FOUNDATION "
msgstr "## 11.2 ПРОЕКТИРОВАНИЕ НАШЕГО ОСНОВАНИЯ ПОТОКА(STREAM FOUNDATION)"

#: ./en/ch11.md:83
msgid "We have the following design goals: "
msgstr "У нас есть следующие цели в области проектирования:"

#: ./en/ch11.md:87
msgid ""
"*   To organize a set of stream classes in a way that accurately reflects "
"the relationships among the different kinds of streams. \n"
"*   To extract common behavior into distinct modules that can be used in "
"several contexts. In other words, we will define a set of classes, each of "
"which has methods that support a well-defined aspect of stream behavior. We "
"want to share code that is common among several classes, to avoid "
"duplication of code, and to make the program as a whole smaller, simpler, "
"and easier to maintain. \n"
"*    To plan for extensions to our foundation. We will define an internal "
"protocol, use it within our implementation, and document it for other "
"programmers to use."
msgstr ""
"* Организовать набор классов потоков таким образом, чтобы точно отражать"
" взаимосвязи между различными типами потоков.\n"
"* Для выделения общего поведения в отдельные модули, которые могут"
" использоваться в нескольких контекстах. Другими словами, мы определим набор"
" классов, каждый из которых имеет методы, поддерживающие четко определенный"
" аспект поведения потока. Мы хотим разделять(сделать общим) код, который"
" является общим для нескольких классов, чтобы избежать дублирования кода и"
" сделать программу в целом меньше, проще и удобнее в обслуживании.\n"
"* Планировать расширение нашего основания(foundation). Мы определим"
" внутренний протокол, будем использовать его в нашей реализации и"
" задокументируем для использования другими программистами."

#: ./en/ch11.md:89
msgid "###  Organization of Stream Classes "
msgstr "### Организация потоковых классов"

#: ./en/ch11.md:91
msgid "To meet the stated goals, we define these groups of classes: "
msgstr "Для достижения заявленных целей мы определяем эти группы классов:"

#: ./en/ch11.md:96
msgid ""
"*   The foundation of all streams: stream \n"
"*   Directional streams, including input-stream, output-stream, "
"bidirectional-stream \n"
"*   Element type streams, including character-stream, byte-stream \n"
"*   Device streams, including disk-stream, tape-stream"
msgstr ""
"* Основа всех потоков: stream(поток)\n"
"* Направленные потоки, включая input-stream(входящий),"
" output-stream(исходящий), bidirectional-stream(двунаправленный)\n"
"* Потоки типов элементов, включая character-stream(поток символьных знаков),"
" byte-stream(байтовый поток)\n"
"* Потоки устройств, включая disk-stream(дисковый поток),"
" tape-stream(ленточный поток)"

#: ./en/ch11.md:98
msgid ""
"Our design effectively defines a stream as \"an object built on the stream "
"class.\" Thus, clients can find out whether an object is a stream by using "
"typep, as well as by using streamp. The following two forms are equivalent:"
msgstr ""
"Наш проект эффективно определяет поток как \"объект, построенный на классе"
" stream\". Таким образом, клиенты могут узнать, является ли объект потоком,"
" используя typep, а также используя streamp. Следующие две формы эквивалентны:"

#: ./en/ch11.md:103
msgid ""
"<pre>\n"
"(typep object 'stream) \n"
"(streamp object) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:105
msgid ""
"Each of these classes is a building block equipped to handle only one as "
"pect of the stream. A complete stream consists of building blocks that "
"specify the direction, the element type, and the device. One example of a "
"complete stream is character-disk-input-stream: This class inherits from "
"character-stream, disk-stream, input-stream, and stream."
msgstr ""
"Каждый из этих классов представляет собой строительный блок, предназначенный"
" для обработки только одного аспекта потока. Полный поток состоит из"
" строительных блоков, которые определяют направление, тип элемента и"
" устройство. Одним из примеров полного потока является"
" character-disk-input-stream: этот класс наследуется от character-stream,"
" disk-stream, input-stream и stream."

#: ./en/ch11.md:107
msgid ""
"The device streams manipulate elements of data without knowing whether the "
"elements are characters or bytes. Each element type stream manipulates data "
"with knowledge of the datatype, but without knowledge of the various "
"devices. We want to isolate the device-specific operations within the realm "
"of the device streams, and to isolate all datatype specific operations "
"within the element type streams."
msgstr ""
"Потоки устройства манипулируют элементами данных, не зная, являются ли эти"
" элементы символьными знаками(characters) или байтами. Каждый поток с типом"
" элемента манипулирует данными со знанием типа данных, но без знания"
" различных устройств. Мы хотим изолировать операции, относящиеся к"
" конкретному устройству, в области потоков устройств и изолировать все"
" операции, относящиеся к конкретному типу данных, в потоках с типом элементов."

#: ./en/ch11.md:109
msgid ""
"This design makes it easy for clients to extend our stream program. To add "
"support for a new element type, the client needs to provide methods for only "
"the generic functions that are specific to the element type of the stream. "
"The new element type stream immediately works with all types of devices "
"supporting the internal protocol. Similarly, introducing a new device "
"requires adding methods for the device-specific generic functions, and the "
"new device will immediately work with all types of elements."
msgstr ""
"Такой проект позволяет клиентам легко расширять нашу потоковую программу."
" Чтобы добавить поддержку нового типа элемента, клиенту необходимо"
" предоставить методы только для обобщенных функций, специфичных для типа"
" элемента потока. Поток с новым типом элементов немедленно работает со всеми"
" типами устройств, поддерживающих внутренний протокол. Аналогично, внедрение"
" нового устройства требует добавления методов для обобщенных функций,"
" специфичных для конкретного устройства, и новое устройство сразу же будет"
" работать со всеми типами элементов."

#: ./en/ch11.md:111
msgid ""
"There are three basic directional types of streams, each of which is  built "
"on stream: input-stream, output-stream, and bidirectional-stream. As shown "
"in Fig. 11.1, bidirectional-stream is built on both input-stream and output-"
"stream."
msgstr ""
"Существует три основных направленных типа потоков, каждый из которых построен"
" на потоке: input-stream(входящий поток), output-stream(выходной поток) и"
" bidirectional-stream(двунаправленный поток). Как показано на рис. 11.1,"
" двунаправленный поток построен как на входящем потоке, так и на выходном"
" потоке."

#: ./en/ch11.md:114
msgid ""
"![Figure 11.1: Directional stream classes.](images/f11-01.jpg)\n"
"**Figure 11.1: Directional stream classes.**"
msgstr ""
"![Рисунок 11.1: Классы направленного потока.](images/f11-01.jpg )"
"**Рисунок 11.1: Классы направленного потока.**"

#: ./en/ch11.md:116
msgid ""
"This pattern is reflected in the other groups of classes. Figure 11.2 shows "
"the organization of character classes."
msgstr ""
"Эта закономерность отражена и в других группах классов. На рисунке 11.2"
" показана организация классов символьных знаков."

#: ./en/ch11.md:118
msgid ""
"Although not shown in these figures, each of the character stream classes is "
"built on a directional stream class. That is, character-stream is built on "
"stream, character-input-stream is built on input-stream, and so on. "
msgstr ""
"Хотя это и не показано на этих рисунках, каждый из классов потока символьных"
" знаков построен на классе направленного потока. То есть"
" character-stream(поток символьных знаков) строится на stream(потоке),"
" character-input-stream(входящий поток символьных знаков) строится на"
" input-stream(входящем потоке) и так далее."

#: ./en/ch11.md:121
msgid ""
"![Figure 11.2: Character stream classes.](images/f11-02.jpg)\n"
"**Figure 11.2: Character stream classes.**"
msgstr ""
"![Рисунок 11.2: Классы потока символьных знаков.](images/f11-02.jpg )"
"**Рисунок 11.2: Классы потока символьных знаков.**"

#: ./en/ch11.md:123
msgid ""
"The device stream classes follow the same pattern. For example, we will "
"define the following classes for the disk device: disk-stream, disk-input-"
"stream, disk-output-stream, and disk-bidirectional-stream."
msgstr ""
"Классы потока устройств следуют тому же шаблону. Например, мы определим"
" следующие классы для дискового устройства: disk-stream, disk-input-stream,"
" disk-output-stream и disk-bidirectional-stream."

#: ./en/ch11.md:125
msgid "### External Stream Protocol "
msgstr "### Внешний Протокол потока"

#: ./en/ch11.md:127
msgid ""
"The external protocol of streams is specified in Common LISP: The Language. "
"In this example, we implement the following subset of the Common Lisp stream "
"operations: "
msgstr ""
"Внешний протокол потоков указан в Common LISP: The Language. В этом примере"
" мы реализуем следующее подмножество потоковых операций Common Lisp:"

#: ./en/ch11.md:140
msgid ""
"| Stream Type            | Operations                       |\n"
"|------------------------|----------------------------------|\n"
"| all streams            | input-stream-p, output-stream-p, |\n"
"|                        | close, stream-element-type       |\n"
"| output                 | force-output, finish-output      |\n"
"| byte input             | read-byte                        |\n"
"| byte output            | write-byte                       |\n"
"| byte bidirectional     | read-byte, write-byte            |\n"
"| character input        | read-char                        |\n"
"| character output       | write-char                       |\n"
"| character bidirectional| read-char, write-char            |\n"
"| disk                   | set-position                     |"
msgstr ""
"| Тип потока             | Операции                         |\n"
"|------------------------|----------------------------------|\n"
"| all streams            | input-stream-p, output-stream-p, |\n"
"|                        | close, stream-element-type       |\n"
"| output                 | force-output, finish-output      |\n"
"| byte input             | read-byte                        |\n"
"| byte output            | write-byte                       |\n"
"| byte bidirectional     | read-byte, write-byte            |\n"
"| character input        | read-char                        |\n"
"| character output       | write-char                       |\n"
"| character bidirectional| read-char, write-char            |\n"
"| disk                   | set-position                     |"

#: ./en/ch11.md:142
msgid ""
"The function set-position is an extension to Common Lisp for disk streams. "
"We document the contract of set-position here:"
msgstr ""
"Функция set-position является расширением Common Lisp для дисковых потоков."
" Мы документируем контракт на установку позиции здесь:"

#: ./en/ch11.md:148
msgid ""
"    > set-position stream new-position &optional eof-error-p eof-value \n"
"    >             Sets the current position to the desired element position. "
"The element position is the\n"
"    >             element number in the file, where the first element is  "
"number 0, the next is 1, and so\n"
"    >             on. If the new-position is beyond the end of file, eof-"
"error-p and eof-value define\n"
"    >             whether an error or a value is returned; otherwise, the "
"new position is returned."
msgstr ""
"\t    > set-position stream new-position &optional eof-error-p eof-value \n"
"\t    >                 Устанавливает текущее положение в нужное положение"
" элемента. Позиция элемента - это\n"
"\t    >                 номер элемента в файле, где первый элемент имеет"
" номер 0, следующий - 1 и так далее.\n"
"\t    >                 Если новая позиция находится за пределами конца"
" файла, eof-error-p и eof-value определяют,\n"
"\t    >                 возвращается ли ошибка или значение; в противном"
" случае возвращается новая позиция."

#: ./en/ch11.md:150
msgid ""
"We discuss how streams are created and opened later, in \"A Procedural "
"Definition for Creating Streams,\" page 207."
msgstr ""
"Мы обсудим, как создаются и открываются потоки позже, в разделе \"Процедурное"
" определение для создания потоков\", стр. 207."

#: ./en/ch11.md:152
msgid "### Internal Stream Protocol"
msgstr "### Внутренний Протокол Потока"

#: ./en/ch11.md:154
msgid ""
"Our purpose in defining an internal protocol is to codify the communication "
"among the different stream classes. This makes it possible for each class to "
"implement a well-defined aspect of the internal protocol and depend on the "
"other classes to implement their aspects. The internal stream protocol "
"consists of the following operations:"
msgstr "### Протокол внутреннего потока"

#: ./en/ch11.md:158
msgid ""
"    >  bytes-per-element stream \n"
"    >               Supported by all element type streams. Returns the "
"number of eight-bit bytes required\n"
"    >               to store one element of this datatype. This must be a "
"positive integer. "
msgstr ""
"\t    >  bytes-per-element stream \n"
"\t    >              Поддерживается всеми потоками типов элементов."
" Возвращает количество восьмиразрядных\n"
"\t    >              байт, необходимых для хранения одного элемента этого"
" типа данных. Это должно быть\n"
"\t    >              положительное целое число."

#: ./en/ch11.md:163
msgid ""
"    >  storage-unit-size stream \n"
"    >               Supported by all device streams. Returns the size of a "
"unit normally read or written\n"
"    >               by this device, expressed in eightbit bytes. For a disk "
"stream, this is the size of a\n"
"    >               disk sector. For a tape stream, this is the size of a "
"tape record."
msgstr ""
"\t    >  storage-unit-size stream \n"
"\t    >             Поддерживается всеми потоками устройств. Возвращает"
" размер единицы, обычно считываемой\n"
"\t    >             или записываемой этим устройством, выраженный в"
" восьмибитных байтах. Для дискового потока\n"
"\t    >             это размер сектора диска. Для ленточного потока это"
" размер записи на магнитной ленте."

#: ./en/ch11.md:170
msgid ""
"    >  make-element-array stream \n"
"    >               Supported by all streams. Creates an array to serve as a "
"buffer for input or output.\n"
"    >               The size of the array is appropriate for the device ("
"note that the low-level device\n"
"    >               primitives read and write in fixed-size blocks), and for "
"the element type appropriate\n"
"    >               to the stream. This can be implemented in terms of "
"storage-unit-size,\n"
"    >               stream-element-type, and bytes-per-element."
msgstr ""
"\t    >  make-element-array stream \n"
"\t    >              Поддерживается всеми потоками. Создает массив, который"
" будет служить буфером для ввода\n"
"\t    >              или вывода.\n"
"\t    >              Размер массива соответствует устройству (обратите"
" внимание, что примитивы устройств \n"
"\t    >              низкого уровня читают и записывают блоками"
" фиксированного размера) и типу элемента,\n"
"\t    >              соответствующему потоку. Это может быть реализовано с"
" точки зрения размера единицы\n"
"\t    >              хранения(storage-unit-size), типа элемента"
" потока(stream-element-type) и байтов на элемент\n"
"\t    >              (bytes-per-element)."

#: ./en/ch11.md:174
msgid ""
"    >  ensure-open-stream stream \n"
"    >               Supported by all streams. Checks whether a stream is "
"open before allowing access to\n"
"    >               it. Signals an error if an attempt is made to access a "
"stream that is closed."
msgstr ""
"\t    >  ensure-open-stream stream \n"
"\t    >             Поддерживается всеми потоками. Проверяет, открыт ли"
" поток, прежде чем разрешить к нему\n"
"\t    >             доступ. Сигнализирует об ошибке, если предпринята попытка"
" получить доступ к закрытому потоку."

#: ./en/ch11.md:179
msgid ""
"    >  read-next-element input-stream \n"
"    >               Supported by all device input streams. Uses low-level "
"device primitives to read one\n"
"    >               element of data. Returns a second value, which is t if "
"the end of file was reached,\n"
"    >               else nil."
msgstr ""
"\t    >  read-next-element input-stream \n"
"\t    >             Поддерживается всеми входными потоками устройств."
" Использует низкоуровневые примитивы\n"
"\t    >             устройств для чтения одного элемента данных. Возвращает"
" второе значение, которое равно t,\n"
"\t    >             если был достигнут конец файла, в противном случае nil."

#: ./en/ch11.md:183
msgid ""
"    >  write-next-element output-stream \n"
"    >               Supported by all device output streams. Uses low-level "
"device primitives to write\n"
"    >               one element of data."
msgstr ""
"\t    >  write-next-element output-stream \n"
"\t    >            Поддерживается всеми выходными потоками устройства."
" Использует низкоуровневые примитивы\n"
"\t    >            устройств для записи одного элемента данных."

#: ./en/ch11.md:186
msgid ""
"    >  force-output-internal output-stream \n"
"    >               Supported by all output streams. Does the work of force-"
"output. "
msgstr ""
"\t    >  force-output-internal output-stream \n"
"\t    >              Поддерживается всеми выходными потоками. Выполняет"
" работу по принудительному выводу."

#: ./en/ch11.md:189
msgid ""
"    >  finish-output-internal output-stream \n"
"    >               Supported by all output streams. Does the work of finish-"
"output."
msgstr ""
"\t    >  finish-output-internal output-stream \n"
"\t    >            Поддерживается всеми выходными потоками. Выполняет работу"
" по завершению вывода."

#: ./en/ch11.md:191
msgid "### 11.3 EXPERIMENTING WITH THE STREAM EXAMPLE "
msgstr "### 11.3 ЭКСПЕРИМЕНТИРУЕМ С ПРИМЕРОМ ПОТОКА"

#: ./en/ch11.md:193
msgid ""
"If you intend to try out the code in this example, keep in mind that we "
"redefine several important Common Lisp functions that operate on streams. "
"You can define a package for the purpose of testing this example and specify "
"that certain Common Lisp symbols should be shadowed. This enables you to "
"retain the previous definitions of the stream functions, which is necessary "
"for keeping your Lisp usable. (If Common Lisp specified that the stream "
"functions were generic, there would be no need to shadow the existing "
"definitions; you could simply add methods to the existing generic functions.)"
msgstr ""
"Если вы собираетесь опробовать код в этом примере, имейте в виду, что мы"
" переопределяем несколько важных функций Common Lisp, которые работают с"
" потоками. Вы можете определить пакет с целью тестирования этого примера и"
" указать, что определенные символы Common Lisp должны быть затенены. Это"
" позволяет вам сохранить предыдущие определения потоковых функций, что"
" необходимо для того, чтобы ваш Lisp можно было использовать. (Если бы в"
" Common Lisp было указано, что потоковые функции являются обобщенными, не"
" было бы необходимости скрывать существующие определения; вы могли бы просто"
" добавить методы к существующим обобщенным функциям.)"

#: ./en/ch11.md:198
msgid ""
"<pre>\n"
"(setq *clos-streams-package* \n"
"      (make-package 'clos-streams :nicknames '(\"cs\") \n"
"                                  :use 'lisp))"
msgstr ""

#: ./en/ch11.md:206
msgid ""
"(shadow '(input-stream-p output-stream-p \n"
"          force-output finish-output \n"
"          close stream-element-type \n"
"          read-char write-char \n"
"          read-byte write-byte) \n"
"        'clos-streams) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:208
msgid ""
"You will notice that we declare the returned values of generic functions in "
"several defgeneric forms. This is a convenient way to document part of the "
"contract of the generic function—the expected returned values. Although "
"Common Lisp does not specify values as a recognized declaration specifier, "
"we can make it one by proclaiming values as a declaration as follows:"
msgstr ""
"Вы заметите, что мы объявляем возвращаемые значения обобщенных функций в"
" нескольких формах defgeneric. Это удобный способ документировать часть"
" контракта обобщенной функции — ожидаемые возвращаемые значения. Хотя Common"
" Lisp не определяет значения в качестве признанного спецификатора объявления,"
" мы можем сделать его таковым, объявив значения в качестве объявления"
" следующим образом:"

#: ./en/ch11.md:212
msgid ""
"<pre>\n"
"(proclaim ' (declaration values)) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:214
msgid ""
"If we neglected to proclaim values as a declaration, the compiler would "
"probably give a warning that the declaration was unsupported."
msgstr ""
"Если бы мы пренебрегли объявлением значений в качестве объявления,"
" компилятор, вероятно, выдал бы предупреждение о том, что объявление не"
" поддерживается."

#: ./en/ch11.md:216
msgid "## 11.4 DIRECTIONAL STREAMS"
msgstr "## 11.4 НАПРАВЛЕННЫЕ ПОТОКИ"

#: ./en/ch11.md:218
msgid ""
"Here we define the classes stream, input-stream, output-stream, and "
"bidirectional-stream. We also define the methods that each of these classes "
"supplies. Then, we mention aspects of this code that are of particular "
"interest."
msgstr ""
"Здесь мы определяем классы stream, input-stream, output-stream и"
" bidirectional-stream. Мы также определяем методы, которые предоставляет"
" каждый из этих классов. Затем мы упомянем аспекты этого кода, которые"
" представляют особый интерес."

#: ./en/ch11.md:220
msgid ""
"The style of this program groups methods and generic functions according to "
"the class definitions. For example, under the stream class definition, you "
"will find definitions for the generic functions that are supported by all "
"streams. All methods supplied by a class are located under the class "
"definition. We also separate the external interface from the internal "
"interface with comments in the code."
msgstr ""
"Стиль этой программы группирует методы и обобщенные функции в соответствии с"
" определениями классов. Например, в разделе определение класса stream вы"
" найдете определения для обобщенных функций, которые поддерживаются всеми"
" потоками. Все методы, предоставляемые классом, находятся в определении"
" класса. Мы также отделяем внешний интерфейс от внутреннего интерфейса с"
" помощью комментариев в коде."

#: ./en/ch11.md:222
msgid ""
"This style fits this particular example well; another program might benefit "
"from a different style. A program that depends heavily on multi methods "
"could not group methods this way, because a multi-method is attached to more "
"than one class. One alternative would be to group the classes, methods, and "
"generic functions together according to the protocols they support."
msgstr ""
"Этот стиль хорошо подходит для данного конкретного примера; другой программе"
" может быть полезен другой стиль. Программа, которая сильно зависит от"
" нескольких методов, не может группировать методы таким образом, потому что"
" мультиметод присоединен к более чем одному классу. Одной из альтернатив было"
" бы сгруппировать классы, методы и обобщенные функции вместе в соответствии с"
" протоколами, которые они поддерживают."

#: ./en/ch11.md:224
msgid "### Defining Directional Streams "
msgstr "### Определение направленных потоков"

#: ./en/ch11.md:231
msgid ""
"<pre>\n"
";;;; THE CLASS STREAM \n"
";;; This basic class must be included in all streams, \n"
"(defclass stream () \n"
"  ((state :initform 'open :accessor stream-state)) \n"
"  (:documentation \"Foundation of all streams.\")) "
msgstr ""

#: ./en/ch11.md:237
msgid ""
";;;; EXTERNAL PROTOCOL SUPPORTED BY ALL STREAMS \n"
";;; Page 332 in Common LISP: The Language \n"
"(defgeneric input-stream-p (stream) \n"
"   ;; Input streams should override this default method. \n"
"   (:method ((stream stream)) nil)) "
msgstr ""

#: ./en/ch11.md:242
msgid ""
";;; Page 332 in Common LISP: The Language \n"
"(defgeneric output-stream-p (stream) \n"
"   ;; Output streams should override this default method. \n"
"   (:method ((stream stream)) nil)) "
msgstr ""

#: ./en/ch11.md:249
msgid ""
";;; Page 332 in Common LISP: The Language \n"
"(defgeneric close (stream Skey abort) \n"
"   (:documentation \"Prevents further I/O operations on stream\") \n"
"   (:method ((stream stream) Skey abort) \n"
"      (declare (ignore abort)) \n"
"      (setf (stream-state stream) 'closed))) "
msgstr ""

#: ./en/ch11.md:254
msgid ""
";;; Page 332 in Common LISP: The Language \n"
";;; Must be implemented by the element type streams, \n"
"(defgeneric stream-element-type (stream) \n"
"   (:documentation \"Returns the type of elements of stream\")) "
msgstr ""

#: ./en/ch11.md:262
msgid ""
";;;; INTERNAL PROTOCOL SUPPORTED BY ALL STREAMS \n"
"(defun ensure-open-stream (stream) \n"
"   \"Prevents access to a stream if it is not open.\" \n"
"   (let ((state (stream-state stream))) \n"
"      (unless (eq state 'open) \n"
"         (error \"Attempt to use stream ~A which is -A\" \n"
"                stream state)))) "
msgstr ""

#: ./en/ch11.md:267
msgid ""
";;; bytes-per-element must be implemented by element type streams. \n"
"(defgeneric bytes-per-element (stream) \n"
"   (declare (values n-bytes)) \n"
"   (:documentation \"Returns length of one element, in 8-bit bytes.\")) "
msgstr ""

#: ./en/ch11.md:272
msgid ""
";;; storage-unit-size must be implemented by device streams, \n"
"(defgeneric storage-unit-size (stream) \n"
"   (declare (values n-bytes)) \n"
"   (:documentation \"Returns size of i/o buffer, in 8-bit bytes.\")) "
msgstr ""

#: ./en/ch11.md:278
msgid ""
"(defun make-element-array (stream) \n"
"   \"Returns array of correct size and element type for stream.\" \n"
"   (make-array (/ (storage-unit-size stream) \n"
"                  (bytes-per-element stream)) \n"
"               :element-type (stream-element-type stream))) "
msgstr ""

#: ./en/ch11.md:284
msgid ""
";;;; THE CLASS INPUT-STREAM AND ITS METHODS \n"
";;; This basic class must be included in all input streams, \n"
"(defclass input-stream (stream) () \n"
"  (:documentation \"Foundation of all input streams.\")) "
msgstr ""

#: ./en/ch11.md:288
msgid ""
";;; Override the default primary method to return true, \n"
"(defmethod input-stream-p ((stream input-stream)) \n"
"   t) "
msgstr ""

#: ./en/ch11.md:299
msgid ""
";;;; INTERNAL PROTOCOL SUPPORTED BY ALL INPUT STREAMS \n"
";;; Make sure the stream is open before any input is allowed, \n"
"(defgeneric read-next-element (input-stream) \n"
"   (declare (values element eof-p)) \n"
"   (:method :before ((stream input-stream)) \n"
"      ;; This method ensures that stream is open before \n"
"      ;; reading; it is inherited by all element type input \n"
"      ;; streams, so it saves each of those methods from \n"
"      ;; duplicating this code, \n"
"      (ensure-open-stream stream)))"
msgstr ""

#: ./en/ch11.md:308
msgid ""
";;; This default method on stream is overridden by input \n"
";;; streams. It is defined simply to give a comprehensible \n"
";;; error message when this situation occurs, and to make it \n"
";;; unnecessary for all external functions to check the \n"
";;; stream argument type. \n"
"(defmethod read-next-element ((stream stream)) \n"
"   (error \"Cannot get input from stream ~A of type ~A.\" \n"
"          stream (type-of stream)))"
msgstr ""

#: ./en/ch11.md:313
msgid ""
";;;; THE CLASS OUTPUT-STREAM AND ITS METHODS \n"
";;; This basic class must be included in all output streams, \n"
"(defclass output-stream (stream) () \n"
"  (:documentation \"Foundation of all output streams.\")) "
msgstr ""

#: ./en/ch11.md:317
msgid ""
";;; Override the default primary method to return true, \n"
"(defmethod output-stream-p ((stream output-stream)) \n"
"   t) "
msgstr ""

#: ./en/ch11.md:335
msgid ""
";;;; EXTERNAL PROTOCOL SUPPORTED BY ALL OUTPUT STREAMS \n"
";; Although COMMON LISP implies that force-output \n"
";; and finish-output are supported by character \n"
";; streams only, they should apply to all output \n"
";; output streams, which is how we do it below. \n"
";; Also, since COMMON LISP specifies that the stream \n"
";; argument of force-output and finish-output is \n"
";; optional, we can't implement these operations \n"
";; directly as generic functions. \n"
";; Therefore, we define force-output-internal and \n"
";; finish-output-internal as generic functions, both of \n"
";; which belong to the internal protocol. \n"
";; Standardize stream variable if t or nil was given \n"
"(defmacro standardize-output-stream-var (stream) \n"
"   `(setf ,stream (cond ((eq ,stream t) *terminal-io*) \n"
"                        ((null ,stream) *standard-output*) \n"
"                        (t ,stream))))"
msgstr ""

#: ./en/ch11.md:340
msgid ""
";;; Page 384 in Common LISP: The Language \n"
"(defun force-output (Soptional (stream *standard-output*)) \n"
"   (standardize-output-stream-var stream) \n"
"   (force-output-internal stream))"
msgstr ""

#: ./en/ch11.md:345
msgid ""
";;; Page 384 in Common LISP: The Language \n"
"(defun finish-output (soptional (stream *standard-output*)) \n"
"   (standardize-output-stream-var stream) \n"
"   (finish-output-internal stream))"
msgstr ""

#: ./en/ch11.md:351
msgid ""
";;;; INTERNAL PROTOCOL SUPPORTED BY ALL OUTPUT STREAMS \n"
"(defgeneric force-output-internal (output-stream) \n"
"   (:method :before ((stream output-stream)) \n"
"      ;; The stream must be open, else generate an error, \n"
"      (ensure-open-stream stream))) "
msgstr ""

#: ./en/ch11.md:356
msgid ""
"(defgeneric finish-output-internal (output-stream) \n"
"   (:method -.before ((stream output-stream)) \n"
"      ;; The stream must be open, else generate an error, \n"
"      (ensure-open-stream stream))) "
msgstr ""

#: ./en/ch11.md:366
msgid ""
"(defgeneric write-next-element (output-stream element) \n"
"   (:method :before ((stream output-stream) element) \n"
"      (declare (ignore element)) \n"
"      ;; Default method ensures that stream is open before \n"
"      ;; writing. This method is inherited by all element type \n"
"      ;; output streams, and thus it saves each of those \n"
"      ;; methods from duplicating this code, \n"
"      (ensure-open-stream stream)))"
msgstr ""

#: ./en/ch11.md:375
msgid ""
";;; This default method on stream is overridden by outpuf streams. \n"
";;; It is defined simply to give a comprehensible error message \n"
";;; when this situation occurs, and to make it unnecessary for \n"
";;; all user-interface functions to check the stream argument type, \n"
"(defmethod write-next-element ((stream stream) element) \n"
"   (declare (ignore element)) \n"
"   (error \"Cannot do output to stream -A of type -A.\" \n"
"          stream (type-of stream)))"
msgstr ""

#: ./en/ch11.md:384
msgid ""
";;; THE CLASS BIDIRECTIONAL-STREAM \n"
";;; This class inherits all needed methods, and supplies none \n"
";;; of its own. \n"
"(defclass bidirectional-stream \n"
"    (input-stream output-stream) \n"
"  () \n"
"  (:documentation \"A combined input and output stream.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:386
msgid "### Highlights of Directional Streams "
msgstr "### Основные моменты направленных потоков"

#: ./en/ch11.md:388
msgid ""
"The relationships among directional streams are defined here. All streams "
"are built on the class stream. Input streams are built on input-stream, and "
"output streams are built on output-stream."
msgstr ""
"Здесь определены взаимосвязи между направленными потоками. Все потоки"
" построены на классе stream. Входные потоки строятся на input-stream, а"
" выходные потоки строятся на output-stream."

#: ./en/ch11.md:390
msgid ""
"The Common Lisp type predicates on streams are defined here, including input-"
"stream-p and output-stream-p. The inheritance of these methods works neatly "
"and effectively."
msgstr ""
"Здесь определены предикаты типа Common Lisp для потоков, включая"
" input-stream-p и output-stream-p. Наследование этих методов работает"
" аккуратно и эффективно."

#: ./en/ch11.md:393
msgid ""
"*     The class stream provides default methods for input-stream-p and "
"output-stream-p, which return nil. \n"
"*      The class input-stream provides a method for input-stream-p that "
"overrides the default method and returns t. However, the class input-stream "
"inherits the default method for output-stream-p. "
msgstr ""
"* Класс stream предоставляет методы по умолчанию для input-stream-p и"
" output-stream-p, которые возвращают nil.\n"
"* Класс input-stream предоставляет метод для input-stream-p, который"
" переопределяет метод по умолчанию и возвращает t. Однако класс input-stream"
" наследует метод по умолчанию для output-stream-p."

#: ./en/ch11.md:396
msgid ""
"*      The class output-stream provides a method for output-stream-p that "
"overrides the default method and returns t. However, the class output-stream "
"inherits the default method for input-stream-p. \n"
"*       The class bidirectional-stream inherits all these methods from its "
"superclasses input-stream, output-stream, and stream. The method for input-"
"stream-p supplied by class input-stream overrides the method supplied by the "
"class stream; therefore, a bidirectional stream is defined to be an input "
"stream. Similarly, a bidirectional stream is defined to be an output stream."
msgstr ""
"* Класс output-stream предоставляет метод для output-stream-p, который"
" переопределяет метод по умолчанию и возвращает t. Однако класс output-stream"
" наследует метод по умолчанию для input-stream-p.\n"
"* Класс bidirectional-stream наследует все эти методы от своих суперклассов"
" input-stream, output-stream и stream. Метод для input-stream-p,"
" предоставляемый классом input-stream, переопределяет метод, предоставляемый"
" классом stream; следовательно, двунаправленный поток определяется как"
" входной поток. Аналогично, двунаправленный поток определяется как выходной"
" поток."

#: ./en/ch11.md:398
msgid ""
"Sometimes it is not possible to implement a function as a generic function. "
"For example, Common Lisp specifies that the stream argument to force-output "
"is optional. In CLOS, methods cannot specialize on optional arguments. Since "
"we want the stream argument to select methods, we define force-output as an "
"ordinary function, which processes its arguments and then calls force-output-"
"internal to do its work. We define force-output-internal as a generic "
"function whose stream argument is required. We do the same for finish-output."
msgstr ""
"Иногда невозможно реализовать функцию как обобщенную функцию. Например,"
" Common Lisp указывает, что аргумент stream для force-output(принудительного"
" вывода) является необязательным. В CLOS методы не могут специализироваться"
" на необязательных аргументах. Поскольку мы хотим, чтобы аргумент stream"
" выбирал методы, мы определяем force-output как обычную функцию, которая"
" обрабатывает свои аргументы, а затем вызывает force-output-internal для"
" выполнения своей работы. Мы определяем force-output-internal как обобщенную"
" функцию, аргумент потока которой является обязательным. Мы делаем то же"
" самое для finish-output."

#: ./en/ch11.md:400
msgid ""
"We implemented ensure-open-stream and make-element-array as ordinary Lisp "
"functions. We do not anticipate that different types of streams will need "
"specialized behavior for these operations. The stream protocol can be "
"implemented in terms of both ordinary and generic functions."
msgstr ""
"Мы реализовали ensure-open-stream и make-element-array как обычные функции"
" Lisp. Мы не ожидаем, что различные типы потоков будут нуждаться в"
" специализированном поведении для этих операций. Потоковый протокол может"
" быть реализован в терминах как обычных, так и обобщенных функций."

#: ./en/ch11.md:402
msgid "## 11.5 TAPE STREAMS"
msgstr "## 11.5 ПОТОКИ ЛЕНТЫ(TAPE)"

#: ./en/ch11.md:404
msgid ""
"For the purpose of this example, we assume an extremely simple tape system. "
"Tape streams do not support all the capabilities of disk streams because the "
"tape device supports sequential access, not random access. Note that tape "
"streams do not support set-position or the appending of data. We also do not "
"provide a bidirectional tape stream."
msgstr ""
"Для целей этого примера мы предполагаем чрезвычайно простую ленточную(tape)"
" систему. Ленточные потоки не поддерживают все возможности дисковых потоков,"
" поскольку ленточное устройство поддерживает последовательный доступ, а не"
" произвольный доступ. Обратите внимание, что ленточные потоки не поддерживают"
" установку положения или добавление данных. Мы также не предоставляем"
" двунаправленный поток ленты."

#: ./en/ch11.md:406
msgid "### Low-Level Tape Interface"
msgstr "### Низкоуровневый интерфейс ленты(Tape) "

#: ./en/ch11.md:408
msgid ""
"Here we specify the interface to an imaginary operating system for streams "
"to magnetic-tape units. We document these primitives, but do not include "
"Lisp code that implements them. We assume that these primitives exist, and "
"we call them in the methods for tape streams."
msgstr ""
"Здесь мы указываем интерфейс к воображаемой операционной системе для потоков"
" на устройства с магнитной лентой. Мы документируем эти примитивы, но не"
" включаем код Lisp, который их реализует. Мы предполагаем, что эти примитивы"
" существуют, и мы вызываем их в методах для ленточных потоков."

#: ./en/ch11.md:410
msgid ""
"To keep the example simple, tape records are all fixed size, except for the "
"last record, which usually is incomplete (it does not contain a full tape "
"record of data), and thus smaller. This tape system supports only one "
"contiguous amount of data, starting at the beginning of the tape and going "
"to an EOF (end of file) mark. "
msgstr ""
"Чтобы упростить пример, все записи на магнитной ленте имеют фиксированный"
" размер, за исключением последней записи, которая обычно является неполной"
" (она не содержит полной записи данных на магнитной ленте) и, следовательно,"
" меньше. Эта ленточная система поддерживает только один непрерывный объем"
" данных, начиная с начала ленты и заканчивая отметкой EOF (конец файла)."

#: ./en/ch11.md:413
msgid ""
"\t>      open-tape-unit tape-unit-number \n"
"\t>             Returns a \"tape-handle\" identifying the tape unit."
msgstr ""
"\t>      open-tape-unit tape-unit-number \n"
"\t>                     Возвращает \"дескриптор ленты/tape-handle\","
" идентифицирующий блок ленты(tape unit)."

#: ./en/ch11.md:416
msgid ""
"\t>      close-tape-unit tape-handle \n"
"\t>             Closes the tape unit and deallocates the tape-handle."
msgstr ""
"\t>      close-tape-unit tape-handle \n"
"\t>               Закрывает блок управления лентой и освобождает tape-handle."

#: ./en/ch11.md:423
msgid ""
"\t>      read-record tape-handle array element-type \n"
"\t>             Reads the next tape record into the array. Returns two \n"
"\t>             values, named eof and eof-position. The first value (eof) is "
"\n"
"\t>             nil if the array contains a complete record, or t if the ar- "
"\n"
"\t>             ray contains an incomplete record; in this case, the second "
"\n"
"\t>             value is a number marking the position of the EOF."
msgstr ""
"\t>      read-record tape-handle array element-type \n"
"\t>                    Считывает следующую запись на ленте в массив."
" Возвращает два значения с именами eof\n"
"\t>                    и eof-position. Первое значение (eof) равно нулю, если"
" массив содержит полную запись, \n"
"\t>                    или t, если массив содержит неполную запись; в этом"
" случае второе значение представляет\n"
"\t>                    собой число, обозначающее позицию EOF."

#: ./en/ch11.md:430
msgid ""
"\t>      write-record tape-handle array element-type soptional (size *tape-"
"record-byte-size*) \n"
"\t>             Writes the contents of the array into the next tape record. "
"\n"
"\t>             The size argument is used for writing the last record, \n"
"\t>             which is usually incomplete, and thus smaller than *tape- \n"
"\t>             record-byte-size*, write-record does not write any ele- \n"
"\t>             ments of the array past the given size. "
msgstr ""
"\t>      write-record tape-handle array element-type soptional (size *tape-"
"record-byte-size*) \n"
"\t>                 Записывает содержимое массива в следующую запись на"
" магнитной ленте. Аргумент size\n"
"\t>                 используется для записи последней записи, которая обычно"
" является неполной и, \n"
"\t>                 следовательно, меньше, чем *tape-record-byte-size*,"
" write-record не записывает никаких\n"
"\t>                 элементов массива, превышающих заданный размер."

#: ./en/ch11.md:433
msgid ""
"\t>      write-eof-mark tape-handle \n"
"\t>            Writes an EOF mark on the tape. "
msgstr ""
"\t>      write-eof-mark tape-handle \n"
"\t>               Записывает метку EOF на ленту."

#: ./en/ch11.md:436
msgid ""
"\t>      rewind tape-handle \n"
"\t>            Rewinds the tape unit to the beginning of the tape. "
msgstr ""
"\t>      rewind tape-handle \n"
"\t>            Перематывает ленточный блок на начало ленты."

#: ./en/ch11.md:438
msgid "### Defining Tape Streams "
msgstr "### Определение потоков Ленты"

#: ./en/ch11.md:440
msgid "<pre>"
msgstr ""

#: ./en/ch11.md:454
msgid ""
";;;; THE CLASS TAPE-STREAM AND ITS METHODS \n"
"(defclass tape-stream \n"
"    (stream) \n"
"  ((unit :accessor tape-unit \n"
"         :initform 0 \n"
"         :initarg :unit) \n"
"   (tape-handle :initform nil :accessor tape-handle) \n"
"   (tape-record-size :allocation :class \n"
"                     :initform *tape-record-byte-size* \n"
"                     :reader storage-unit-size) \n"
"   (element-buffer :accessor element-buffer) \n"
"   (buffer-index :accessor buffer-index)) \n"
"  (:documentation \"A stream for accessing a tape device.\")) "
msgstr ""

#: ./en/ch11.md:463
msgid ""
"(defmethod initialize-instance :after \n"
"    ((stream tape-stream) skey) \n"
"   (with-accessors ((tape-handle tape-handle) \n"
"                    (unit tape-unit) \n"
"                    (element-buffer element-buffer)) \n"
"       stream \n"
"      (setf tape-handle (open-tape-unit unit)) \n"
"      (setf element-buffer (make-element-array stream))))"
msgstr ""

#: ./en/ch11.md:472
msgid ""
";;; Close the tape unit and clear the tape-handle, \n"
"(defmethod close ((stream tape-stream) skey abort) \n"
"   (declare (ignore abort)) \n"
"   (with-accessors ((tape-handle tape-handle)) \n"
"       stream \n"
"      (when tape-handle \n"
"         (close-tape-unit tape-handle) \n"
"         (setf tape-handle nil))))"
msgstr ""

#: ./en/ch11.md:483
msgid ""
";;;; THE CLASS TAPE-INPUT-STREAM AND ITS METHODS \n"
"(defclass tape-input-stream \n"
"    (tape-stream input-stream) \n"
"  ;; position in buffer of EOF \n"
"  ;; or nil if EOF has not been reached \n"
"  ((eof-offset :initform nil \n"
"               :accessor eof-offset) \n"
"   ;; provide a default value for this inherited slot \n"
"   (buffer-index :initform nil)) \n"
"  (:documentation \"A stream for getting input from a tape device.\"))"
msgstr ""

#: ./en/ch11.md:507
msgid ""
"(defmethod read-next-element ((stream tape-input-stream)) \n"
"   (with-accessors ((element-buffer element-buffer) \n"
"                    (buffer-index buffer-index) \n"
"                    (tape-handle tape-handle) \n"
"                    (eof-offset eof-offset)) \n"
"       stream \n"
"      ;; Make sure the input buffer contains the desired data \n"
"      (unless (and buffer-index \n"
"                   (< buffer-index (length element-buffer))) \n"
"         ;; The current buffer does not contain the desired element. \n"
"         ;; Read the next record, \n"
"         (multiple-value-bind (eof byte-offset) \n"
"             (read-record tape-handle element-buffer \n"
"                          (stream-element-type stream)) \n"
"            (if eof (setf eof-offset \n"
"                          (/ byte-offset (bytes-per-element stream)))) \n"
"            (setf buffer-index 0))) \n"
"      ;; Return nil t if EOF is reached \n"
"      (if (and eof-offset (>= buffer-index eof-offset)) \n"
"          (values nil t) \n"
"          ;; Otherwise return data element and update buffer index \n"
"          (progl (aref element-buffer buffer-index) \n"
"                 (incf buffer-index)))))"
msgstr ""

#: ./en/ch11.md:509
msgid ";;;; THE CLASS TAPE-OUTPUT-STREAM AND ITS METHODS "
msgstr ""

#: ./en/ch11.md:514
msgid ""
"(defclass tape-output-stream \n"
"    (tape-stream output-stream) \n"
"  ((buffer-index :initform 0)) \n"
"  (:documentation \"A stream for writing output to a tape device.\")) "
msgstr ""

#: ./en/ch11.md:528
msgid ""
"(defmethod write-next-element ((stream tape-output-stream) element) \n"
"   (with-accessors ((element-buffer element-buffer) \n"
"                    (buffer-index buffer-index) \n"
"                    (tape-handle tape-handle)) \n"
"       stream \n"
"      (unless (< buffer-index (length element-buffer)) \n"
"         ;; index is past the end of the buffer, so we \n"
"         ;; need to write out the buffer and update index \n"
"         (write-record tape-handle element-buffer \n"
"                       (stream-element-type stream)) \n"
"         (setf buffer-index 0)) \n"
"      (setf (aref element-buffer buffer-index) element) \n"
"      (incf buffer-index)))"
msgstr ""

#: ./en/ch11.md:547
msgid ""
";;; For close :abort, rewind tape immediately and write EOF. \n"
";;; For normal close, write out remaining buffered data (if \n"
";;; necessary) and then write EOF. \n"
"(defmethod close :before ((stream tape-output-stream) \n"
"                          &key abort) \n"
"   (with-accessors ((tape-handle tape-handle)) \n"
"       stream \n"
"      (if abort \n"
"          (rewind tape-handle) \n"
"          ;; No need to write buffer out if there is no buffer-index \n"
"          ;; because that implies that no writing has begun \n"
"          (unless (zerop buffer-index) \n"
"             (write-record tape-handle element-buffer \n"
"                           (stream-element-type stream) \n"
"                           ;; include the size argument \n"
"                           (* buffer-index \n"
"                              (bytes-per-element stream))))) \n"
"      (write-eof-mark tape-handle)))"
msgstr ""

#: ./en/ch11.md:555
msgid ""
";;; Neither force-output-internal nor finish-output-internal \n"
";;; should write an incomplete tape record to the tape device, \n"
";;; because it would then be impossible to continue to do \n"
";;; output at the correct tape position. Therefore the two \n"
";;; methods below don't do anything. \n"
"(defmethod force-output-internal ((stream tape-output-stream)) \n"
"   nil) ;nil is the documented returned value. "
msgstr ""

#: ./en/ch11.md:559
msgid ""
"(defmethod finish-output-internal ((stream tape-output-stream)) \n"
"   nil) ;nil is the documented returned value. \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:562
msgid "### Highlights of Tape Streams "
msgstr "### Основные моменты ленточных потоков"

#: ./en/ch11.md:564
msgid ""
"The purpose of tape streams is to isolate all knowledge of the magnetic tape "
"device. The only part of our program that uses the tape primitives is the "
"tape streams. An equally important aspect of tape streams is that they "
"access the magnetic-tape device for input and or output, without any "
"knowledge of the type of elements being read or written. Tape streams "
"manipulate data without knowing whether the data consist of characters, "
"bytes, or other types of data."
msgstr ""
"Целью ленточных потоков является изоляция всех знаний об устройстве с"
" магнитной лентой. Единственная часть нашей программы, которая использует"
" ленточные примитивы, - это ленточные потоки. Не менее важным аспектом"
" ленточных потоков является то, что они получают доступ к устройству на"
" магнитной ленте для ввода и/или вывода без каких-либо знаний о типе"
" считываемых или записываемых элементов. Ленточные потоки манипулируют"
" данными, не зная, состоят ли данные из символьных знаков(characters), байтов"
" или других типов данных."

#: ./en/ch11.md:566
msgid ""
"This modularity is the keystone of our design. The modularity depends on a "
"strict delineation of responsibility. Tape stream classes are responsible "
"for accessing the magnetic-tape device, and they must rely on the element "
"type stream classes to handle any work that is specific to the element type "
"of the data."
msgstr ""
"Эта модульность является краеугольным камнем нашего проекта. Модульность"
" зависит от строгого разграничения ответственности. Классы потока ленты"
" отвечают за доступ к устройству с магнитной лентой, и они должны полагаться"
" на классы потока с типом элементов для обработки любой работы, специфичной"
" для типов элементов данных."

#: ./en/ch11.md:568
msgid ""
"The primitives in our tape interface do not support set-position. The tape "
"device reads from beginning to end, or writes from beginning to end, and "
"cannot change its notion of current position, other than to rewind all the "
"way to the beginning of the tape. This limitation has two effects on tape "
"streams: "
msgstr ""
"Примитивы в нашем ленточном интерфейсе не поддерживают set-position."
" Ленточное устройство считывает от начала до конца или записывает от начала"
" до конца и не может изменить свое представление о текущем положении, кроме"
" как перемотать полностью до начала ленты. Это ограничение оказывает два"
" эффекта на ленточные потоки:"

#: ./en/ch11.md:571
msgid ""
"*     Tape streams do not supply a method for set-position. If a client "
"tries to set the position of a tape stream, the \"no applicable method\" "
"error is signaled.\n"
"*     Since we cannot set the position, it is not possible to implement "
"force-output-internal or finish-output-internal. If we were to write an "
"incomplete tape record to the tape device, we could no longer continue to do "
"output at the correct tape position. However, even though we cannot "
"implement these generic functions, it is essential that we define methods "
"for them. When called, the methods simply return nil. The existence of these "
"methods enables clients to use force-output and finish-output on all output "
"streams. If the device can force or finish the output it does so; if it "
"cannot, no error is signaled."
msgstr ""
"* Ленточные потоки не предоставляют метод для установки"
" положения(set-position). Если клиент пытается установить положение"
" ленточного потока, выдается сообщение об ошибке \"неприменимый метод\".\n"
"* Поскольку мы не можем установить положение, невозможно реализовать"
" force-output-internal(принудительный вывод-внутренний) или"
" finish-output-internal(конечный вывод-внутренний). Если бы мы записали"
" неполную запись на магнитную ленту на ленточное устройство, мы больше не"
" смогли бы продолжать вывод в правильном положении ленты. Однако, даже если"
" мы не можем реализовать эти обобщенные функции, важно, чтобы мы определили"
" методы для них. При вызове методы просто возвращают nil. Существование этих"
" методов позволяет клиентам использовать force-output(принудительный вывод) и"
" finish-output(конечный вывод) во всех выходных потоках. Если устройство"
" может принудительно выполнить вывод или завершить его, оно делает это; если"
" это не удается, ошибка не сигнализируется."

#: ./en/ch11.md:573
msgid ""
"This behavior is consistent with our defined external protocol. All output "
"streams must support force-output and finish-output, although the actual "
"details of what happens depend on the device. It is part of the contract of "
"these two functions that no error should be signaled, even if the device "
"cannot support the functions. This is unusual; typically, it is appropriate "
"to allow the \"no applicable method\" error to be signaled when the generic "
"function is not implemented for the set of arguments."
msgstr ""
"Такое поведение согласуется с нашим определенным внешним протоколом. Все"
" выходные потоки должны поддерживать force-output(принудительный вывод) и"
" finish-output(завершение вывода), хотя фактические детали того, что"
" происходит, зависят от устройства. Частью контракта этих двух функций"
" является то, что ошибка не должна сигнализироваться, даже если устройство не"
" может поддерживать эти функции. Это необычно; как правило, целесообразно"
" разрешить сигнализацию ошибки \"нет применимого метода\", когда обобщенная"
" функция не реализована для набора аргументов."

#: ./en/ch11.md:575
msgid "## 11.6 DISK STREAMS "
msgstr "## 11.6 ДИСКОВЫЕ ПОТОКИ"

#: ./en/ch11.md:577
msgid ""
"Disk streams need to have direct access to the disk. For the purpose of this "
"example, we assume a simple interface to an imaginary operating system for "
"streams to disk files. In a real implementation, this layer would be the "
"very lowest file-system support."
msgstr ""
"Дисковые потоки должны иметь прямой доступ к диску. Для целей этого примера"
" мы предполагаем простой интерфейс к воображаемой операционной системе для"
" потоков дисковых файлов. В реальной реализации этот уровень был бы самой"
" низкой поддержкой файловой системы."

#: ./en/ch11.md:579
msgid "### Low-Level Disk Interface"
msgstr "### Низкоуровневый Дисковый интерфейс"

#: ./en/ch11.md:582
msgid ""
"We assume a simple operating system that supports random-access files with "
"fixed-size blocks (corresponding to a disk sector). The interface assumes "
"that the file already exists, or else open-disk-file will create it. \n"
"disk-write creates the block if it does not already exist. We assume the "
"following primitives for accessing the disk:"
msgstr ""
"Мы предполагаем простую операционную систему, которая поддерживает файлы"
" произвольного доступа с блоками фиксированного размера(fixed-size)"
" (соответствующими сектору диска). Интерфейс предполагает, что файл уже"
" существует, иначе open-disk-file создаст его.\n"
"disk-write(запись на диск) создает блок, если он еще не существует. Мы"
" предполагаем следующие примитивы для доступа к диску:"

#: ./en/ch11.md:586
msgid ""
"\t   >     open-disk-file file-name-string \n"
"\t   >           Returns a \"file-handle\" for identifying the file and "
"opens the file for random\n"
"\t   >           block-oriented access."
msgstr ""
"\t   >     open-disk-file file-name-string \n"
"\t   >           Возвращает \"дескриптор файла\" для идентификации файла и"
" открывает файл для произвольного\n"
"\t   >           доступа, ориентированного на блок."

#: ./en/ch11.md:589
msgid ""
"\t   >     byte-length file-handle \n"
"\t   >           Returns the length of the file in bytes."
msgstr ""
"\t   >     byte-length file-handle \n"
"\t   >           Возвращает длину файла в байтах."

#: ./en/ch11.md:593
msgid ""
"\t   >    (setf byte-length) n-bytes file-handle \n"
"\t   >           Sets the length of a file in bytes. Called with the setf "
"syntax as follows: \n"
"\t   >             (setf (byte-length file-handle) n-bytes)"
msgstr ""
"\t   >    (setf byte-length) n-bytes file-handle \n"
"\t   >           Задает длину файла в байтах. Вызывается с помощью синтаксиса"
" setf следующим образом:\n"
"\t   >            (setf (byte-length file-handle) n-bytes)"

#: ./en/ch11.md:596
msgid ""
"\t   >     close-disk-file file-handle \n"
"\t   >           Closes the file and deallocates the file-handle."
msgstr ""
"\t   >     close-disk-file file-handle \n"
"\t   >           Закрывает файл и освобождает дескриптор файла."

#: ./en/ch11.md:606
msgid ""
"\t   >     disk-read file-handle array block-number element-type &key (wait "
"t) \n"
"\t   >           Reads the contents of the file's specified block into the "
"array, automatically\n"
"\t   >           converting from the disk's internal data format into the "
"element type. If wait is t,\n"
"\t   >           disk-read does not return until the disk operation "
"finishes. Otherwise, disk-read\n"
"\t   >           returns immediately after requesting the operation, "
"returning an identifier that\n"
"\t   >           can be passed to disk-finished-p to see whether the disk "
"operation is finished.\n"
"\t   >           The contents of the array should not be accessed until the "
"disk operation finishes.\n"
"\t   >           That is, if wait is nil, the array should not be accessed "
"until disk-f inished-p\n"
"\t   >           returns t."
msgstr ""
"\t   >     disk-read file-handle array block-number element-type &key (wait "
"t) \n"
"\t   >           Считывает содержимое указанного блока файла в массив,"
" автоматически преобразуя внутренний\n"
"\t   >           формат данных диска в тип элемента. Если ожидание равно t,"
" disk-read(чтение с диска) не\n"
"\t   >           возвращается до завершения операции с диском. В противном"
" случае disk-read возвращается\n"
"\t   >           сразу после запроса операции, возвращая идентификатор,"
" который может быть передан в \n"
"\t   >           disk-finished-p, чтобы узнать, завершена ли операция с"
" диском. К содержимому массива не\n "
"\t   >           следует обращаться до завершения операции с диском. То есть,"
" если ожидание равно нулю,\n"
"\t   >           доступ к массиву не должен осуществляться до тех пор, пока"
" disk-finished-p не вернет t."

#: ./en/ch11.md:616
msgid ""
"\t   >     disk-write file-handle array block-number element-type &key (wait "
"t) \n"
"\t   >           Writes the contents of the array into the file's specified "
"block, automatically\n"
"\t   >           converting from the element type into the disk's internal "
"data format. If wait is t,\n"
"\t   >           disk-write does not return until the disk operation "
"finishes. Otherwise, disk-write\n"
"\t   >           returns immediately after requesting the operation, "
"returning an identifier that\n"
"\t   >           can be passed to disk-finished-p to see whether the disk "
"operation is finished. \n"
"\t   >           The contents of the array should not be accessed until the "
"disk operation finishes.\n"
"\t   >\t       That is, if wait is nil, the array should not be accessed "
"until disk-finished-p\n"
"\t   >\t       returns t."
msgstr ""
"\t   >     disk-write file-handle array block-number element-type &key (wait "
"t) \n"
"\t   >           Записывает содержимое массива в указанный блок файла,"
" автоматически преобразуя тип \n"
"\t   >           элемента во внутренний формат данных диска. Если ожидание"
" равно t, запись на диск не \n"
"\t   >           возвращается до завершения операции с диском. В противном"
" случае disk-write возвращается\n"
"\t   >           сразу после запроса операции, возвращая идентификатор,"
" который может быть передан в \n"
"\t   >          disk-finished-p, чтобы узнать, завершена ли операция с"
" диском.\n"
"\t   >          К содержимому массива не следует обращаться до завершения"
" операции с диском. То есть, \n"
"\t   >          если ожидание равно нулю, доступ к массиву не должен"
" осуществляться до тех пор, пока \n"
"\t   >          disk-finished-p не вернет t."

#: ./en/ch11.md:620
msgid ""
"\t   >     disk-finished-p identifier \n"
"\t   >           Returns t if the operation is finished. The identifier is "
"the value returned by\n"
"\t   >\t       disk-read or disk-write if wait is nil."
msgstr ""
"\t   >     disk-finished-p identifier \n"
"\t   >            Возвращает t, если операция завершена. Идентификатор - это"
" значение, возвращаемое при \n"
"\t   >            disk-read(чтении с диска) или disk-write(записи на диск),"
" если ожидание равно нулю."

#: ./en/ch11.md:622
msgid ""
"Disk streams are considerably more complicated than tape streams. The disk-"
"write primitive supports a wait keyword, which we will use for "
"distinguishing between force-output and finish-output. Common Lisp specifies "
"that force-output should begin to write the buffered data, but should not "
"wait for the writing to be finished. In contrast, finish-output writes the "
"buffered data and does wait until the writing is finished. This distinction "
"means that disk streams have some asynchronous activities, which requires us "
"to keep in mind those situations for which we need to check whether a disk-"
"write operation is in progress before proceeding."
msgstr ""
"Дисковые Потоки значительно сложнее, чем потоки на магнитной ленте. Примитив"
" disk-write поддерживает ключевое слово wait, которое мы будем использовать"
" для различения force-output и finish-output. Common Lisp указывает, что"
" force-output должен начать запись буферизованных данных, но не должен ждать"
" завершения записи. В отличие от этого, finish-output записывает"
" буферизованные данные и ожидает завершения записи. Это различие означает,"
" что дисковые потоки выполняют некоторые асинхронные действия, что требует от"
" нас помнить о тех ситуациях, для которых нам необходимо проверить,"
" выполняется ли операция disk-write, прежде чем продолжить."

#: ./en/ch11.md:624
msgid "### Defining Disk Streams "
msgstr "### Определение дисковых потоков"

#: ./en/ch11.md:654
msgid ""
"<pre>\n"
";;;; THE DISK-STREAM CLASS \n"
"(defclass disk-stream \n"
"    ;; Disk streams are built on the basic class stream \n"
"    (stream) \n"
"  ;; Handle to file returned by OS \n"
"  ((file-handle :initform nil \n"
"                :accessor file-handle) \n"
"   ;; Name of the file for.the OS \n"
"   (pathname :initarg :pathname \n"
"             :accessor disk-pathname) \n"
"   ;; Size of a disk sector, expressed in 8-bit bytes \n"
"   (disk-sector-size :allocation :class ■ \n"
"                                 :initform *disk-sector-byte-size* \n"
"                                 :reader storage-unit-size) \n"
"   ;; Position of current element within file \n"
"   (element-number :initform 0 \n"
"                   :accessor element-number) \n"
"   ;; Total number of elements in disk file \n"
"   (element-length :accessor element-length) \n"
"   ;; Element buffer, used for I/O \n"
"   (element-buffer :accessor element-buffer) \n"
"   ;; Index into element buffer or NIL if uninitialized \n"
"   (buffer-index :initform nil \n"
"                 :accessor buffer-index) \n"
"   ;; Disk block number of buffer, \n"
"   (block-number :initform 0 \n"
"                 :accessor block-number)) \n"
"  (:documentation \"A stream for accessing a disk file.\"))"
msgstr ""

#: ./en/ch11.md:672
msgid ""
";;; This method does a lot of initialization, and some of \n"
";;; it depends on happening in a certain order. Hence an \n"
";;; initialization method is preferable to initforms, \n"
";;; whose execution order is not defined, \n"
"(defmethod initialize-instance :after \n"
"    ((stream disk-stream) skey) \n"
"   ;; we use with-accessors for convenient access to the slots \n"
"   (with-accessors ((file-handle file-handle) \n"
"                    (element-length element-length) \n"
"                    (pathname disk-pathname) \n"
"                    (element-buffer element-buffer)) \n"
"       stream \n"
"      (setf file-handle (open-disk-file (namestring pathname))) \n"
"      (setf element-buffer (make-element-array stream)) \n"
"      (setf element-length (/ (byte-length file-handle) \n"
"                              (bytes-per-element stream)))))"
msgstr ""

#: ./en/ch11.md:674
msgid "; EXTERNAL PROTOCOL SUPPORTED BY ALL DISK STREAMS "
msgstr ""

#: ./en/ch11.md:712
msgid ""
";; set-position is an extension to COMMON LISP, which \n"
";; we include in the External Interface. It allows \n"
";; greater control when accessing disk streams. \n"
";; This sets the current position to the desired element \n"
";; position. If the element position is beyond the end \n"
";; of the file, eof-error-p and eof-value define whether \n"
";; an error or a value is returned. The element position \n"
";; is the element number in the file, where the first \n"
";; element is number 0, the next is 1, and so on. \n"
"(defgeneric set-position (disk-stream new-position \n"
"                          &optional eof-error-p eof-value) \n"
"   (:method ((stream disk-stream) new-position \n"
"             &optional eof-error-p eof-value) \n"
"      (with-accessors ((element-buffer element-buffer) \n"
"                       (buffer-index buffer-index) \n"
"                       (element-length element-length) \n"
"                       (file-handle file-handle) \n"
"                       (block-number block-number)) \n"
"          stream \n"
"         ;; Don't allow setting position past end of file \n"
"         (if (> new-position element-length) \n"
"             (if eof-error-p \n"
"                 (error \"End of file in ~A\" stream) \n"
"                 eof-value) \n"
"             ;; Here, new-position is OK \n"
"             (multiple-value-bind (block-no offset) \n"
"                 (truncate new-position (length element-buffer)) \n"
"                ;; Unless current buffer is valid \n"
"                (unless (and buffer-index \n"
"                             ;; And contains the same block \n"
"                             (= block-number block-no)) \n"
"                   ;; Have to read in the desired block \n"
"                   (setf block-number block-no) \n"
"                   (disk-read file-handle element-buffer block-number \n"
"                              (stream-element-type stream))) \n"
"                (setf buffer-index offset) \n"
"                (setf element-number new-position))))))"
msgstr ""

#: ./en/ch11.md:723
msgid ""
"(defmethod close ((stream disk-stream) Skey abort) \n"
"   (declare (ignore abort)) \n"
"   (with-accessors ((file-handle file-handle)) \n"
"       stream \n"
"      ;; Checking and clearing the file-handle isn't essential \n"
"      ;; but is good practice in case CLOSE is called multiple \n"
"      ;; times, especially CLOSE then CLOSE :ABORT T \n"
"      (when file-handle \n"
"         (close-disk-file file-handle) \n"
"         (setf file-handle nil))))"
msgstr ""

#: ./en/ch11.md:725
msgid ";;;; THE CLASS DISK-INPUT-STREAM AND ITS METHODS "
msgstr ""

#: ./en/ch11.md:728
msgid ""
"(defclass disk-input-stream (disk-stream input-stream) () \n"
"  (:documentation \"A stream for getting input from a disk.\")) "
msgstr ""

#: ./en/ch11.md:752
msgid ""
"(defmethod read-next-element ((stream disk-input-stream)) \n"
"   (with-accessors ((element-number element-number) \n"
"                    (element-length element-length) \n"
"                    (buffer-index buffer-index) \n"
"                    (element-buffer element-buffer) \n"
"                    (block-number block-number) \n"
"                    (file-handle file-handle)) \n"
"       stream \n"
"      (cond ((< element-number element-length) \n"
"             ;; Make sure the input buffer contains the desired data. \n"
"             (unless (and buffer-index \n"
"                          (< buffer-index (length element-buffer))) \n"
"                ;; Unless at beginning, advance to next block, \n"
"                (if buffer-index (incf block-number)) \n"
"                (disk-read file-handle element-buffer block-number \n"
"                           (stream-element-type stream)) \n"
"                (setf buffer-index 0)) \n"
"             ;; Update pointers and return data element, \n"
"             (incf element-number) \n"
"             (progl (aref element-buffer buffer-index) \n"
"                    (incf buffer-index))) \n"
"            (t ;; At EOF \n"
"             (values nil t)))))"
msgstr ""

#: ./en/ch11.md:762
msgid ""
";;;; THE CLASS DISK-OUTPUT-STREAM AND ITS METHODS \n"
"(defclass disk-output-stream \n"
"    (disk-stream output-stream) \n"
"  ;; disk-id is used to store the identifier returned \n"
"  ;; by disk-write, which we will use to find out if \n"
"  ;; the disk-write is still in progress, \n"
"  ((disk-id :initform nil \n"
"            :accessor disk-id)) \n"
"  (:documentation \"A stream for writing output to a disk.\"))"
msgstr ""

#: ./en/ch11.md:773
msgid ""
";;; This comes in useful when we need to ensure that \n"
";;; there is no disk-write currently in progress, \n"
"(defmethod wait-for-disk ((stream disk-output-stream)) \n"
"   (with-accessors ((disk-id disk-id)) \n"
"       stream \n"
"      (unless (null disk-id) \n"
"         ;; process-wait is not part of COMMON LISP, but we \n"
"         ;; defined it earlier, in \"Locks and Processes\" \n"
"         (process-wait \"Disk wait\" #'disk-finished-p disk-id) \n"
"         (setf disk-id nil))))"
msgstr ""

#: ./en/ch11.md:809
msgid ""
"(defmethod write-next-element \n"
"    ((stream disk-output-stream) element) \n"
"   (with-accessors ((element-buffer element-buffer) \n"
"                    (buffer-index buffer-index) \n"
"                    (block-number block-number) \n"
"                    (element-number element-number) \n"
"                    (element-length element-length) \n"
"                    (file-handle file-handle)) \n"
"       stream \n"
"      ;; Ensure that no disk write is happening, \n"
"      (wait-for-disk stream) \n"
"      (unless (and buffer-index (< buffer-index \n"
"                                   (length element-buffer))) \n"
"         ;; Current buffer does not contain the desired element, \n"
"         (when buffer-index \n"
"            ;; Write out the old buffer and update the pointers, \n"
"            (disk-write file-handle element-buffer block-number \n"
"                        (stream-element-type stream)) \n"
"            (incf block-number)) \n"
"         ;; Need to read in next block in case we are \n"
"         ;; overwriting an existing file, \n"
"         (when (< element-number element-length) \n"
"            (disk-read file-handle element-buffer block-number \n"
"                       (stream-element-type stream))) \n"
"         (setf buffer-index 0)) \n"
"      (setf (aref element-buffer buffer-index) element) \n"
"      (incf buffer-index) \n"
"      (incf element-number) \n"
"      ;; Update the EOF pointer as well, but defer the actual \n"
"      ;; setting of the EOF pointer on the disk until CLOSE (or \n"
"      ;; FINISH-OUTPUT) time to reduce overhead. FINISH-OUTPUT \n"
"      ;; should be called anyway when dealing with files which \n"
"      ;; are being read by other processes, \n"
"      (when (>» element-number element-length) \n"
"      (setf element-length element-number))))"
msgstr ""

#: ./en/ch11.md:832
msgid ""
";;; The methods for force-output-internal and finish-output-internal \n"
";;; check whether a force-output-internal is already in progress. \n"
";;; If so, they don't do an additional, unnecessary disk-write. \n"
"(defmethod force-output-internal ((stream disk-output-stream)) \n"
"   (with-accessors ((buffer-index buffer-index) \n"
"                    (file-handle file-handle) \n"
"                    (element-buffer element-buffer) \n"
"                    (disk-id disk-id) \n"
"                    (block-number block-number)) \n"
"       stream \n"
"      (unless disk-id \n"
"         ;; A force-output-internal is not already in \n"
"         ;; progress, so we start one. \n"
"         (when buffer-index \n"
"            ;; The current buffer contents are valid. Write them \n"
"            ;; out. Don't change any of the pointers in case \n"
"            ;; output is simply continued. \n"
"            (setf disk-id (disk-write file-handle element-buffer \n"
"                                      block-number \n"
"                                      (stream-element-type stream) \n"
"                                      :wait nil))))) \n"
"   nil) ;; nil is the documented returned value."
msgstr ""

#: ./en/ch11.md:853
msgid ""
"(defmethod finish-output-internal ((stream disk-output-stream)) \n"
"   (with-accessors ((file-handle file-handle) \n"
"                    (buffer-index buffer-index) \n"
"                    (element-length element-length) \n"
"                    (disk-id disk-id)) \n"
"       stream \n"
"      ;; Don't do anything if buffer is invalid \n"
"      (when buffer-index \n"
"         (unless disk-id \n"
"            ;; A force-output-internal is not already in \n"
"            ;; progress, so we start one. \n"
"            (force-output-internal stream)) \n"
"         ;; Also, update the EOF pointer on the disk. It's OK \n"
"         ;; if the operating system causes this to hang until \n"
"         ;; the disk is updated. Note: this could be optimized \n"
"         ;; to do this only if the value has changed, \n"
"         (setf (byte-length file-handle) \n"
"               (* element-length (bytes-per-element stream))) \n"
"         ;; And then wait for it to finish, \n"
"         (wait-for-disk stream))))"
msgstr ""

#: ./en/ch11.md:865
msgid ""
"(defmethod set-position :before ((stream disk-output-stream) \n"
"                                 new-position \n"
"                                 &optional eof-error-p eof-value) \n"
"   (declare (ignore new-position eof-error-p eof-value)) \n"
"   ;; Before a new disk block can be read in containing the \n"
"   ;; new position, we have to write out the old block if it \n"
"   ;; has been modified. Note: this could be improved by \n"
"   ;; seeing whether the new-position argument is still in \n"
"   ;; the same buffer, and not doing finish-output-internal \n"
"   ;; in that case, \n"
"   (finish-output-internal stream)) "
msgstr ""

#: ./en/ch11.md:868
msgid ""
";; This needs to be done before the primary methods are \n"
";; called, to prepare the file to be closed by first sending "
msgstr ""

#: ./en/ch11.md:874
msgid ""
";;; out any buffered output. \n"
"(defmethod close :before ((stream disk-output-stream) \n"
"                          &key abort) \n"
"   (unless abort \n"
"      (finish-output-internal stream)))"
msgstr ""

#: ./en/ch11.md:880
msgid ""
";;;; THE CLASS DISK-BIDIRECTIONAL-STREAM \n"
"(defclass disk-bidirectional-stream \n"
"    (disk-input-stream disk-output-stream bidirectional-stream) \n"
"  () \n"
"  (:documentation \"A combined input and output disk stream.\")) "
msgstr ""

#: ./en/ch11.md:887
msgid ""
";;; Bidirectional streams do both reading and writing. \n"
";;; Before reading, ensure that no disk-write is happening. \n"
"(defmethod read-next-element :before \n"
"           ((stream disk-bidirectional-stream)) \n"
"   (wait-for-disk stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:889
msgid "### Highlights of Disk Streams "
msgstr "### Основные моменты дисковых потоков"

#: ./en/ch11.md:891
msgid ""
"Disk streams are analogous to tape streams, in that they isolate all "
"knowledge of the disk device. The disk streams are responsible for handling "
"all work related to the disk, and they must do their job without depending "
"on knowledge of the element type of the data."
msgstr ""
"Дисковые потоки аналогичны ленточным потокам в том смысле, что они изолируют"
" все сведения о дисковом устройстве. Дисковые потоки отвечают за обработку"
" всей работы, связанной с диском, и они должны выполнять свою работу, не"
" завися от знания типов элементов данных."

#: ./en/ch11.md:893
msgid ""
"However, the disk streams do need to provide the element type of the stream "
"as an argument to disk-read and disk-write. To do so, the disk stream "
"methods call the stream-element-type generic function. Each element type "
"stream provides a method for stream-element-type. Thus, when disk stream "
"methods need information about the element type, they use the documented "
"internal protocol and rely on the element type classes handling the element "
"type aspects of streams."
msgstr ""
"Однако дисковые потоки должны предоставлять тип элементов потока в качестве"
" аргумента для disk-read и disk-write. Для этого методы дискового потока"
" вызывают обобщенную функцию stream-element-type. Каждый тип элемента потока"
" предоставляет метод для stream-element-type. Таким образом, когда методам"
" дискового потока требуется информация о типе элемента, они используют"
" документированный внутренний протокол и полагаются на классы типов"
" элементов, обрабатывающие аспекты типов элементов потоков."

#: ./en/ch11.md:895
msgid ""
"It is also worth noting that disk streams introduce one new function into "
"the external protocol: set-position. Since the disk primitives support "
"reading and writing random blocks, it is useful to bring that capability "
"directly to the users of our stream program. Disk streams support set-"
"position because to do so makes sense for a disk device; however, there is "
"no requirement that all device streams must support set-position."
msgstr ""
"Также стоит отметить, что дисковые потоки вводят одну новую функцию во"
" внешний протокол: set-position. Поскольку дисковые примитивы поддерживают"
" чтение и запись произвольных блоков, полезно предоставить эту возможность"
" непосредственно пользователям нашей потоковой программы. Дисковые потоки"
" поддерживают set-position, поскольку это имеет смысл для дискового"
" устройства; однако нет требования, чтобы все потоки устройств поддерживали"
" set-position(задание положения)."

#: ./en/ch11.md:897
msgid ""
"Disk streams are more complex than tape streams because of the asynchronous "
"behavior of disk writing (supported by the :wait keyword to disk-write) and "
"the set-position capability. It is valuable to identify the places in the "
"code where we use wait-for-disk, because that gives us a framework for "
"discussing the modularity of disk streams. The general guideline is that we "
"must wait for the disk to finish writing before we modify the buffer of "
"data. The buffer is modified by both disk-read and functions that write "
"elements to the array."
msgstr ""
"Дисковые потоки более сложны, чем ленточные потоки, из-за асинхронного"
" поведения записи на диск (поддерживается ключевым словом :wait для"
" disk-write) и возможности set-position(установки положения). Важно"
" определить места в коде, где мы используем wait-for-disk(ожидание диска),"
" потому что это дает нам основу(framework) для обсуждения модульности"
" дисковых потоков. Общее правило заключается в том, что мы должны дождаться"
" завершения записи на диск, прежде чем изменять буфер данных. Буфер"
" изменяется как с помощью disk-read(чтения с диска), так и с помощью функций,"
" которые записывают элементы в массив."

#: ./en/ch11.md:903
msgid ""
"*  wait-for-disk is implemented by a method on disk-output-stream and by the "
"slot disk-id, which is a slot of disk-output-stream. It is correct to "
"associate the wait-for-disk behavior with disk output streams, because disk "
"writing takes place in disk output streams only.\n"
"*  An input-only disk stream would have no need to call disk-write, which "
"means that an input-only stream never has to wait for the disk. No methods "
"for disk-input-stream call wait-for-disk. \n"
"*  In general, an output-only disk stream needs to wait for the disk before "
"modifying the buffer. This happens in the method for write-next-element. \n"
"*  The primary method for set-position is attached to the class disk-stream. "
"This method calls disk-read without waiting for the disk because for input-"
"only streams waiting is unnecessary and, in fact, is unsupported. However, "
"output streams must wait for the disk before calling disk-read. We implement "
"this waiting by providing a before-method for set-position for the class "
"disk-output-stream. This method calls finish-output, which in turn calls "
"write-next-element, which waits for the disk if necessary. \n"
"*  A bidirectional disk stream needs to wait for the disk before calling "
"disk-read or disk-write. Bidirectional streams inherit the waiting behavior "
"already implemented by output streams, but there is no waiting behavior in "
"input streams (because waiting is unnecessary for input-only streams). "
"Therefore, we support the waiting behavior in a before-method for read-next-"
"element for the class disk-bidirectional-stream."
msgstr ""
"* wait-for-disk(ожидание диска) реализуется методом в disk-output-stream и"
" слотом disk-id, который является слотом disk-output-stream. Правильно"
" связывать поведение wait-for-disk с потоками вывода на диск, поскольку"
" запись на диск происходит только в потоках вывода на диск.\n"
"* Дисковому потоку, предназначенному только для ввода, не нужно было бы"
" вызывать disk-write, что означает, что потоку, предназначенному только для"
" ввода, никогда не нужно ждать диск. Нет методов для disk-input-stream"
" вызывающих wait-for-disk.\n"
"* Как правило, дисковый поток, предназначенный только для вывода, должен"
" дождаться диска, прежде чем изменять буфер. Это происходит в методе для"
" write-next-element.\n"
"* Основной метод для set-position привязан к классу disk-stream. Этот метод"
" вызывает disk-read без ожидания диска, потому что для потоков только для"
" ввода ожидание не требуется и, по сути, не поддерживается. Однако выходные"
" потоки должны дождаться диска, прежде чем вызывать disk-read. Мы реализуем"
" это ожидание, предоставляя метод before для set-position для класса"
" disk-output-stream. Этот метод вызывает finish-output, который, в свою"
" очередь, вызывает write-next-element, который при необходимости ожидает"
" диск.\n"
"* Двунаправленный дисковый поток должен дождаться диска перед вызовом функции"
" disk-read(чтения с диска) или disk-write(записи с диска). Двунаправленные"
" потоки наследуют поведение ожидания, уже реализованное выходными потоками,"
" но во входных потоках нет поведения ожидания (поскольку ожидание не"
" требуется для потоков только для ввода). Поэтому мы поддерживаем поведение"
" ожидания в методе before для read-next-element(чтения следующего элемента)"
" для класса disk-bidirectional-stream."

#: ./en/ch11.md:905
msgid "## 11.7 CHARACTER STREAMS"
msgstr "## 11.7 ПОТОКИ СИМВОЛЬНЫХ ЗНАКОВ(CHARACTER)"

#: ./en/ch11.md:907
msgid ""
"Here we define our first element type streams; character streams do anything "
"that is needed to handle the character element type. These streams are "
"considerably simpler than the device type streams. "
msgstr ""
"Здесь мы определяем наши потоки для первого типа элемента; потоки символьных"
" знаков выполняют все, что необходимо для обработки элментов типа символьных"
" знаков. Эти потоки значительно проще, чем потоки типа устройств."

#: ./en/ch11.md:909
msgid "### Defining Character Streams "
msgstr "### Определение потоков символьных знаков"

#: ./en/ch11.md:921
msgid ""
"<pre>\n"
";;;; THE CLASS CHARACTER-STREAM \n"
"(defclass character-stream \n"
"    (stream) \n"
"  ((bytes-per-element :allocation :class \n"
"\t\t      :initform 1 \n"
"\t\t      :reader bytes-per-element) \n"
"   (element-type :allocation :class \n"
"\t\t :initform 'character \n"
"\t\t :reader stream-element-type)) \n"
"  (:documentation \"A stream for transmitting characters.\"))"
msgstr ""

#: ./en/ch11.md:923
msgid ";;;;;; EXTERNAL PROTOCOL SUPPORTED BY CHARACTER STREAMS "
msgstr ""

#: ./en/ch11.md:938
msgid ""
";; Because COMMON LISP specifies that the stream argument to \n"
";; read-char and write-char is optional, we implement \n"
";; these operations as ordinary functions. The \"generic\" \n"
";; aspect of read-char and write-char lies within the bodies \n"
";; of the functions, where they call the generic functions \n"
";; read-next-element and write-next-element. \n"
";; Standardize stream variable if t or nil was given. \n"
";; This is done for input streams on characters, but \n"
";; not on bytes, since the byte-stream operations do \n"
";; not default the stream argument; it is required, \n"
"(defmacro standardize-char-input-stream-var (stream) \n"
"  `(setf ,stream (cond ((eq ,stream t) *terminal-io*) \n"
"\t\t       ((null ,stream) *standard-input*) \n"
"\t\t       (t ,stream))))"
msgstr ""

#: ./en/ch11.md:954
msgid ""
";;; Page 379 in Common LISP: The Language \n"
"(defun read-char (&optional (input-stream *standard-input*) \n"
"\t\t    eof-error-p eof-value recursive-p) \n"
"  (standardize-char-input-stream-var input-stream) \n"
"  (multiple-value-bind (element eof-p) \n"
"      (read-next-element input-stream) \n"
"    (cond (eof-p \n"
"\t   (if eof-error-p \n"
"\t       (if recursive-p \n"
"\t\t   (error \"End of file while reading from ~A\" \n"
"\t\t\t  input-stream) \n"
"\t\t   (error \"End of file in ~A\" input-stream)) \n"
"\t       eof-value)) \n"
"\t  (t \n"
"\t   element))))"
msgstr ""

#: ./en/ch11.md:960
msgid ""
";;; Page 384 in Common LISP: The Language \n"
"(defun write-char (character \n"
"\t\t   &optional (output-stream *standard-output*)) \n"
"  (standardize-output-stream-var output-stream) \n"
"  (write-next-element output-stream character))"
msgstr ""

#: ./en/ch11.md:966
msgid ""
";;;; THE DIRECTIONAL CHARACTER-STREAM CLASSES \n"
"(defclass character-input-stream \n"
"    (character-stream input-stream) \n"
"  () \n"
"  (:documentation \"A stream for getting character input.\")) "
msgstr ""

#: ./en/ch11.md:971
msgid ""
"(defclass character-output-stream \n"
"    (character-stream output-stream) \n"
"  () \n"
"  (:documentation \"A stream for writing character output.\")) "
msgstr ""

#: ./en/ch11.md:979
msgid ""
"(defclass character-bidirectional-stream \n"
"    (character-input-stream \n"
"     character-output-stream \n"
"     bidirectional-stream) \n"
"  () \n"
"  (:documentation \"A combined input and output character stream.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:981
msgid "### Highlights of Character Streams "
msgstr "### Основные моменты потоков символьных знаков"

#: ./en/ch11.md:983
msgid ""
"Character streams handle the character element type. The generic functions "
"bytes-per-element and stream-element-type store information about the "
"structure of character elements. Since both of these are constants, we chose "
"to store them in class slots that have reader methods. Alternatively, we "
"could have stored the information in defmethod forms, where the methods "
"simply returned the constants."
msgstr ""
"Потоки символьных данных обрабатывают элементы типа символьных"
" знаков(character). Обобщенные функции bytes-per-element и"
" stream-element-type хранят информацию о структуре элементов символьных"
" знаков. Поскольку оба они являются константами, мы решили сохранить их в"
" слотах классов, которые имеют методы чтения. В качестве альтернативы мы"
" могли бы сохранить информацию в формах defmethod, где методы просто"
" возвращали константы."

#: ./en/ch11.md:985
msgid ""
"The character-stream class assumes each character fits in a single byte. "
"Some implementations support characters that require more than one byte of "
"storage. Our model could be extended to include classes built on character-"
"stream; such classes could provide a class slot named bytes-per-element to "
"override the class slot defined by the character-stream class."
msgstr ""
"Класс character-stream предполагает, что каждый символьный знак помещается в"
" один байт. Некоторые реализации поддерживают символьные знаки, для которых"
" требуется более одного байта памяти. Наша модель может быть расширена, чтобы"
" включить классы, построенные на потоке символьных знаков; такие классы могли"
" бы предоставлять слот класса с именем bytes-per-element для переопределения"
" слота класса, определенного классом character-stream."

#: ./en/ch11.md:987
msgid ""
"Common Lisp specifies that character streams support the functions read-char "
"and write-char. (Common Lisp also specifies several other functions that "
"manipulate character streams, but this example does not implement all of "
"them.) The real benefits of our stream foundation become clear here: It is "
"very easy to define read-char and write-char in terms of read-next-element "
"and write-next-element. As we shall demonstrate in byte streams, it is "
"equally easy to implement the byte input and output functions using the same "
"foundation."
msgstr ""
"Common Lisp указывает, что потоки символьных знаков поддерживают функции"
" read-char и write-char. (Common Lisp также определяет несколько других"
" функций, которые управляют потоками символьных знаков, но в этом примере"
" реализованы не все из них.) Реальные преимущества нашей основы"
" потоков(stream foundation) становятся очевидными здесь: очень легко"
" определить read-char и write-char в терминах read-next-element и"
" write-next-element. Как мы продемонстрируем в byte streams(потоках байтов),"
" одинаково легко реализовать функции ввода и вывода байтов, используя одну и"
" ту же основу."

#: ./en/ch11.md:989
msgid ""
"We define character-input-stream, character-output-stream, and character-"
"bidirectional-stream to fill out the type organization. None of those "
"classes supplies methods or slots of its own. By defining these classes, "
"however, we enable clients to use typep to determine whether an object is of "
"one of these stream types."
msgstr ""
"Мы определяем character-input-stream, character-output-stream и"
" character-bidirectional-stream, чтобы заполнить организацию типов. Ни один"
" из этих классов не предоставляет собственных методов или слотов. Однако,"
" определяя эти классы, мы даем возможность клиентам использовать typep для"
" определения того, относится ли объект к одному из этих типов потоков."

#: ./en/ch11.md:991
msgid "## 11.8 BYTE STREAMS"
msgstr "## 11.8 БАЙТОВЫЕ ПОТОКИ"

#: ./en/ch11.md:993
msgid ""
"Here we define several kinds of byte streams, each intended to handle bytes "
"of various sizes."
msgstr ""
"Здесь мы определяем несколько видов потоков байтов, каждый из которых"
" предназначен для обработки байтов различного размера."

#: ./en/ch11.md:995
msgid "## Defining Byte Streams"
msgstr "## Определение потоков байтов"

#: ./en/ch11.md:1000
msgid ""
"<pre>\n"
";;;; THE BYTE-STREAM CLASSES \n"
"(defclass byte-stream (stream) () \n"
"  (:documentation \"A stream for transmitting bytes of data.\")) "
msgstr ""

#: ./en/ch11.md:1010
msgid ""
"(defclass 8-bit-byte-stream \n"
"    (byte-stream) \n"
"  ((bytes-per-element :allocation :class \n"
"\t\t      :initform 1 \n"
"\t\t      :reader bytes-per-element) \n"
"   (element-type :allocation :class \n"
"\t\t :initform '(unsigned-byte 8) \n"
"\t\t :reader stream-element-type)) \n"
"  (:documentation \"A stream for transmitting 8-bit bytes of data.\")) "
msgstr ""

#: ./en/ch11.md:1020
msgid ""
"(defclass 32-bit-word-stream \n"
"    (byte-stream) \n"
"  ((bytes-per-element :allocation :class \n"
"\t\t      :initform 4 \n"
"\t\t      :reader bytes-per-element) \n"
"   (element-type :allocation :class \n"
"\t\t :initform '(signed-byte 32) \n"
"\t\t :reader stream-element-type)) \n"
"  (:documentation \"A stream for transmitting 32-bit words of data.\"))"
msgstr ""

#: ./en/ch11.md:1023
msgid ""
";;;; THE CLASS BYTE-INPUT-STREAM AND A METHOD \n"
"(defclass byte-input-stream (byte-stream input-stream) ()) "
msgstr ""

#: ./en/ch11.md:1037
msgid ""
";;; Page 382 in Common LISP: The Language \n"
"(defgeneric read-byte (byte-input-stream \n"
"\t\t       &optional eof-error-p eof-value) \n"
"  (:method ((stream byte-input-stream) \n"
"\t    &optional eof-error-p eof-value) \n"
"    (multiple-value-bind (element eof-p) \n"
"\t(read-next-element stream) \n"
"      (cond (eof-p \n"
"\t     (if eof-error-p \n"
"\t\t (error \"End of file while reading from ~A\" stream) \n"
"\t\t eof-value)) \n"
"\t    (t \n"
"\t     element)))))"
msgstr ""

#: ./en/ch11.md:1040
msgid ""
";;;; THE CLASS BYTE-OUTPUT-STREAM AND A METHOD \n"
"(defclass byte-output-stream (byte-stream output-stream) ()) "
msgstr ""

#: ./en/ch11.md:1045
msgid ""
";;; Page 385 in Common LISP: The Language \n"
"(defgeneric write-byte (output-stream byte) \n"
"  (:method ((stream byte-output-stream) byte) \n"
"    (write-next-element stream byte)))"
msgstr ""

#: ./en/ch11.md:1050
msgid ""
";;;; THE OTHER BYTE-STREAM CLASSES \n"
"(defclass 8-bit-byte-input-stream \n"
"    (8-bit-byte-stream byte-input-stream) \n"
"  ()) "
msgstr ""

#: ./en/ch11.md:1054
msgid ""
"(defclass 8-bit-byte-output-stream \n"
"    (8-bit-byte-stream byte-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1060
msgid ""
"(defclass 8-bit-byte-bidirectional-stream \n"
"    (8-bit-byte-input-stream \n"
"     8-bit-byte-output-stream \n"
"     bidirectional-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1064
msgid ""
"(defclass 32-bit-word-input-stream \n"
"    (32-bit-word-stream byte-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1068
msgid ""
"(defclass 32-bit-word-output-stream \n"
"    (32-bit-word-stream byte-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1075
msgid ""
"(defclass 32-bit-word-bidirectional-stream \n"
"    (32-bit-word-input-stream \n"
"     32-bit-word-output-stream \n"
"     bidirectional-stream) \n"
"  ()) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:1077
msgid "### Highlights of Byte Streams"
msgstr "### Основные моменты потоков байтов"

#: ./en/ch11.md:1079
msgid ""
"Byte streams exhibit another good use of modularity. We have divided byte "
"streams into two pieces: one piece supporting the directional aspect, the "
"other piece supporting the structural aspect (the structure of the element "
"type)."
msgstr ""
"Потоки байтов демонстрируют еще одно хорошее применение модульности. Мы"
" разделили потоки байтов на две части: одна часть поддерживает аспект"
" направления, другая часть поддерживает структурный аспект (структура типа"
" элементов)."

#: ./en/ch11.md:1081
msgid ""
"The directional aspect of byte streams includes the Common Lisp functions "
"read-byte and write-byte; that is, a byte input stream supports read-byte, "
"whereas a byte output stream supports write-byte. The classes byte-input-"
"stream and byte-output-stream support those functions with methods that call "
"read-next-element and write-next-element.Thus, these two classes handle the "
"directional aspect of byte streams."
msgstr ""
"Аспект направленности потоков байтов включает в себя функции Common Lisp"
" read-byte и write-byte; то есть поток ввода байта поддерживает"
" read-byte(чтение байта), тогда как поток вывода байтов поддерживает (запись"
" байта). Классы byte-input-stream и byte-output-stream поддерживают эти"
" функции с помощью методов, которые вызывают read-next-element и"
" write-next-element.Таким образом, эти два класса обрабатывают аспект"
" направления потоков байтов."

#: ./en/ch11.md:1083
msgid ""
"The structural aspect of byte streams includes bytes-per-element and stream-"
"element-type, which describe the structure of the element type. The classes 8"
"-bit-byte-stream and 32-bit-word-stream support those generic functions with "
"methods (reader methods that access the class slots where the information is "
"stored). Thus, these two classes handle the structural aspect of byte "
"streams. "
msgstr ""
"Структурный аспект потоков байтов включает в себя bytes-per-element(байты на"
" элемент) и stream-element-type(тип элемента потока), которые описывают"
" структуру типа элемента. Классы 8-bit-byte-stream и 32-bit-word-stream"
" поддерживают эти обобщенные функции с методами (методы чтения, которые"
" обращаются к слотам класса, где хранится информация). Таким образом, эти два"
" класса обрабатывают структурный аспект потоков байтов."

#: ./en/ch11.md:1085
msgid ""
"We then define classes that are built on both a \"directional aspect of the "
"element type\" stream and a \"structural aspect of the element type\" stream "
"class. For example, the class 8-bit-byte-input-stream inherits from byte-"
"input-stream and 8-bit-byte-stream."
msgstr ""
"Затем мы определяем классы, которые построены как на потоке \"аспект"
" направления и типа элемента\", так и на потоковом классе \"структурный"
" аспект типа элемента\". Например, класс 8-bit-byte-input-stream наследуется"
" от byte-input-stream и 8-bit-byte-stream."

#: ./en/ch11.md:1087
msgid "## 11.9 INSTANTIABLE STREAMS"
msgstr "## 11.9 СОЗДАВАЕМЫЕ ПОТОКИ"

#: ./en/ch11.md:1089
msgid ""
"A usable stream needs three components: a directional class, a device class, "
"and an element type class. We do not expect users to create an instance of "
"any of the stream classes defined so far, because all these stream classes "
"are incomplete. We now define the complete, usable streams, which we might "
"call the \"instantiable\" streams. \"Instantiable\" indicates that we do "
"expect clients to create instances of these streams."
msgstr ""
"Для использования потока необходимы три компонента: класс направления, класс"
" устройства и класс типа элемента. Мы не ожидаем, что пользователи создадут"
" экземпляр какого-либо из классов stream, определенных до сих пор, поскольку"
" все эти классы stream являются неполными. Теперь мы определяем полные,"
" пригодные для использования потоки, которые мы могли бы назвать"
" \"instantiable/создаваемыми\" потоками. \"Instantiable/Создаваемый\""
" указывает на то, что мы ожидаем, что клиенты будут создавать экземпляры этих"
" потоков."

#: ./en/ch11.md:1091
msgid "### Defining the Instantiable Streams"
msgstr "### Определение создаваемых потоков"

#: ./en/ch11.md:1099
msgid ""
"<pre>\n"
";;;; An instantiable stream needs three components, indicating \n"
";;;; the element type, the direction, and the device type. \n"
";;;; INSTANTIABLE CHARACTER DISK STREAMS \n"
"(defclass character-disk-input-stream \n"
"    (character-input-stream disk-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1103
msgid ""
"(defclass character-disk-output-stream \n"
"    (character-output-stream disk-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1107
msgid ""
"(defclass character-disk-bidirectional-stream \n"
"    (character-bidirectional-stream disk-bidirectional-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1112
msgid ""
";;;; INSTANTIABLE CHARACTER TAPE STREAMS \n"
"(defclass character-tape-input-stream \n"
"    (character-input-stream tape-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1116
msgid ""
"(defclass character-tape-output-stream \n"
"    (character-output-stream tape-output-stream) \n"
"  ()) "
msgstr ""

#: ./en/ch11.md:1121
msgid ""
";;;; INSTANTIABLE 8-BIT-BYTE DISK STREAMS \n"
"(defclass 8-bit-byte-disk-input-stream \n"
"    (8-bit-byte-input-stream disk-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1125
msgid ""
"(defclass 8-bit-byte-disk-output-stream \n"
"    (8-bit-byte-output-stream disk-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1130
msgid ""
"(defclass 8-bit-byte-disk-bidirectional-stream \n"
"    (8-bit-byte-bidirectional-stream \n"
"     disk-bidirectional-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1135
msgid ""
";;;; INSTANTIABLE 8-BIT-BYTE TAPE STREAMS \n"
"(defclass 8-bit-byte-tape-input-stream \n"
"    (8-bit-byte-input-stream tape-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1139
msgid ""
"(defclass 8-bit-byte-tape-output-stream \n"
"    (8-bit-byte-output-stream tape-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1144
msgid ""
";;;; INSTANTIABLE 32-BIT-WORD DISK STREAMS \n"
"(defclass 32-bit-word-disk-input-stream \n"
"    (32-bit-word-input-stream disk-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1148
msgid ""
"(defclass 32-bit-word-disk-output-stream \n"
"    (32-bit-word-output-stream disk-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1153
msgid ""
"(defclass 32-bit-word-disk-bidirectional-stream \n"
"    (32-bit-word-bidirectional-stream \n"
"     disk-bidirectional-stream) \n"
"  ()) "
msgstr ""

#: ./en/ch11.md:1158
msgid ""
";;;; INSTANTIABLE 32-BIT-WORD TAPE STREAMS \n"
"(defclass 32-bit-word-tape-input-stream \n"
"    (32-bit-word-input-stream tape-input-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1162
msgid ""
"(defclass 32-bit-word-tape-output-stream \n"
"    (32-bit-word-output-stream tape-output-stream) \n"
"  ())"
msgstr ""

#: ./en/ch11.md:1164
msgid "</pre>"
msgstr ""

#: ./en/ch11.md:1166
msgid "## 11.10 A PROCEDURAL DEFINITION FOR CREATING STREAMS"
msgstr "## 11.10 ПРОЦЕДУРНОЕ ОПРЕДЕЛЕНИЕ ДЛЯ СОЗДАНИЯ ПОТОКОВ"

#: ./en/ch11.md:1168
msgid ""
"At this point, we have finished the foundation of streams, and have "
"implemented several of the familiar Common Lisp stream functions. However, "
"we have ignored the question of how streams are created in the first place. "
"We need to define an interface for creating streams. Since one of our goals "
"was to make streams easily extensible, we should design this interface as an "
"extensible protocol and document it; this protocol enables programmers to "
"hook a new stream class into the existing mechanism and make the new class "
"generally available."
msgstr ""
"На данный момент мы завершили написание основания потоков и реализовали"
" несколько знакомых потоковых функций Common Lisp. Однако мы проигнорировали"
" вопрос о том, как создаются потоки в первую очередь. Нам нужно определить"
" интерфейс для создания потоков. Поскольку одной из наших целей было сделать"
" потоки легко расширяемыми, мы должны спроектировать этот интерфейс как"
" расширяемый протокол и задокументировать его; этот протокол позволяет"
" программистам подключать новый класс потока(stream) к существующему"
" механизму и делать новый класс общедоступным."

#: ./en/ch11.md:1170
msgid "### Designing a Protocol for Creating Streams"
msgstr "### Разработка протокола для создания потоков"

#: ./en/ch11.md:1172
msgid ""
"The interface for creating streams will be used by open and other functions "
"that need to create streams. The bulk of the work of creating a stream is "
"done by make-stream, which we document as follows:"
msgstr ""
"Интерфейс для создания потоков будет использоваться open и другими функциями,"
" которые необходимы для создания потоков. Основная часть работы по созданию"
" потока выполняется make-stream, который мы документируем следующим образом:"

#: ./en/ch11.md:1181
msgid ""
"\t      >  make-stream device-type direction element-type name\n"
"\t      >                   Returns an opened stream of the correct type for "
"the arguments. Calls\n"
"\t      >                   select-stream-class to choose the class. Calls "
"make-device-stream to\n"
"\t      >                   choose the correct arguments to make-instance "
"and to create the instance\n"
"\t      >                   itself, device-type is a symbol, such as tape or "
"disk, direction is the\n"
"\t      >                   symbol input or output or bidirectional, element-"
"type is a type specifier,\n"
"\t      >                   name is a string: for a disk device it names a "
"pathname; for a tape\n"
"\t      >                   device, it names a unit number."
msgstr ""
"\t      >  make-stream device-type direction element-type name\n"
"\t      >             Возвращает открытый поток правильного типа для"
" аргументов. Вызывает select-stream-class,\n"
"\t      >             чтобы выбрать класс. Вызывает make-device-stream, чтобы"
" выбрать правильные аргументы\n"
"\t      >             для make-instance и создать сам экземпляр, тип"
" устройства - это символ, такой как лента \n"
"\t      >             или диск, направление - это символ ввода или вывода или"
" двунаправленный, тип элемента\n"
"\t      >             - это спецификатор типа, имя - строка: для дисковому"
" устройству присваивается имя пути;\n"
"\t      >             для ленточного устройства присваивается номер"
" устройства."

#: ./en/ch11.md:1183
msgid ""
"Since we document two functions that make-stream calls, we are designing a "
"procedural definition for make-stream. We might envision the definition of "
"make-stream as the following: "
msgstr ""
"Поскольку мы документируем две функции, которые вызывают make-stream, мы"
" разрабатываем процедурное определение для make-stream. Мы могли бы"
" представить себе определение make-stream следующим образом:"

#: ./en/ch11.md:1195
msgid ""
"<pre>\n"
";;; Called by any function that needs to create a stream. \n"
";;; make-stream creates, opens, and returns a stream, \n"
"(defun make-stream (device-type direction element-type name) \n"
"  (let* ((stream-class (select-stream-class \n"
"\t\t\tdirection element-type device-type)) \n"
"\t (stream (make-device-stream device-type stream-class \n"
"\t\t\t\t     name))) \n"
"    (setf (stream-state stream) 'open) \n"
"    stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:1197
msgid ""
"The two aspects of the make-stream procedure that we need to identify "
"further are "
msgstr ""
"Два аспекта процедуры make-stream, которые нам необходимы для определения"
" дальнейших областей"

#: ./en/ch11.md:1200
msgid ""
"* Selecting the stream class with select-stream-class \n"
"* Making an instance of the stream class with make-device-stream"
msgstr ""
"* Выбор класса потока с помощью select-stream-class \n"
"* Создание экземпляра класса stream с помощью make-device-stream"

#: ./en/ch11.md:1203
msgid ""
"We specify that make-stream calls select-stream-class to choose the "
"appropriate class based on the desired direction, element type, and device. "
"The association from sets of direction, element type, and device to the \n"
"stream classes is set up by calling add-stream-class. In this design, both "
"select-stream-class and add-stream-class are ordinary functions and are not "
"intended to be specialized by programmers. Instead, we expect programmers to "
"call add-stream-class for each instantiable class, to associate the stream "
"class with the correct direction, element type, and device. We document "
"select-stream-class and add-stream-class as follows:"
msgstr ""
"Мы указываем, что make-stream вызывает select-stream-class, чтобы выбрать"
" соответствующий класс на основе желаемого направления, типа элемента и"
" устройства. Связь наборов direction, типа элемента и устройства с классами"
" stream настраивается путем вызова add-stream-class. В этом проекте как"
" select-stream-class, так и add-stream-class являются обычными функциями и не"
" предназначены для специализации программистами. Вместо этого мы ожидаем, что"
" программисты вызовут add-stream-class для каждого создаваемого класса, чтобы"
" связать класс stream с правильным направлением, типом элемента и"
" устройством. Мы документируем select-stream-class и add-stream-class"
" следующим образом:"

#: ./en/ch11.md:1209
msgid ""
"\t    >  add-stream-class direction element-type device-type class \n"
"\t    >               Sets up an association from the first three arguments "
"to the class. This\n"
"\t    >               association is used by select-stream-class. \n"
"\t    >               direction is a keyword argument; element-type is a "
"type specifier; and\n"
"\t    >\t\t    device-type is a symbol."
msgstr ""
"\t    >  add-stream-class direction element-type device-type class \n"
"\t    >           Устанавливает связь между первыми тремя аргументами и"
" классом. Эта ассоциация \n"
"\t    >           используется select-stream-class. direction(направление) -"
" это аргумент ключевого слова;\n"
"\t    >           element-type(тип элемента) - это спецификатор типа; а"
" device-type(тип устройства) - это символ."

#: ./en/ch11.md:1213
msgid ""
"\t    >  select-stream-class direction element-type device-type \n"
"\t    >               Returns the appropriate class for the arguments. The "
"arguments are the same\n"
"\t    >\t\t    as the first three arguments to add-stream-class."
msgstr ""
"\t    >  select-stream-class direction element-type device-type \n"
"\t    >         Возвращает соответствующий класс для аргументов. Аргументы те"
" же, что и первые три \n"
"\t    >         аргумента для add-stream-class."

#: ./en/ch11.md:1215
msgid ""
"As far as the external protocol is concerned, the implementation of select-"
"stream-class and add-stream-class is irrelevant. One possible way to "
"implement these operations is with an association table, as follows:"
msgstr ""
"Что касается внешнего протокола, реализация select-stream-class и"
" add-stream-class не имеет значения. Одним из возможных способов реализации"
" этих операций является использование таблицы ассоциаций следующим образом:"

#: ./en/ch11.md:1219
msgid ""
"<pre>\n"
"(defvar *stream-selector* nil) "
msgstr ""

#: ./en/ch11.md:1225
msgid ""
";;; Sets up association from first 3 args to the class, \n"
"(defun add-stream-class (direction element-type device-type class) \n"
"  (setq *stream-selector* \n"
"\t(acons (list direction element-type device-type) class \n"
"\t       *stream-selector*)))"
msgstr ""

#: ./en/ch11.md:1237
msgid ""
";;; Chooses the appropriate class based on its arguments. \n"
";;; Signals an error if there is no matching stream, \n"
"(defun select-stream-class (direction element-type device-type) \n"
"  (let* ((entry (assoc (list direction element-type device-type) \n"
"\t\t       *stream-selector* \n"
"\t\t       :test #'compare-stream-lists)) \n"
"\t (class (cdr entry))) \n"
"    (if (null entry) \n"
"\t(error \"Cannot create a ~A ~A stream for device-type -A.\" \n"
"\t       element-type direction device-type) \n"
"\tclass)))"
msgstr ""

#: ./en/ch11.md:1245
msgid ""
";;; Returns t if the stream lists are equivalent. \n"
";;; Used to compare plist keys in *stream-selector* \n"
"(defun compare-stream-lists (list1 list2) \n"
"  (and (eql (first list1) (first list2)) \n"
"       ;; compare the element-types \n"
"       (equal-typep (second list1) (second list2)) \n"
"       (eql         (third list1) (third list2))))"
msgstr ""

#: ./en/ch11.md:1250
msgid ""
";;; Tests whether two type specifiers are equivalent, \n"
"(defun equal-typep (t1 t2) \n"
"  (and (subtypep t1 t2) (subtypep t2 t1)))\n"
"</pre>"
msgstr ""

#: ./en/ch11.md:1252
msgid ""
"The keys in the association list are lists of direction, element type, and "
"device type. We need to ensure that equivalent type specifiers choose the "
"element type correctly: (mod 256) and (unsigned-byte 8) are equivalent and "
"both should result in a stream whose element type is (unsigned-byte 8). We "
"use equal-typep to compare type specifiers."
msgstr ""
"Ключи в списке ассоциаций - это списки направления, типа элемента и типа"
" устройства. Нам нужно убедиться, что спецификаторы эквивалентного типа"
" правильно выбирают тип элемента: (mod 256) и (беззнаковый байт 8)"
" эквивалентны, и оба должны приводить к потоку, тип элемента которого равен"
" (беззнаковый байт 8). Мы используем equal-typep для сравнения спецификаторов"
" типов."

#: ./en/ch11.md:1254
msgid ""
"The job of make-device-stream is to call make-instance with the correct "
"arguments for the device. We expect programmers to specialize make-device-"
"stream for any new instantiate device type. In this example, we assume that "
"the device-type argument is a symbol, such as disk or tape—so the methods "
"must be individual methods that specialize onthose symbols. "
msgstr ""
"Задача make-device-stream состоит в том, чтобы вызвать make-instance с"
" правильными аргументами для устройства. Мы ожидаем, что программисты будут"
" специализировать make-device-stream для любого нового типа создаваемого"
" устройства. В этом примере мы предполагаем, что аргументом типа устройства"
" является символ, такой как диск или лента, поэтому методы должны быть"
" отдельными методами, которые специализируются на этих символах."

#: ./en/ch11.md:1261
msgid ""
"\t> make-device-stream device-type class name \n"
"\t>                   Creates and returns a stream; its main purpose is to "
"provide the correct\n"
"\t>\t\t    arguments to make-instance for the device class. This generic "
"function is\n"
"\t>\t\t    intended to be specialized for each device type, device-type is a "
"symbol,\n"
"\t>\t\t    such as tape or disk, name is a string: for a disk device it "
"names a path-name;\n"
"\t>\t\t    for a tape device, it names a unit number."
msgstr ""
"\t> make-device-stream device-type class name \n"
"\t>                  Создает и возвращает поток; его основная цель -"
" предоставить правильные аргументы \n"
"\t>                  make-instance для класса device. Эта обобщенная функция"
" предназначена для специализации\n"
"\t>                  для каждого типа устройства, тип устройства - это"
" символ, такой как лента или диск, имя - это\n"
"\t>                  строка: для дискового устройства это имя пути; для"
" ленточного устройства это номер устройства."

#: ./en/ch11.md:1263
msgid ""
"In summary, the protocol for hooking a new stream into the stream creation "
"mechanism consists of two tasks:"
msgstr ""
"Таким образом, протокол для подключения нового потока к механизму создания"
" потока состоит из двух задач:"

#: ./en/ch11.md:1266
msgid ""
"*   add-stream-class must be called for new instantiable streams \n"
"*   make-device-stream must be specialized for new device classes"
msgstr ""
"* add-stream-класс должен быть вызван для новых создаваемых потоков\n"
"* make-device-stream должен быть специализирован для новых классов устройств"

#: ./en/ch11.md:1268
msgid "### Using the Protocol for Creating Streams"
msgstr "### Использование протокола для создания потоков"

#: ./en/ch11.md:1273
msgid ""
"<pre>\n"
";;;; THE MAKE-DEVICE-STREAM GENERIC FUNCTION \n"
"(defgeneric make-device-stream (device-type class name) \n"
"  (:documentation \"Create an instance with correct initargs.\")) "
msgstr ""

#: ./en/ch11.md:1278
msgid ""
";;;; METHODS FOR MAKE-DEVICE-STREAM \n"
"(defmethod make-device-stream ((device-type (eql 'tape)) \n"
"\t\t\t       class name) \n"
"  (make-instance class :unit (parse-integer name)))"
msgstr ""

#: ./en/ch11.md:1282
msgid ""
"(defmethod make-device-stream ((device-type (eql 'disk)) \n"
"\t\t\t       class name) \n"
"  (make-instance class :pathname name)) "
msgstr ""

#: ./en/ch11.md:1286
msgid ""
";;;; ADDING CHARACTER DISK STREAMS \n"
"(add-stream-class :input 'character 'disk \n"
"\t\t  (find-class 'character-disk-input-stream)) "
msgstr ""

#: ./en/ch11.md:1289
msgid ""
"(add-stream-class :output 'character 'disk \n"
"\t\t  (find-class 'character-disk-output-stream))"
msgstr ""

#: ./en/ch11.md:1292
msgid ""
"(add-stream-class :bidirectional 'character 'disk \n"
"\t\t  (find-class 'character-disk-bidirectional-stream)) "
msgstr ""

#: ./en/ch11.md:1296
msgid ""
";;;; ADDING CHARACTER TAPE STREAMS \n"
"(add-stream-class :input 'character 'tape \n"
"\t\t  (find-class 'character-tape-input-stream))"
msgstr ""

#: ./en/ch11.md:1299
msgid ""
"(add-stream-class :output 'character 'tape \n"
"\t\t  (find-class 'character-tape-output-stream)) "
msgstr ""

#: ./en/ch11.md:1303
msgid ""
";;;; ADDING 8-BIT-BYTE DISK STREAMS \n"
"(add-stream-class :input '(unsigned-byte 8) 'disk \n"
"\t\t  (find-class '8-bit-byte-disk-input-stream))"
msgstr ""

#: ./en/ch11.md:1306
msgid ""
"(add-stream-class :output '(unsigned-byte 8) 'disk \n"
"\t\t  (find-class '8-bit-byte-disk-output-stream))"
msgstr ""

#: ./en/ch11.md:1310
msgid ""
"(add-stream-class :bidirectional '(unsigned-byte 8) 'disk \n"
"\t\t  (find-class \n"
"\t\t   '8-bit-byte-disk-bidirectional-stream)) "
msgstr ""

#: ./en/ch11.md:1314
msgid ""
";;;; ADDING 8-BIT-BYTE TAPE STREAMS \n"
"(add-stream-class :input '(unsigned-byte 8) 'tape \n"
"\t\t  (find-class '8-bit-byte-tape-input-stream))"
msgstr ""

#: ./en/ch11.md:1317
msgid ""
"(add-stream-class :output '(unsigned-byte 8) 'tape \n"
"\t\t  (find-class '8-bit-byte-tape-output-stream)) "
msgstr ""

#: ./en/ch11.md:1321
msgid ""
";;;; ADDING 32-BIT-WORD DISK STREAMS \n"
"(add-stream-class :input '(signed-byte 32) 'disk \n"
"\t\t  (find-class '32-bit-word-disk-input-stream))"
msgstr ""

#: ./en/ch11.md:1324
msgid ""
"(add-stream-class :output '(signed-byte 32) 'disk \n"
"\t\t  (find-class '32-bit-word-disk-output-stream))"
msgstr ""

#: ./en/ch11.md:1328
msgid ""
"(add-stream-class :bidirectional '(signed-byte 32) 'disk \n"
"\t\t  (find-class \n"
"\t\t   '32-bit-word-disk-bidirectional-stream)) "
msgstr ""

#: ./en/ch11.md:1332
msgid ""
";;;; ADDING 32-BIT-WORD TAPE STREAMS \n"
"(add-stream-class :input '(signed-byte 32) 'tape \n"
"\t\t  (find-class '32-bit-word-tape-input-stream))"
msgstr ""

#: ./en/ch11.md:1336
msgid ""
"(add-stream-class :output '(signed-byte 32) 'tape \n"
"\t\t  (find-class '32-bit-word-tape-output-stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch11.md:1339
msgid "## 11.11 SUMMARY OF TECHNIQUES USED IN STREAMS "
msgstr "## 11.11 КРАТКОЕ ОПИСАНИЕ МЕТОДОВ, ИСПОЛЬЗУЕМЫХ В ПОТОКАХ"

#: ./en/ch11.md:1341
msgid ""
"We have shown an example using CLOS and object-oriented techniques to solve "
"a complex problem. The important techniques are as follows:"
msgstr ""
"Мы показали пример использования CLOS и объектно-ориентированных методов для"
" решения сложной задачи. Важными методами являются следующие:"

#: ./en/ch11.md:1348
msgid ""
"*  Identifying classes that represent the types of objects manipulated by "
"the program \n"
"*  Documenting an external protocol to be used by clients to create and "
"manipulate the objects \n"
"*  Maximizing the sharing of code while minimizing the duplication of both "
"code and information (knowledge), by \n"
"   *  Arranging the classes into an organization that accurately reflects "
"the interaction among the different types of objects \n"
"   *  Documenting an internal protocol to be used by the different classes "
"to communicate with one another \n"
"*   Providing a mechanism for linking the classes themselves to the external "
"interface for creating objects "
msgstr ""
"* Определение классов, представляющих типы объектов, которыми управляет"
" программа\n"
"* Документирование внешнего протокола, который будет использоваться клиентами"
" для создания объектов и управления ими.\n"
"* Максимальное совместное использование кода при минимизации дублирования как"
" кода, так и информации (знаний), путем\n"
"    * Организация классов в организацию, которая точно отражает"
" взаимодействие между различными типами объектов\n"
"    * Документирование внутреннего протокола, который будет использоваться"
" различными классами для связи друг с другом\n"
"* Предоставление механизма для привязки самих классов к внешнему интерфейсу"
" для создания объектов"

#: ./en/ch11.md:1350
msgid ""
"Although we have documented the external and internal stream protocols, we "
"need to document the implementation of streams to enable other programmers "
"to extend streams. The alternative would be to make the source code of "
"streams available to programmers. "
msgstr ""
"Хотя мы задокументировали внешние и внутренние протоколы потоков, нам"
" необходимо задокументировать реализацию потоков, чтобы другие программисты"
" могли расширять потоки. Альтернативой было бы сделать исходный код потоков"
" доступным для программистов."

#: ./en/ch11.md:1352
msgid "## 11.12 DOCUMENTING THE IMPLEMENTATION OF STREAMS"
msgstr "## 11.12 ДОКУМЕНТИРОВАНИЕ РЕАЛИЗАЦИИ ПОТОКОВ"

#: ./en/ch11.md:1354
msgid ""
"The task of documenting an implementation is a challenge, because it "
"requires you to be aware of which aspects of the implementation are internal "
"and which are external. We recommend a conservative approach, which is to "
"document the implementation on a strict \"need to know\" basis. That is, "
"document only those portions of the implementation that outside programmers "
"must understand in order to extend the program. "
msgstr ""
"Задача документирования реализации является сложной, поскольку она требует,"
" чтобы вы знали, какие аспекты реализации являются внутренними, а какие"
" внешними. Мы рекомендуем консервативный подход, который заключается в"
" документировании реализации на строгой основе \"необходимо знать\". То есть"
" документируйте только те части реализации, которые должны быть поняты"
" сторонними программистами для расширения программы."

#: ./en/ch11.md:1356
msgid ""
"(Documentation of the internals would be useful for maintainers; this is, "
"however, a different issue from that of documenting an implementation for "
"other programmers to extend.)"
msgstr ""
"(Документация внутренних компонентов была бы полезна для сопровождающих;"
" однако это проблема, отличная от проблемы документирования реализации для"
" расширения другими программистами.)"

#: ./en/ch11.md:1358
msgid ""
"It is important to document the existence and organization of the stream "
"classes. Programmers need to know what methods are defined for the generic "
"functions in the internal and external protocols, which classes those "
"methods are attached to, and what the methods do. We can, however, omit the "
"details of how the methods work. Some methods do not need to be documented "
"at all. For example, the method for wait-for-disk is purely internal to disk "
"streams. Programmers who want to extend streams to handle other devices or "
"element types would have no need to call wait-for-disk, to specialize it, or "
"to be aware of its existence. On the other hand, if we want to enable "
"programmers to extend disk streams, we do need to document wait-for-disk."
msgstr ""
"Важно задокументировать существование и организацию потоковых классов."
" Программистам необходимо знать, какие методы определены для обобщенных"
" функций во внутренних и внешних протоколах, к каким классам присоединены эти"
" методы и что они делают. Однако мы можем опустить детали того, как работают"
" эти методы. Некоторые методы вообще не нуждаются в документировании."
" Например, метод wait-for-disk(ожидания диска) является чисто внутренним для"
" дисковых потоков. Программистам, которые хотят расширить потоки для"
" обработки других устройств или типов элементов, не нужно вызывать"
" wait-for-disk, специализировать его или знать о его существовании. С другой"
" стороны, если мы хотим позволить программистам расширять дисковые потоки,"
" нам действительно нужно документировать wait-for-disk(ожидание диска)."

#: ./en/ch11.md:1360
msgid ""
"We would probably choose not to expose the slots of a class, in favor of "
"documenting the methods that access them. For example, documenting the "
"methods for stream-state and (setf stream-state) gives programmers "
"sufficient information to query a stream for its state and to change that "
"state. There is no need to expose the fact that these are reader and writer "
"methods for a slot. "
msgstr ""
"Вероятно, мы предпочли бы не раскрывать слоты класса в пользу"
" документирования методов, которые обращаются к ним. Например,"
" документирование методов для stream-state и (setf stream-state) дает"
" программистам достаточную информацию для запроса потока о его состоянии и"
" для изменения этого состояния. Нет необходимости раскрывать тот факт, что"
" это методы чтения и записи для слота."
