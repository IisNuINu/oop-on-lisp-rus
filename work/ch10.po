#. extracted from ./en/ch10.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 10:45+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch10.md:2
msgid "# A Procedural Definition: Initialization"
msgstr "# Процедурное определение: Инициализация"

#: ./en/ch10.md:4
msgid ""
"In this chapter, we discuss the technique of designing a \"procedural "
"definition\" of a high-level task; this entails breaking down the task into "
"separate generic functions, each of which is responsible for a clearly "
"defined portion of the task. Usually, there is a default behavior for the "
"generic functions. Programmers use these generic functions as entry points; "
"they can control portions of the task by specializing one or more of the "
"generic functions."
msgstr ""
"В этой главе мы обсуждаем технику разработки \"процедурного определения\""
" задачи высокого уровня; это влечет за собой разбиение задачи на отдельные"
" обобщенные функции, каждая из которых отвечает за четко определенную часть"
" задачи. Обычно для обобщенных функций существует поведение по умолчанию."
" Программисты используют эти обобщенные функции в качестве точек входа; они"
" могут управлять частями задачи, специализируя одну или несколько обобщенных"
" функций."

#: ./en/ch10.md:6
msgid ""
"Some programs have several related tasks. The procedural definitions of the "
"tasks can overlap, to share code. Two or three tasks might be defined to "
"call a single generic function. This technique can lead to modular programs; "
"it requires a careful design in which the shared work can be shared, while "
"the separate work can be kept separate. We examine one example in detail: "
"the CLOS procedural definition of initialization."
msgstr ""
"Некоторые программы имеют несколько связанных задач. Процедурные определения"
" задач могут накладываться друг на друга, чтобы совместно использовать код."
" Две или три задачи могут быть определены для вызова одной обобщенной"
" функции. Этот метод(техника) может привести к созданию модульных программ;"
" он требует тщательного проектирования, при котором общая работа может быть"
" разделена, в то время как отдельная работа может храниться отдельно. Мы"
" подробно рассмотрим один пример: процедурное определение инициализации CLOS."

#: ./en/ch10.md:8
msgid "## 10.1 EXAMPLES OF PROCEDURAL DEFINITIONS"
msgstr "## 10.1 ПРИМЕРЫ ПРОЦЕДУРНЫХ ОПРЕДЕЛЕНИЙ"

#: ./en/ch10.md:10
msgid ""
"We used the technique of a procedural definition in \"The Implementation of "
"install,\" page 80. As shown in Fig. 10.1, the installation task is  divided "
"into four generic functions, each of which performs a single aspect of the "
"installation. "
msgstr ""
"Мы использовали метод процедурного определения в разделе \"Реализация"
" установки/инсталяции\", стр. 80. Как показано на рис. 10.1, задача установки"
" разделена на четыре обобщенные функции, каждая из которых выполняет"
" отдельный аспект установки."

#: ./en/ch10.md:13
msgid ""
"![Figure 10.1: Procedural definition of the installation task.](images/f10-01"
".jpg)\n"
"**Figure 10.1: Procedural definition of the installation task.**"
msgstr ""
"![Рисунок 10.1: Процедурное определение задачи установки.](images/f10-01.jpg )"
"**Рисунок 10.1: Процедурное определение задачи установки.**"

#: ./en/ch10.md:15
msgid ""
"Later, in \"A Procedural Definition for Creating Streams,\" page 207, we "
"design a procedural definition for choosing the correct class of stream to "
"create, and for creating the stream by giving the appropriate arguments to "
"make-instance."
msgstr ""
"Позже, в разделе \"Процедурное определение для создания потоков\", стр. 207,"
" мы разработаем процедурное определение для выбора правильного класса потока"
" для создания и для создания потока путем предоставления соответствующих"
" аргументов make-instance."

#: ./en/ch10.md:17
msgid ""
"CLOS itself uses the technique of procedural definitions. We have already "
"seen that make-instance has a procedural definition: it always calls "
"initialize-instance. Class redefinition is another example; it always calls "
"update-instance-for-redefined-class. Similarly, change-class always calls "
"update-instance-for-different-class. The generic functions initialize-"
"instance, update-instance-for-redefined-class, and update-instance-for-"
"different-class are defined intentionally as entry points—generic functions "
"that can be specialized with methods."
msgstr ""
"Сам CLOS использует технику процедурных определений. Мы уже видели, что"
" make-instance имеет процедурное определение: она всегда вызывает"
" initialize-instance. Переопределение класса - еще один пример; оно всегда"
" вызывает update-instance-for-redefined-class. Аналогично, change-class"
" всегда вызывает update-instance-for-different-class. Обобщенные функции"
" initialize-instance, update-instance-for-redefined-class и"
" update-instance-for-different-class намеренно определены как точки входа —"
" обобщенные функции, которые могут быть специализированы с помощью методов."

#: ./en/ch10.md:19
msgid ""
"Certain error situations also have procedural definitions: generic functions "
"that are called when errors are encountered. The default method signals an "
"error, but you can specialize the generic function to do something "
"different. The generic functions include the following:"
msgstr ""
"Некоторые ситуации с ошибками также имеют процедурные определения: обобщенные"
" функции, которые вызываются при возникновении ошибок. Метод по умолчанию"
" сигнализирует об ошибке, но вы можете специализировать обобщенную функцию,"
" чтобы сделать что-то другое. Обобщенные функции включают в себя следующее:"

#: ./en/ch10.md:22
msgid ""
"\t>   slot-unbound \n"
"\t>           Called when an attempt is made to read an unbound slot"
msgstr ""
"\t>   slot-unbound \n"
"\t>            Вызывается при попытке прочитать несвязанный слот"

#: ./en/ch10.md:26
msgid ""
"\t>   slot-missing \n"
"\t>           Called when an attempt is made to access a slot of an "
"instance, but there is no slot\n"
"\t>           by that name accessible to the instance"
msgstr ""
"\t>   slot-missing \n"
"\t>            Вызывается, когда предпринимается попытка получить доступ к"
" слоту экземпляра, но нет слота\n"
"\t>            с таким именем, доступного экземпляру"

#: ./en/ch10.md:29
msgid ""
"\t>   no-applicable-method \n"
"\t>           Called when a generic function is called and there is no "
"applicable method for it "
msgstr ""
"\t>   no-applicable-method \n"
"\t>            Вызывается, когда вызывается обобщенная функция и для нее нет"
" применимого метода"

#: ./en/ch10.md:32
msgid ""
"\t>   no-next-method \n"
"\t>           Called when call-next-method is used and there is no \"next "
"method\""
msgstr ""
"\t>   no-next-method \n"
"\t>             Вызывается, когда используется call-next-method и нет"
" \"следующего метода\""

#: ./en/ch10.md:34
msgid "## 10.2 ISOLATING WORK SHARED AMONG PROCEDURES"
msgstr "## 10.2 ИЗОЛЯЦИЯ РАБОТЫ, РАЗДЕЛЯЕМОЙ МЕЖДУ ПРОЦЕДУРАМИ"

#: ./en/ch10.md:36
msgid ""
"CLOS initializes instances in several contexts: when an instance is first "
"created with make-instance, when an instance is being updated because its "
"class was redefined, and when you use change-class to change the class of an "
"instance. In addition, the function reinitialize-instance (rarely used in "
"application programs, but used within the implementation of CLOS itself, in "
"the metaobject protocol) performs initialization of an instance based on "
"initargs."
msgstr ""
"CLOS инициализирует экземпляры в нескольких контекстах: когда экземпляр"
" впервые создается с помощью make-instance, когда экземпляр обновляется,"
" поскольку его класс был переопределен, и когда вы используете change-class"
" для изменения класса экземпляра. Кроме того, функция reinitialize-instance"
" (редко используемая в прикладных программах, но используемая в рамках"
" реализации самого CLOS, в протоколе metaobject) выполняет инициализацию"
" экземпляра на основе initargs."

#: ./en/ch10.md:38
msgid ""
"In each of these tasks, the initialization work is similar but not "
"identical. In an object-oriented design, the goal is to isolate the work "
"that can be shared, define it once, and use it everywhere it is needed. In "
"this section, we describe how CLOS defines these related procedures in an "
"object-oriented way. You can use this approach when designing your own "
"programs. The four related initialization procedures are somewhat "
"complicated, and most application programs do not require this much "
"complexity; still, the example provides a good illustration of procedural  "
"definitions."
msgstr ""
"В каждой из этих задач работа по инициализации аналогична, но не идентична. В"
" объектно-ориентированном проектировании цель состоит в том, чтобы"
" изолировать работу, которой можно поделиться, определить ее один раз и"
" использовать везде, где это необходимо. В этом разделе мы опишем, как CLOS"
" определяет эти связанные процедуры объектно-ориентированным способом. Вы"
" можете использовать этот подход при разработке своих собственных программ."
" Четыре связанные процедуры инициализации несколько сложны, и большинство"
" прикладных программ не требуют такой большой сложности; тем не менее, этот"
" пример дает хорошую иллюстрацию процедурных определений."

#: ./en/ch10.md:40
msgid ""
"The first step is to identify what the procedures have in common. Here we "
"focus on the initialization work done in each task:"
msgstr ""
"Первый шаг - определить, что общего у этих процедур. Здесь мы сосредоточимся"
" на работе по инициализации, выполняемой в каждой задаче:"

#: ./en/ch10.md:44
msgid ""
"\t>   initialize-instance \n"
"\t>           Performs initialization according to initargs; then, for any "
"slots that are still\n"
"\t>           unbound, fills those slots with the values of their initforms"
msgstr ""
"\t>   initialize-instance \n"
"\t>           Выполняет инициализацию в соответствии с initargs; затем для"
" любых слотов, которые все еще \n"
"\t>           не привязаны, заполняет эти слоты значениями их initforms"

#: ./en/ch10.md:47
msgid ""
"\t>   reinitialize-instance \n"
"\t>           Performs initialization according to initargs"
msgstr ""
"\t>   reinitialize-instance \n"
"\t>           Выполняет инициализацию в соответствии с initargs"

#: ./en/ch10.md:51
msgid ""
"\t>   update-instance-for-redefined-class \n"
"\t>           Performs initialization according to initargs; then, for any "
"added local slots that\n"
"\t>           are still unbound, fills those slots with the values of their "
"initforms"
msgstr ""
"\t>   update-instance-for-redefined-class \n"
"\t>           Выполняет инициализацию в соответствии с initargs; затем для"
" любых добавленных локальных\n"
"\t>           слотов, которые все еще не привязаны, заполняет эти слоты"
" значениями их initforms"

#: ./en/ch10.md:55
msgid ""
"\t>   update-instance-for-different-class \n"
"\t>           Performs initialization according to initargs; then, for any "
"added local slots that\n"
"\t>           are still unbound, fills those slots with the values of their "
"initforms "
msgstr ""
"\t>   update-instance-for-different-class \n"
"\t>           Выполняет инициализацию в соответствии с initargs; затем для"
" любых добавленных локальных\n"
"\t>           слотов, которые все еще не привязаны, заполняет эти слоты"
" значениями их initforms"

#: ./en/ch10.md:58
msgid ""
"We have identified two phases of initialization: performing initialization "
"according to initargs, and then filling some unbound slots with the values "
"of their initforms. CLOS arranges for both phases to be done by one generic "
"function, shared-initialize, which is called by all four generic functions "
"mentioned. The four functions have slightly different requirements; these "
"differences are managed by providing arguments to shared-initialize. The "
"syntax of shared-initialize is \n"
"(shared-initialize instance slots-for-initform srest initargs)"
msgstr ""
"Мы определили две фазы инициализации: выполнение инициализации в соответствии"
" с initargs, а затем заполнение некоторых несвязанных слотов значениями их"
" initforms. CLOS организует выполнение обеих фаз одной обобщенной функцией"
" shared-initialize, которая вызывается всеми четырьмя упомянутыми"
" обобобщенными функциями. Четыре функции имеют несколько разные требования;"
" эти различия устраняются путем предоставления аргументов для"
" shared-initialize(общей инициализации). Синтаксис shared-initialize таков"

#: ./en/ch10.md:60
msgid "## 10.3 FILLING UNBOUND SLOTS WITH INITFORMS"
msgstr "## 10.3 ЗАПОЛНЕНИЕ НЕСВЯЗАННЫХ СЛОТОВ INITFORMS(ФОРМАМИ ИНИЦИАЛИЗАЦИИ)"

#: ./en/ch10.md:62
msgid ""
"For the two updating functions, the phase of filling unbound slots with "
"initforms is done for the added local slots. For initialize-instance, this "
"phase is done for all slots; for reinitialize-instance it is not done for "
"any slots."
msgstr ""
"Для двух функций обновления фаза заполнения несвязанных слотов с помощью"
" initforms выполняется для добавленных локальных слотов. Для"
" initialize-instance этот этап выполняется для всех слотов; для"
" reinitialize-instance он не выполняется ни для каких слотов."

#: ./en/ch10.md:64
msgid ""
"The generic function shared-initialize takes a required argument called "
"slots-for-initform, indicating which slots to fill with their initforms. "
"This argument is a list of names of slots, or t to indicate all slots, or "
"nil to indicate no slots. The following table shows how the callers (default "
"methods for the four generic functions) provide the slots-for-initform "
"argument:"
msgstr ""
"Обобщенная функция shared-initialize принимает обязательный аргумент,"
" называемый slots-for-initform, указывающий, какие слоты следует заполнить их"
" initforms. Этот аргумент представляет собой список имен слотов, или t для"
" обозначения всех слотов, или nil для обозначения отсутствия слотов. В"
" следующей таблице показано, как вызывающие  (методы по умолчанию для четырех"
" обобщенных функций) предоставляют аргумент slots-for-initform:"

#: ./en/ch10.md:71
msgid ""
"|  Caller of  shared-initialize        | Value of slots-for-initform |\n"
"|--------------------------------------|----------------------|\n"
"| initialize-instance                  | t                    |\n"
"| reinitialize-instance                | nil                  |\n"
"| update-instance-for-redefined-class  | added  local slots   |\n"
"| update-instance-for-different-class  | added  local slots   |"
msgstr ""
"| Вызывающий shared-initialize   | Значение для  slots-for-initform      |\n"
"|------------------------------------------------|----------------------------"
"---|\n"
"| initialize-instance                           | t                          "
" |\n"
"| reinitialize-instance                        | nil                        "
" |\n"
"| update-instance-for-redefined-class | added  local slots   |\n"
"| update-instance-for-different-class  | added  local slots   |"

#: ./en/ch10.md:73
msgid "## 10.4 PERFORMING INITIALIZATION BY INITARGS"
msgstr "## 10.4 ВЫПОЛНЕНИЕ ИНИЦИАЛИЗАЦИИ С ПОМОЩЬЮ INITARGS"

#: ./en/ch10.md:75
msgid ""
"As described in \"Controlling Initialization with Methods,\" page 159, "
"initialize-instance performs initialization according to initargs. If a slot-"
"filling initarg is given in the call to initialize-instance, the slot is "
"filled with that value, even if the slot already has a value. Initargs can  "
"also be used by user-defined initialization methods that do extra work "
"required by the application program."
msgstr ""
"Как описано в разделе \"Управление инициализацией с помощью методов\", стр."
" 159, initialize-instance выполняет инициализацию в соответствии с initargs."
" Если initarg заполняющий слот, задан в вызове initialize-instance, слот"
" заполняется этим значением, даже если слот уже имеет значение. Initargs"
" также могут использоваться определяемыми пользователем методами"
" инициализации, которые выполняют дополнительную работу, требуемую прикладной"
" программой."

#: ./en/ch10.md:77
msgid ""
"In most cases, there is no need for updating functions to use initialization "
"arguments. Sometimes, however, an application program needs a method for a "
"special purpose, and that method needs some arguments as input. For example, "
"a method for update-instance-for-redefined-class might need an argument in "
"addition to the four required arguments; the same could be true for a method "
"for update-instance-for-different-class."
msgstr ""
"В большинстве случаев нет необходимости в обновлении функций для"
" использования аргументов инициализации. Иногда, однако, прикладной программе"
" требуется метод для специальной цели, и этому методу нужны некоторые"
" аргументы в качестве входных данных. Например, методу"
" update-instance-for-redefined-class(обновления экземпляра для"
" переопределенного класса) может потребоваться аргумент в дополнение к"
" четырем требуемым аргументам; то же самое может быть верно для метода"
" update-instance-for-different-class(обновления экземпляра для другого"
" класса)."

#: ./en/ch10.md:79
msgid ""
"Initargs can be useful in all initialization tasks, so this is another piece "
"of work that can be shared. Thus, shared-initialize accepts an srest "
"argument consisting of initargs. Each caller of shared-initialize chooses "
"whether or not to supply initargs."
msgstr ""
"Initargs могут быть полезны во всех задачах инициализации, так что это еще"
" одна часть работы, которой можно поделиться. Таким образом,"
" shared-initialize принимает аргумент &rest, состоящий из initargs. Каждый"
" вызывающий shared-initialize выбирает, предоставлять ли initargs или нет."

#: ./en/ch10.md:82
msgid ""
"The user can provide initargs directly to make-instance; these initargs are "
"passed to initialize-instance, and then are passed to shared-initialize. "
"When redefining a class or changing the class of an instance, however, the "
"user cannot provide initargs. So how are initargs useful in these updating "
"procedures? You can define an around-method for update-instance-for-"
"redefined-class or update-instance-for-different-class. The around-method "
"computes initargs and passes them  on in a call to call-next-method; the "
"default method is invoked with \n"
"those initargs, and it passes them on to shared-initialize. Thus, around-"
"methods are the entry point that allows the updating functions to use "
"initargs."
msgstr ""
"Пользователь может предоставить initargs(инициализации) непосредственно"
" make-instance; эти initargs передаются initialize-instance, а затем"
" передаются shared-initialize. Однако при переопределении класса или"
" изменении класса экземпляра пользователь не может предоставить initargs. Так"
" как initargs могут быть полезны в этих процедурах обновления? Вы можете"
" определить (окружающий)around-метод дляupdate-instance-for-redefined-class"
" или update-instance-for-different-class. Метод around вычисляет initargs и"
" передает их в вызове call-next-method; метод по умолчанию вызывается с этими"
" initargs, и он передает их в shared-initialize. Таким образом, around-методы"
" являются точкой входа, которая позволяет функциям обновления использовать"
" initargs."

#: ./en/ch10.md:84
msgid "## 10.5 SPECIALIZING A PORTION OF THE PROCEDURE"
msgstr "## 10.5 СПЕЦИАЛИЗАЦИЯ ЧАСТИ ПРОЦЕДУРЫ"

#: ./en/ch10.md:86
msgid ""
"A procedural definition enables users to specialize one or more aspects of "
"the procedure as a whole. The initialization scheme recognizes that some "
"work is appropriate to one task only (such as class redefinition), whereas "
"other work is appropriate to all initialization tasks. The procedural "
"definition both separates the four initialization tasks from one another, "
"and combines them via the call to shared-initialize."
msgstr ""
"Процедурное определение позволяет пользователям специализировать один или"
" несколько аспектов процедуры в целом. Схема инициализации признает, что"
" некоторая работа подходит только для одной задачи (например, переопределение"
" класса), тогда как другая работа подходит для всех задач инициализации."
" Процедурное определение как отделяет четыре задачи инициализации друг от"
" друга, так и объединяет их с помощью вызова shared-initialize."

#: ./en/ch10.md:97
msgid ""
"| Specializing this Generic Function    | Affects                  |\n"
"|---------------------------------------|--------------------------|\n"
"| initialize-instance                   | instance creation        |\n"
"| reinitialize-instance                 | instance reinitialization| \n"
"| update-instance-for-redefined-class   | class redefinition       |\n"
"| update-instance-for-different-class   | class change             |\n"
"| shared-initialize                     | instance creation,       |\n"
"|                                       | instance reinitialization| \n"
"|                                       | class redefinition,      |\n"
"|                                       | and class change         |"
msgstr ""
"| Специализация этой обобщенной функции | Влияние                     |\n"
"|---------------------------------------|-----------------------------|\n"
"| initialize-instance                   | создание экземпляра         |\n"
"| reinitialize-instance                 | переинициализация экземпляра| \n"
"| update-instance-for-redefined-class   | переопределение классса     |\n"
"| update-instance-for-different-class   | изменение класса            |\n"
"| shared-initialize                     | создание экземпляра,        |\n"
"|                                       | переинициализация экземпляра| \n"
"|                                       | переопределение классса,    |\n"
"|                                       | и  изменение класса         |"

#: ./en/ch10.md:99
msgid ""
"Each of the five initialization functions has a default primary method. For "
"example, the default method for update-instance-for-different-class calls "
"initialize-instance with the appropriate arguments. In turn, the default "
"method for initialize-instance performs initialization according to initargs "
"and initforms, based on its arguments. Typically, programmers specialize "
"these generic functions by providing after-methods, not primary methods."
msgstr ""
"Каждая из пяти функций инициализации имеет основной метод по умолчанию."
" Например, метод по умолчанию для update-instance-for-different-class"
" вызывает initialize-instance с соответствующими аргументами. В свою очередь,"
" метод по умолчанию для initialize-instance выполняет инициализацию в"
" соответствии с initargs и initforms на основе своих аргументов. Как правило,"
" программисты специализируют эти обобощенные функции, предоставляя"
" after-методы, а не первичные методы."

#: ./en/ch10.md:101
msgid "## 10.6 DECLARING INITARG NAMES AS VALID"
msgstr "## 10.6 ОБЪЯВЛЕНИЕ ИМЕН INITARG КАК ДОПУСТИМЫХ"

#: ./en/ch10.md:103
msgid ""
"All five initialization functions accept initargs. As mentioned in "
"\"Initialization Arguments,\" page 160, initarg names must be declared as "
"valid. If a generic function is called with an unrecognized initarg name, an "
"error is signaled."
msgstr ""
"Все пять функций инициализации принимают initargs. Как упоминалось в разделе"
" \"Аргументы инициализации\", стр. 160, имена initarg должны быть объявлены"
" как допустимые. Если обобщенная функция вызывается с нераспознанным именем"
" initarg, выдается сообщение об ошибке."

#: ./en/ch10.md:105
msgid ""
"The :initarg slot option declares initarg names as valid for all five "
"initialization functions. Defining initialization methods that use skey "
"parameters declares the parameter names as valid initarg names. For each "
"call to an initialization generic function, the set of valid initarg "
"namesdepends on the appropriate applicable initialization methods:"
msgstr ""
"Параметр слота :initarg объявляет имена initarg допустимыми для всех пяти"
" функций инициализации. Определение методов инициализации, которые используют"
" параметры &key, объявляет имена параметров как допустимые имена initarg. Для"
" каждого вызова обобщенной функции инициализации набор допустимых имен"
" initarg зависит от соответствующих применимых методов инициализации:"

#: ./en/ch10.md:117
msgid ""
"| Task Performed          | Initialization Methods that Declare Initarg "
"Names as Valid |\n"
"|-------------------------|------------------------------------|\n"
"| Instance creation       | make-instance,                     |\n"
"|                         | initialize-instance,               |\n"
"|                         | shared-initialize                  |\n"
"|Instance reinitialization| reinitialize-instance,             |\n"
"|                         | shared-initialize                  |\n"
"| Class change            |update-instance-for-different-class,|\n"
"|                         | shared-initialize                  |\n"
"| Class redefinition      |update-instance-for-redefined-class,|\n"
"|                         | shared-initialize                  |"
msgstr ""
"| Выполняемая Задача          | Методы инициализации, которые объявляют имена"
" Initarg допустимыми        |\n"
"|--------------------------------------------|--------------------------------"
"----------------------------|\n"
"| Создание экземпляра          | make-instance,                              "
"      |\n"
"|                                            | initialize-instance,          "
"                      |\n"
"|                                            | shared-initialize             "
"                      |\n"
"|Переинициализация экземпл| reinitialize-instance,                           "
"  |\n"
"|                                            | shared-initialize             "
"                      |\n"
"|Изменение класса                |update-instance-for-different-class,       "
" |\n"
"|                                            | shared-initialize             "
"                      |\n"
"| Переопределение класса    |update-instance-for-redefined-class,       |\n"
"|                                            | shared-initialize             "
"                      |"
