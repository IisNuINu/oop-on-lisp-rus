#. extracted from ./en/ch04.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 10:57+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch04.md:2
msgid "# Programming with Methods"
msgstr "# Программирование с помощью методов"

#: ./en/ch04.md:4
msgid ""
"The locking program illustrated the central features of CLOS. This chapter "
"describes additional useful techniques, including how to write methods to do "
"the following:"
msgstr ""
"Программа блокировки проиллюстрировала основные функции CLOS. В этой главе"
" описываются дополнительные полезные методы, в том числе как написать методы"
" для выполнения следующих действий:"

#: ./en/ch04.md:10
msgid ""
"*   Represent information without storing it in slots \n"
"*   Add behavior to an accessor generic function \n"
"*   Specialize on more than one argument \n"
"*   Specialize on Common Lisp types such as strings and arrays \n"
"*   Specialize on an individual Lisp object "
msgstr ""
"* Представление информации без сохранения ее в слотах\n"
"* Добавление поведения к обобщенной функции средства доступа(accessor)\n"
"* Специализироваться на более чем одном аргументе\n"
"* Специализироваться на типах Common Lisp, таких как строки и массивы\n"
"* Специализироваться на отдельном объекте Lisp"

#: ./en/ch04.md:12
msgid ""
"We use three examples in this chapter. The first example represents "
"triangles as instances of classes and demonstrates different ways to store "
"information associated with triangles. The second example is an installation "
"program designed to install various software products on different operating "
"systems; shows how to write methods that specialize on more than one "
"argument. The third example is a program supporting remote evaluation, which "
"illustrates methods that specialize on Common Lisp types and on individual "
"Lisp objects. "
msgstr ""
"В этой главе мы используем три примера. Первый пример представляет"
" треугольники как экземпляры классов и демонстрирует различные способы"
" хранения информации, связанной с треугольниками. Второй пример представляет"
" собой программу установки, предназначенную для установки различных"
" программных продуктов в разных операционных системах; показано, как писать"
" методы, которые специализируются на более чем одном аргументе. Третий пример"
" - это программа, поддерживающая удаленную оценку/выполнение, которая"
" иллюстрирует методы, специализирующиеся на типах Common Lisp и на отдельных"
" объектах Lisp."

#: ./en/ch04.md:15
msgid "## 4.1 IMPLEMENTATION CHOICES: METHODS VERSUS SLOTS"
msgstr "## 4.1 ВАРИАНТЫ РЕАЛИЗАЦИИ: МЕТОДЫ ПРОТИВ СЛОТОВ"

#: ./en/ch04.md:17
msgid ""
"CLOS supports more than one way to represent certain kinds of information "
"associated with an instance or a class. This section introduces the concept "
"of a shared slot and discusses the pros and cons of representing information "
"in slots versus in methods."
msgstr ""
"CLOS поддерживает несколько способов представления определенных видов"
" информации, связанных с экземпляром или классом. В этом разделе вводится"
" концепция общего(для всех экземпляров класса) слота и обсуждаются плюсы и"
" минусы представления информации в слотах по сравнению с методами."

#: ./en/ch04.md:19
msgid "### Local and Shared Slots"
msgstr "### Локальные и общие(Shared) слоты"

#: ./en/ch04.md:21
msgid ""
"There are two kinds of slots. A local slot stores information about the "
"state of a particular instance. Each instance maintains its individual copy "
"of the slot with its own value. This is the default kind of slot. All the "
"slots mentioned previously in this book are local slots."
msgstr ""
"Существует два вида слотов. Локальный слот хранит информацию о состоянии"
" конкретного экземпляра. Каждый экземпляр поддерживает свою индивидуальную"
" копию слота со своим собственным значением. Это тип слота по умолчанию. Все"
" слоты, упомянутые ранее в этой книге, являются локальными."

#: ./en/ch04.md:23
msgid ""
"A shared slot stores information on the state of the class as a whole. There "
"is only one value of a shared slot; it is associated with the class and "
"shared by all instances of the class. If one instance changes the value of "
"the shared slot, the new value will be seen by all instances if they read "
"the slot."
msgstr ""
"Общий слот хранит информацию о состоянии класса в целом. Существует только"
" одно значение общего слота; оно связано с классом и совместно используется"
" всеми экземплярами класса. Если один экземпляр изменяет значение общего"
" слота, новое значение будет видно всем экземплярам, если они прочитают слот."

#: ./en/ch04.md:25
msgid ""
"For example, we might define a class named triangle. Each instance stores "
"the length of its three sides in local slots named side-a, side-b, and side-"
"c. These must be local slots, so that each instance can keep track of its "
"own dimensions."
msgstr ""
"Например, мы могли бы определить класс с именем triangle. Каждый экземпляр"
" хранит длину своих трех сторон в локальных слотах с именами side-a, side-b и"
" side-c. Это должны быть локальные слоты, чтобы каждый экземпляр мог"
" отслеживать свои собственные измерения."

#: ./en/ch04.md:27
msgid ""
"Suppose the triangle class is one of several classes in a program that "
"handles geometric shapes. The shape protocol states that the generic "
"function number-of-sides returns the number of sides of a given shape. For "
"the triangle class, we can store that information in a shared slot named "
"number-of-sides and provide a reader method for it. A shared slot is "
"appropriate, because all instances of the triangle class have the same "
"number of sides."
msgstr ""
"Предположим, класс triangle является одним из нескольких классов в программе,"
" которая обрабатывает геометрические фигуры. Протокол shape(фигуры) гласит,"
" что обобщенная функция number-of-sides возвращает количество сторон заданной"
" фигуры. Для класса triangle мы можем сохранить эту информацию в общем слоте"
" с именем number-of-sides и предоставить для него метод считывания. Общий"
" слот подходит, поскольку все экземпляры класса triangle имеют одинаковое"
" количество сторон."

#: ./en/ch04.md:30
msgid ""
"![Figure 4.1: Local and shared slots.](images/f04-01.jpg)\n"
"**Figure 4.1: Local and shared slots.**"
msgstr ""
"![Рисунок 4.1: Локальные и общие слоты.](images/f04-01.jpg )"
"**Рисунок 4.1: Локальные и общие слоты.**"

#: ./en/ch04.md:32
msgid ""
"Figure 4.1 shows that each instance stores its individual values for the "
"local slots side-a, side-b, and side-c, but there is only a single value for "
"the shared slot number-of-sides. Local slots are stored inside each "
"instance, and shared slots are stored inside the class itself."
msgstr ""
"На рисунке 4.1 показано, что каждый экземпляр хранит свои индивидуальные"
" значения для локальных слотов side-a, side-b и side-c, но существует только"
" одно значение для общего количества сторон слота. Локальные слоты хранятся"
" внутри каждого экземпляра, а общие слоты хранятся внутри самого класса."

#: ./en/ch04.md:34
msgid ""
"The defclass form defines the slots and controls whether the slot is local "
"or shared. The :allocation slot option specifies whether a slot is local or "
"shared. The default is :allocation :instance, which means the slot is local. "
"To specify that a slot should be shared, you give the :allocation :class "
"slot option."
msgstr ""
"Форма defclass определяет слоты и управляет тем, является ли слот локальным"
" или общим. Параметр слота :allocation  указывает, является ли слот локальным"
" или общим. Значение по умолчанию равно :allocation :instance(экземпляр), что"
" означает, что слот является локальным. Чтобы указать, что слот должен быть"
" общим, вы указываете параметр :allocation :class."

#: ./en/ch04.md:36
msgid ""
"The following defclass form defines three local slots and one shared slot "
"for the triangle class:"
msgstr ""
"Следующая форма defclass определяет три локальных слота и один общий слот для"
" класса triangle:"

#: ./en/ch04.md:49
msgid ""
"<pre>\n"
"(defclass triangle (shape) \n"
"  ((side-a :accessor side-a\n"
"           :initarg :side-a) \n"
"   (side-b :accessor side-b\n"
"           :initarg :side-b) \n"
"   (side-c :accessor side-c\n"
"           :initarg :side-c) \n"
"   (number-of-sides :reader number-of-sides \n"
"                    :initform 3 \n"
"                    :allocation :class))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:51
msgid ""
"The reader number-of-sides can be used on any instance of triangle. The "
"reader method returns the value of the slot named number-of-sides, which is "
"shared by all instances of the triangle class."
msgstr ""
"Считыватель number-of-sides может быть использован для любого экземпляра"
" triangle(треугольника). Метод reader возвращает значение слота с именем"
" number-of-sides, которое является общим для всех экземпляров класса triangle."

#: ./en/ch04.md:54
msgid ""
"### Useful Triangle Functions \n"
"In the examples that follow, we label each angle of the triangle according "
"to its opposite side. Angle-A is opposite side-a, and adjacent to side-b and "
"side-c. Figure 4.2 shows how the angles and sides are related to one "
"another. Figure 4.2 Angles and sides of a triangle. Here we define two "
"useful functions for dealing with triangles, which we use in the examples "
"that follow: "
msgstr ""
"### Полезные функции Triangle(Треугольника)\n"
"В следующих примерах мы обозначаем каждый угол треугольника в соответствии с"
" его противоположной стороной. Angle-A(Угол-A) является противоположной"
" side-a(стороной-a) и примыкает к side-b(стороне-b) и side-c(стороне-c). На"
" рисунке 4.2 показано, как углы и стороны связаны друг с другом. Рисунок 4.2"
" Углы и стороны треугольника. Здесь мы определяем две полезные функции для"
" работы с треугольниками, которые мы используем в следующих примерах:"

#: ./en/ch04.md:57
msgid ""
"![Figure 4.2: Angles and sides of a triangles.](images/f04-02.jpg)\n"
"**Figure 4.2: Angles and sides of a triangles.**"
msgstr ""
"![Рисунок 4.2: Углы и стороны треугольника.](images/f04-02.jpg )"
"**Рисунок 4.2: Углы и стороны треугольника.**"

#: ./en/ch04.md:64
msgid ""
"<pre>\n"
";;; Return the area of a triangle, given three sides. \n"
";;; Algorithm is: area - ab(sin C)/2 \n"
"(defun area-of-triangle (a b c) \n"
"   (let ((angle-C (three-sides-to-angle c a b))) \n"
"      (* a b (sin angle-C) .5)))"
msgstr ""

#: ./en/ch04.md:73
msgid ""
";;; Return the angle A between adjacent sides b and c \n"
";;; and opposite side a, given all sides of a triangle \n"
";;; Law of Cosines: aA2 - bA2 + cA2 - 2bc(cos A) \n"
"(defun three-sides-to-angle (a b c) \n"
"   (acos (/ (- (+ (expt b 2) (expt c 2)) \n"
"               (expt a 2)) \n"
"            (* 2 b c)))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:75
msgid ""
"We expand on the triangle example in \"Example of Redefining CLOS Elements,\""
" page 144."
msgstr ""
"Мы подробно остановимся на примере треугольника в разделе \"Пример"
" переопределения элементов CLOS\", стр. 144."

#: ./en/ch04.md:77
msgid "### Representing Information About an Instance"
msgstr "### Представление информации Об Экземпляре"

#: ./en/ch04.md:79
msgid ""
"In the shape program, we might need to determine the area of a given shape. "
"There are two ways to represent the area of a shape: calculate it in a "
"method, or store the area in a local slot. For example, here are the ways to "
"represent the area of a triangle:"
msgstr ""
"В программе shape нам может потребоваться определить площадь заданной"
" фигуры(area). Существует два способа представления площади фигуры: вычислить"
" ее с помощью метода или сохранить площадь в локальном слоте. Например, вот"
" способы представления площади треугольника:"

#: ./en/ch04.md:82
msgid ""
"\t > Method                    Define a method that calculates the area "
"based on the\n"
"\t >                           lengths of the sides of the triangle. "
msgstr ""
"\t > Метод                     Определите метод, который вычисляет площадь на"
" основе\n"
"\t >                               длин сторон треугольника."

#: ./en/ch04.md:91
msgid ""
"<pre>\n"
"(defmethod area ((tri triangle)) \n"
"   (area-of-triangle (side-a tri) \n"
"                     (side-b tri) \n"
"                     (side-c tri))) \n"
"</pre>\n"
"\t>Local slot                 Define a local slot named area that stores the "
"area of \n"
"\t>                           each triangle and a reader method for the "
"slot. "
msgstr ""
"<pre>\n"
"(defmethod area ((tri triangle)) \n"
"   (area-of-triangle (side-a tri) \n"
"                     (side-b tri) \n"
"                     (side-c tri))) \n"
"</pre>\n"
"\t>Локальный слот             Определите локальный слот с именем area, в"
" котором\n"
"\t>                                      хранится площадь каждого"
" треугольника и метод считывания\n"
"\t>                                      для этого слота."

#: ./en/ch04.md:102
msgid ""
"<pre>\n"
"(defclass triangle (shape) \n"
"  ((side-a :accessor side-a :initarg :side-a) \n"
"   (side-b :accessor side-b :initarg :side-b) \n"
"   (side-c :accessor side-c :initarg :side-c) \n"
"   (number-of-sides :reader number-of-sides \n"
"                    :initform 3 \n"
"                    :allocation :class) \n"
"   (area :reader area :initarg :area))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:106
msgid ""
"\t>                          We must calculate the area when the triangle is "
"first \n"
"\t>                          created. One effective way to do this is to "
"define a con- \n"
"\t>                          structor called make-triangle, which "
"initializes the area: "
msgstr ""
"\t>                          Мы должны вычислить площадь при первом создании\n"
"\t>                          треугольника. Один из эффективных способов"
" сделать это\n"
"\t>                          - определить конструктор с именем make-triangle,"
" который\n"
"\t>                          инициализирует area:"

#: ./en/ch04.md:116
msgid ""
"<pre>\n"
"(defun make-triangle (side-a side-b side-c) \n"
"   (make-instance 'triangle \n"
"                  :side-a side-a \n"
"                  :side-b side-b \n"
"                  :side-c side-c \n"
"                  :area (area-of-triangle \n"
"                         side-a side-b side-c))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:122
msgid ""
"\t>                          Since many programs need to do initialization "
"such as \n"
"\t>                          this, CLOS provides a technique especially "
"intended for \n"
"\t>                          this purpose, called initialization methods; we "
"discuss \n"
"\t>                          them in \"Controlling Initialization with "
"Methods,\" page \n"
"\t>                          159. "
msgstr ""
"\t>                          Поскольку многим программам необходимо"
" выполнять\n"
"\t>                          инициализацию, подобную этой, CLOS предоставляет"
" технику,\n"
"\t>                          специально предназначенную для этой цели,"
" называемую\n"
"\t>                          методами инициализации; мы обсуждаем их в"
" разделе\n"
"\t>                          \"Управление инициализацией с помощью методов\","
" стр. 159."

#: ./en/ch04.md:126
msgid ""
"\t>                          It is also necessary to recalculate the area "
"whenever any \n"
"\t>                          of the side lengths change, which we "
"demonstrate in \n"
"\t>                          \"Defining Auxiliary Methods for Accessors,\" "
"page 71. "
msgstr ""
"\t>                          Также необходимо пересчитывать площадь всякий"
" раз, когда\n"
"\t>                          изменяется какая-либо из длин сторон, что мы"
" демонстрируем\n"
"\t>                          в разделе \"Определение вспомогательных методов"
" для средств\n"
"\t>                          доступа(Accessors)\", стр. 71."

#: ./en/ch04.md:128
msgid ""
"Regardless of which implementation choice you make, the client gets the area "
"the same way: by calling the area generic function. The choice of internal "
"representation is up to the programmer. The effects of using a method to "
"calculate the area each time are that: less storage space is needed and "
"object-creation and updating of the side length are faster, but the area "
"query is slower. The effects of storing the area in a slot are that: the "
"area query is faster, but more storage space might be needed, and object-"
"creation and updating of the side length are slower."
msgstr ""
"Независимо от того, какой выбор реализации вы сделаете, клиент получает area"
" одним и тем же способом: вызывая обобщенную функцию area. Выбор внутреннего"
" представления остается за программистом. Эффект от использования метода для"
" вычисления площади каждый раз таков: требуется меньше места для хранения, а"
" создание объекта и обновление длины стороны выполняются быстрее, но запрос"
" площади(area) выполняется медленнее. Эффекты хранения площади(area) в слоте"
" таковы: запрос  area выполняется быстрее, но может потребоваться больше"
" места для хранения, а создание объекта и обновление длины стороны"
" выполняются медленнее."

#: ./en/ch04.md:130
msgid "### Representing Information About a Class"
msgstr "### Представление информации О Классе"

#: ./en/ch04.md:132
msgid ""
"We have already mentioned the need to represent information associated with "
"a class, such as the number of sides of triangles. CLOS offers two ways to "
"do this:"
msgstr ""
"Мы уже упоминали о необходимости представления информации, связанной с"
" классом, такой как количество сторон треугольников. CLOS предлагает два"
" способа сделать это:"

#: ./en/ch04.md:136
msgid ""
"   \t> Method                    Define a method that returns the "
"information. The \n"
"\t>                           number of sides is \"stored\" only in the "
"method body and \n"
"\t>                           not in a slot. "
msgstr ""
"\t> Метод                Определите метод, который возвращает информацию.\n"
"\t>                           Количество сторон \"хранится\" только в теле"
" метода, а не\n"
"\t>                           в слоте."

#: ./en/ch04.md:141
msgid ""
"<pre>\n"
"(defmethod number-of-sides ((tri triangle))\n"
"   3) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:147
msgid ""
"\t> Shared slot               Define a shared slot and a reader method for "
"the generic \n"
"\t>                           function number-of-sides. The two defclass "
"forms for \n"
"\t>                           triangle given earlier show how to define a "
"shared slot \n"
"\t>                           (use the :allocation :class slot option) and a "
"reader \n"
"\t>                           method (specify the :reader number-of-sides "
"slot option). "
msgstr ""
"\t> Общий слот                Определите общий слот и метод считывания для"
" обобщенной\n"
"\t>                                   функции number-of-sides. Две формы"
" defclass для triangle,\n"
"\t>                                   приведенные ранее, показывают, как"
" определить общий слот\n"
"\t>                                   (используйте параметр слота :allocation"
" :class) и метод\n"
"\t>                                   считывания (укажите параметр слота"
" :reader number-of-sides\n"
"\t>                                   с числом сторон считывателя)."

#: ./en/ch04.md:150
msgid ""
"Here the tradeoff is between speed of the query and the convenience of "
"updating the information associated with the class. When a method stores the "
"information, the query is probably faster, because no slot access is "
"required. This technique might also save storage space, since the "
"information is stored in one method, rather than in a slot and a reader \n"
"method. However, the only way to change the information is to redefine the "
"method. This approach works, but it requires programming (locating the "
"method's definition, editing it, and compiling it), rather than just using a "
"program (calling a writer generic function). In some applications, you can "
"reasonably assume that the information associated with a class will never "
"change, so updating is not a problem. For example, we know that the number "
"of sides of a triangle will always be 3, and there is no need ever to update "
"that information. In other contexts, however, the information associated "
"with the class might need to be changed. "
msgstr ""
"Здесь компромисс заключается между скоростью запроса и удобством обновления"
" информации, связанной с классом. Когда метод хранит информацию, запрос,"
" вероятно, выполняется быстрее, поскольку доступ к слоту не требуется. Этот"
" метод также может сэкономить место для хранения, поскольку информация"
" хранится одним способом, а не в слоте и способе считывания. Однако"
" единственный способ изменить информацию - это переопределить метод. Этот"
" подход работает, но он требует программирования (нахождения определения"
" метода, его редактирования и компиляции), а не просто использования"
" программы (вызова обобщенной функции writer). В некоторых приложениях вы"
" можете разумно предположить, что информация, связанная с классом, никогда не"
" изменится, поэтому обновление не является проблемой. Например, мы знаем, что"
" количество сторон треугольника всегда будет равно 3, и нет необходимости"
" когда-либо обновлять эту информацию. Однако в других контекстах может"
" потребоваться изменить информацию, связанную с классом."

#: ./en/ch04.md:152
msgid ""
"When the information is stored in a shared slot, you can conveniently change "
"it by using a writer generic function. However (depending on the CLOS "
"implementation), the query might be slower and more storage space might be "
"used."
msgstr ""
"Когда информация хранится в общем слоте, вы можете удобно изменить ее,"
" используя обобщенную функцию записи. Однако (в зависимости от реализации"
" CLOS) запрос может выполняться медленнее и может использоваться больше места"
" для хранения."

#: ./en/ch04.md:154
msgid "## 4.2 PROGRAMMING WITH ACCESSORS "
msgstr "## 4.2 ПРОГРАММИРОВАНИЕ С ПОМОЩЬЮ СРЕДСТВ ДОСТУПА(ACCESSORS)"

#: ./en/ch04.md:156
msgid ""
"This section describes how to modify the behavior of an accessor generic "
"function and discusses the various ways to access slots. "
msgstr ""
"В этом разделе описывается, как изменить поведение обобщенной функции"
" доступа, и обсуждаются различные способы доступа к слотам."

#: ./en/ch04.md:158
msgid "### Automatically Generated Accessors "
msgstr "### Автоматически Сгенерированные Средства доступа(Accessors)"

#: ./en/ch04.md:160
msgid ""
"By giving the :accessor slot option to defclass, you ask CLOS to generate a "
"method for a reader generic function and a method for a writer generic "
"function. The reader method simply returns the value of the slot, and the "
"writer method writes a new value into the slot."
msgstr ""
"Предоставляя defclass параметр слота :accessor, вы просите CLOS сгенерировать"
" метод для обобщенной функции reader и метод для обобщенной функции writer."
" Метод reader просто возвращает значение слота, а метод writer записывает"
" новое значение в слот."

#: ./en/ch04.md:162
msgid ""
"These are primary methods that behave just like any other primary method, "
"which means you can write auxiliary methods to perform additional "
"computation. That is, you can define be fore-methods and after-methods to "
"augment the behavior of primary methods for reader and writer generic "
"functions. "
msgstr ""
"Это первичные методы, которые ведут себя так же, как и любой другой первичный"
" метод, что означает, что вы можете написать вспомогательные методы для"
" выполнения дополнительных вычислений. То есть вы можете определить методы"
" before и after, чтобы улучшить поведение первичных методов для обобщенных"
" функций reader и writer."

#: ./en/ch04.md:164
msgid "### Defining Auxiliary Methods for Accessors"
msgstr "### Определение вспомогательных методов для средств доступа(Accessors)"

#: ./en/ch04.md:166
msgid ""
"Here we continue to use the triangle example. Recall that the definition of "
"the triangle class gives the : accessor slot option to generate methods for "
"a reader named side-a and the corresponding writer named (setf side-a)."
msgstr ""
"Здесь мы продолжаем использовать пример с треугольником(triangle). Напомним,"
" что определение класса triangle предоставляет опцию слота :accessor для"
" генерации методов для устройства чтения с именем side-a и соответствующего"
" устройства записи с именем (setf side-a)."

#: ./en/ch04.md:168
msgid ""
"Earlier, we mentioned the possibility of storing the area of a triangle in a "
"slot and recalculating the area every time a side length of the triangle "
"changes. To use this approach, we need a method to run every time a new "
"value is stored in any of the slots side-a, side-b, or side-c. We can do "
"this by defining after-methods for the writer generic functions (setf side-a)"
", (setf side-b), and (setf side-c)."
msgstr ""
"Ранее мы упоминали о возможности сохранения площади треугольника в слоте и"
" пересчета площади каждый раз, когда изменяется длина стороны треугольника."
" Чтобы использовать этот подход, нам нужен метод, который будет выполняться"
" каждый раз, когда новое значение сохраняется в любом из слотов side-a,"
" side-b или side-c. Мы можем сделать это, определив after-методы для"
" обобщенной функций writer (setf side-a), (setf side-b) и (setf side-c)."

#: ./en/ch04.md:171
msgid ""
"You can use defmethod to write an auxiliary method for a reader generic "
"function or a writer generic function. The first argument is the name of the "
"generic function, which for a reader is a symbol, and for a writer is a list "
"such as (setf symbol). In methods for writer generic functions, the first "
"parameter in the lambda-list is the parameter for the \n"
"new value to be written into the slot. For example:"
msgstr ""
"Вы можете использовать defmethod для написания вспомогательного метода для"
" обобщенной функции reader или обобщенной функции writer. Первый аргумент -"
" это имя обобщенной функции, которое для читателя является символом, а для"
" записи - списком, таким как (setf symbol). В методах для обобщенной функций"
" записи первый параметр в лямбда-списке является параметром для нового"
" значения, которое будет записано в слот. Например:"

#: ./en/ch04.md:179
msgid ""
"<pre>\n"
"(defmethod (setf side-a) :after (new-length (tri triangle)) \n"
"   (setf (area tri) \n"
"         (area-of-triangle new-length \n"
"                           (side-b tri) \n"
"                           (side-c tri)))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:181
msgid ""
"This is an after-method, which runs after the primary method for (setf "
"side-a). This method calculates the area of the triangle and stores it in "
"the area slot every time the writer function (setf side-a) is called. We "
"would need to write similar after-methods for (setf side-b) and (setf side-c)"
" to ensure that the area is updated whenever any of the side lengths change. "
msgstr ""
"Это after-метод, который выполняется после основного метода для (setf"
" side-a). Этот метод вычисляет площадь треугольника и сохраняет ее в слоте"
" area каждый раз, когда вызывается функция записи (setf side-a). Нам нужно"
" было бы написать аналогичные  after- методы для (setf side-b) и (setf"
" side-c), чтобы гарантировать, что area обновляется всякий раз, когда"
" изменяется какая-либо из длин сторон."

#: ./en/ch04.md:183
msgid "## Defining Primary Methods for Accessors "
msgstr "## Определение основных методов для средств доступа(Accessors)"

#: ./en/ch04.md:185
msgid ""
"The :accessor, : reader, and :writer slot options are convenience features "
"of CLOS. You could implement primary methods for reading and writing a slot "
"yourself, by using defmethod. The body of a reader method would use the "
"primitive slot-value to read the value of the slot, where as a writer method "
"would use setf with slot-value."
msgstr ""
"Опции слотов :accessor, :reader и :writer являются удобными функциями CLOS."
" Вы могли бы реализовать основные методы для чтения и записи слота"
" самостоятельно, используя defmethod. Тело метода чтения будет использовать"
" примитивное значение слота для считывания значения слота, где в качестве"
" метода записи будет использоваться setf со значением слота."

#: ./en/ch04.md:187
msgid ""
"For example, in our previous definition for the triangle class, we gave the :"
"accessor option to define a reader and writei' for side-a. Alternatively, we "
"could define primary methods for the readers and writers by hand. "
msgstr ""
"Например, в нашем предыдущем определении для класса triangle мы дали параметр"
" :accessor для определения reader и writer для side-a. В качестве"
" альтернативы, мы могли бы вручную определить основные методы для читателей и"
" авторов."

#: ./en/ch04.md:192
msgid ""
"<pre>\n"
";;; Defining the reader side-a \n"
"(defmethod side-a ((tri triangle)) \n"
"   (slot-value tri 'side-a)) "
msgstr ""

#: ./en/ch04.md:197
msgid ""
";;; Defining the writer (setf side-a) \n"
"(defmethod (setf side-a) (new-side-a (tri triangle)) \n"
"   (setf (slot-value tri 'side-a) new-side-a))\n"
"</pre>"
msgstr ""

#: ./en/ch04.md:199
msgid ""
"Usually, there is no advantage to defining a primary method of an accessor "
"by hand, because in almost all cases you want the primary method simply to "
"read or write the value of the slot. When you need to do something special, "
"you can provide a before-method or after-method to work in conjunction with "
"the primary method, rather than providing a special-purpose primary method."
msgstr ""
"Обычно нет никакого преимущества в определении основного метода средства"
" доступа вручную, потому что почти во всех случаях вы хотите, чтобы основной"
" метод просто считывал или записывал значение слота. Когда вам нужно сделать"
" что-то особенное, вы можете предоставить метод \"до\"(before-) или"
" \"после\"(after-) для работы в сочетании с основным методом, вместо"
" предоставления специального основного метода."

#: ./en/ch04.md:201
msgid "### Accessors Versus slot-value"
msgstr "### Средства доступа(Accessors) против slot-value"

#: ./en/ch04.md:203
msgid ""
"The implementation of primary methods for accessors (regardless of whether "
"the method is automatically generated by CLOS or is defined by hand) is done "
"in terms of slot-value. You can read the value of any slot with slot-value, "
"and you can write the value of a slot by using setf with slot-value. It is "
"important to understand the difference between using slot-value and using an "
"accessor."
msgstr ""
"Реализация первичных методов для средств доступа(accessors) (независимо от"
" того, генерируется ли метод автоматически CLOS или определяется вручную)"
" выполняется в терминах slot-value(значения слота). Вы можете прочитать"
" значение любого слота с помощью slot-value, и вы можете записать значение"
" слота, используя setf с помощью slot-value. Важно понимать разницу между"
" использованием slot-value(значения слота) и использованием средства"
" доступа(accessor)."

#: ./en/ch04.md:205
msgid ""
"Clients of a program are expected to use accessors to read and write slots, "
"because the accessors are usually the advertised interface. In contrast, "
"slot-value is the underlying implementation of accessors and is not intended "
"to be used in other contexts. To call slot-value, you need to know the name "
"of the slot, which is strictly an internal detail of the program. Consider "
"what happens if the developer changes the internal representation of that "
"information by changing the name of the slot or by storing the information "
"in a method instead of a slot: presumably the developer defines new methods "
"for the generic functions to replace the accessor methods, so callers of the "
"advertised generic functions continue to work. However, any callers of slot-"
"value for that slot will be invalidated."
msgstr ""
"Ожидается, что клиенты программы будут использовать средства"
" доступа(accessors) для чтения и записи слотов, поскольку средства доступа"
" обычно являются рекламируемым(объявляемым) интерфейсом. Напротив, slot-value"
" является базовой реализацией средств доступа и не предназначен для"
" использования в других контекстах. Чтобы вызвать slot-value, вам необходимо"
" знать название слота, которое является строго внутренней деталью программы."
" Рассмотрим, что произойдет, если разработчик изменит внутреннее"
" представление этой информации, изменив имя слота или сохранив информацию в"
" методе вместо слота: предположительно, разработчик определяет новые методы"
" для обобщенных функций, чтобы заменить методы доступа, поэтому вызывающие"
" объявленные обобщенные функции продолжают работать. Однако любые вызывающие"
" slot-value для этого слота будут признаны недействительными."

#: ./en/ch04.md:207
msgid ""
"slot-value accesses the slot directly, without calling any accessor methods. "
"This is a disadvantage if the program depends on accessor methods to do "
"necessary work related to accessing the slot. Recall that the triangle "
"example uses after-methods for the writers of the side length slots to "
"update the area; if you use setf of slot-value to write the value of a side "
"length, the value of the area slot will be incorrect because no accessor "
"methods will be called. "
msgstr ""
"slot-value обращается к слоту напрямую, без вызова каких-либо методов"
" доступа. Это является недостатком, если программа зависит от методов доступа"
" для выполнения необходимой работы, связанной с доступом к слоту. Напомним,"
" что в примере треугольника используются after-методы для записи слотов длины"
" стороны для обновления области; если вы используете setf из slot-value для"
" записи значения длины стороны, значение слота области будет неверным,"
" поскольку методы доступа не будут вызваны."

#: ./en/ch04.md:209
msgid ""
"You should use slot-value for two purposes: if you want to define an "
"accessor by hand, or if you want to access a slot without calling any "
"accessor methods. The latter use of slot-value can be helpful when debugging "
"a program."
msgstr ""
"Вы должны использовать slot-value для двух целей: если вы хотите определить"
" средство доступа вручную или если вы хотите получить доступ к слоту без"
" вызова каких-либо методов доступа. Последнее использование slot-value может"
" быть полезно при отладке программы."

#: ./en/ch04.md:211
msgid "### Using with-accessors and with-slots"
msgstr "### Использование with-accessors и with-slots"

#: ./en/ch04.md:213
msgid ""
"Another way to access slots is to use with-accessors or with-slots, two "
"macros that allow you to access slots by using variable names. Within the "
"body of with-accessors, using the variable has the same effect as calling "
"the corresponding accessor generic function. In contrast, with-slots "
"translates use of the variable to a call to slot-value, so no accessor "
"methods are called."
msgstr ""
"Другой способ получить доступ к слотам - использовать with-accessors или"
" with-slots, два макроса, которые позволяют вам получать доступ к слотам с"
" помощью имен переменных. В теле with-accessors использование переменной"
" имеет тот же эффект, что и вызов соответствующей обобщенной функции"
" accessor. В отличие от этого, with-slots переводит использование переменной"
" в вызов slot-value, поэтому методы доступа не вызываются."

#: ./en/ch04.md:215
msgid ""
"The purpose of these macros is to simplify bodies of code that access slots "
"frequently, by supporting a shortcut syntax. Thus, using with-accessors is a "
"shortcut for calling the accessors, and using with-slots is a shortcut for "
"calling slot-value. Using these macros can result in more concise code, "
"especially when the bodies of the methods use either accessors or slot-value "
"frequently."
msgstr ""
"Цель этих макросов - упростить части кода, которые часто обращаются к слотам,"
" за счет поддержки синтаксиса быстрого доступа. Таким образом, использование"
" with-accessors - это ярлык для вызова средств доступа, а использование"
" with-slots - это ярлык для вызова slot-value. Использование этих макросов"
" может привести к более сжатому коду, особенно когда тела методов часто"
" используют либо средства доступа, либо значение слота."

#: ./en/ch04.md:217
msgid ""
"In the triangle example, we might need a method for returning angle A, which "
"is opposite to side a, and adjacent to sides b and c. Here, we show two "
"equivalent ways to access the sides."
msgstr ""
"В примере с треугольником нам может понадобиться метод для возврата угла A,"
" который противоположен стороне a и примыкает к сторонам b и c. Здесь мы"
" показываем два эквивалентных способа доступа к сторонам."

#: ./en/ch04.md:219
msgid "Calling the readers to get the sides:"
msgstr "Вызываем читателей чтобы получить сторону:"

#: ./en/ch04.md:226
msgid ""
"<pre>\n"
"(defmethod angle-A ((tri triangle)) \n"
"   (three-sides-to-angle (side-a tri) \n"
"                         (side-b tri) \n"
"                         (side-c tri))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:228
msgid "Using with-accessors to get the sides: "
msgstr "Используем with-accessors, чтобы получить стороны:"

#: ./en/ch04.md:237
msgid ""
"<pre>\n"
"(defmethod angle-A ((tri triangle)) \n"
"   (with-accessors ((a side-a) \n"
"                    (b side-b) \n"
"                    (c side-c)) \n"
"       tri \n"
"      (three-sides-to-angle a b c))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:239
msgid ""
"You can also write the value of a slot by using setq or setf with the "
"variable. The following table shows how variables can be used in the body of "
"the with-accessors form in method shown: "
msgstr ""
"Вы также можете записать значение слота, используя setq или setf с"
" переменной. В следующей таблице показано, как переменные могут быть"
" использованы в теле формы with-accessors в показанном методе:"

#: ./en/ch04.md:246
msgid ""
"| This Form         | Translates to This Form  |\n"
"|-------------------|--------------------------|\n"
"|    a              | (side-a tri)             |\n"
"| (setq a value)    | (setf (side-a tri) value)|\n"
"| (setf a value)    | (setf (side-a tri) value)|"
msgstr ""

#: ./en/ch04.md:248
msgid ""
"The with-accessors macro requires you to specify a variable (such as a) for "
"each accessor (such as side-a). Although you can specify that the variable "
"should be the same symbol as the accessor, there is no brief syntax for it; "
"you always have to list both the variable and the accessor names."
msgstr ""
"Макрос with-accessors требует, чтобы вы указали переменную (например, a) для"
" каждого аксессуара (например, side-a). Хотя вы можете указать, что"
" переменная должна иметь тот же символ, что и средство доступа, для этого не"
" существует краткого синтаксиса; вам всегда нужно перечислять имена как"
" переменной, так и средства доступа."

#: ./en/ch04.md:250
msgid ""
"The with-slots macro does have a brief syntax: You list the slots you want "
"to access, and then you can access them by their names. Here we show two "
"equivalent ways to access the slots directly—calling slot-value and using "
"with-slots:"
msgstr ""
"Макрос with-slots имеет краткий синтаксис: вы перечисляете слоты, к которым"
" хотите получить доступ, а затем можете получить к ним доступ по их именам."
" Здесь мы показываем два эквивалентных способа прямого доступа к слотам —"
" вызов slot-value и использование with-slots:"

#: ./en/ch04.md:257
msgid ""
"<pre>\n"
";;; Using slot-value to access the slots \n"
"(defmethod angle-A ((tri triangle)) \n"
"   (three-sides-to-angle (slot-value tri 'side-a) \n"
"                         (slot-value tri 'side-b) \n"
"                         (slot-value tri 'side-c))) "
msgstr ""

#: ./en/ch04.md:264
msgid ""
";;; Using with-slots to access the slots \n"
"(defmethod angle-A ((tri triangle)) \n"
"   (with-slots (side-a side-b side-c) \n"
"       tri \n"
"      (three-sides-to-angle side-a side-b side-c))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:266
msgid ""
"The following table shows how variables can be used in the body of the with-"
"slots form in the method shown:"
msgstr ""
"В следующей таблице показано, как переменные могут быть использованы в теле"
" формы with-slots в показанном методе:"

#: ./en/ch04.md:272
msgid ""
"|  This Form     | Translates to This Form              |\n"
"|----------------|--------------------------------------|\n"
"|   a            | (slot-value tri 'side-a)             |\n"
"| (setq a value) | (setf (slot-value tri 'side-a) value)|\n"
"| (setf a value) | (setf (slot-value tri 'side-a) value)|"
msgstr ""
"| Эта форма      | Переводится в эту форму             \n"
"|----------------|--------------------------------------|\n"
"|   a            | (slot-value tri 'side-a)             |\n"
"| (setq a value) | (setf (slot-value tri 'side-a) value)|\n"
"| (setf a value) | (setf (slot-value tri 'side-a) value)|"

#: ./en/ch04.md:274
msgid ""
"Note that, when you use with-slots or with-accessors, the instance form gets "
"evaluated only once. "
msgstr ""
"Обратите внимание, что при использовании with-slots или with-accessors форма"
" экземпляра оценивается только один раз."

#: ./en/ch04.md:276
msgid "### Beading Unbound Slots"
msgstr "### Донастройка поведения несвязанных слотов"

#: ./en/ch04.md:278
msgid ""
"If a slot is not initialized, and no value has been stored in it by means of "
"a writer, the slot is unbound. If you try to read the value of an unbound "
"slot, an error is signaled."
msgstr ""
"Если слот не инициализирован, и никакое значение не было сохранено в нем с"
" помощью записи, слот не привязан. Если вы попытаетесь прочитать значение"
" несвязанного слота, будет выдан сигнал об ошибке."

#: ./en/ch04.md:280
msgid ""
"The default behavior (signaling an error) is supported by the generic "
"function slot-unbound. That is, if you try to read an unbound slot, CLOS "
"calls the exception handler slot-unbound. The generic function slot-unbound "
"has a system-supplied default method that signals an error; you can "
"specialize this generic function if you want to change what happens when "
"unbound slots are read in instances of a certain class."
msgstr ""
"Поведение по умолчанию (сигнализация об ошибке) поддерживается обобщенной"
" функцией slot-unbound. То есть, если вы пытаетесь прочитать несвязанный"
" слот, CLOS вызывает обработчик исключений slot-unbound. Обобщенная функция"
" slot-unbound имеет системный метод по умолчанию, который сигнализирует об"
" ошибке; вы можете специализировать эту обобщенную функцию, если хотите"
" изменить то, что происходит, когда несвязанные слоты считываются в"
" экземплярах определенного класса."

#: ./en/ch04.md:282
msgid "## 4.3 MULTI-METHODS"
msgstr "## 4.3 МУЛЬТИМЕТОДЫ"

#: ./en/ch04.md:284
msgid ""
"Many object-oriented programs can be written with methods that specialize "
"only one parameter. However, sometimes it is useful to write methods that "
"specialize more than one parameter. These are called multi-methods."
msgstr ""
"Многие объектно-ориентированные программы могут быть написаны с"
" использованием методов, которые специализируются только на одном параметре."
" Однако иногда полезно писать методы, которые специализируются более чем на"
" одном параметре. Они называются мультиметодами."

#: ./en/ch04.md:286
msgid ""
"The technique of using multi-methods is intended for operations whose "
"implementation truly depends on the type of more than one argument."
msgstr ""
"Техника использования мультиметодов предназначена для операций, реализация"
" которых действительно зависит от типа более чем одного аргумента."

#: ./en/ch04.md:288
msgid ""
"We introduce multi-methods by discussing an installation scenario. Suppose a "
"company sells various software products, each of which can run on a variety "
"of operating systems. The installation procedure depends on the type of the "
"software product and on the type of the operating system. This company wants "
"to provide a generic installation program to automate the installation "
"process."
msgstr ""
"Мы вводим несколько методов, обсуждая сценарий инициализации. Предположим,"
" компания продает различные программные продукты, каждый из которых может"
" работать на различных операционных системах. Процедура установки зависит от"
" типа программного продукта и от типа операционной системы. Эта компания"
" хочет предоставить универсальную программу установки для автоматизации"
" процесса установки."

#: ./en/ch04.md:290
msgid ""
"Currently, the company supports two software products, Life and Adventure, "
"on two operating systems, Genera and Unix. The company plans to support "
"additional software products and operating systems in the future, so the "
"installation program should be extensible. In this example, we use the "
"following representation of the software products and operating systems:"
msgstr ""
"В настоящее время компания поддерживает два программных продукта, Life и"
" Adventure, в двух операционных системах, Genera и Unix. Компания планирует"
" поддерживать дополнительные программные продукты и операционные системы в"
" будущем, поэтому программа установки должна быть расширяемой. В этом примере"
" мы используем следующее представление программных продуктов и операционных"
" систем:"

#: ./en/ch04.md:295
msgid ""
"*   The software products are represented by the classes life and adventure "
"\n"
"*   All software products are built on the class basic-product \n"
"*   The operating systems are represented by the classes genera and unix \n"
"*   All operating systems are built on the class basic-os "
msgstr ""
"* Программные продукты представлены классами life и adventure\n"
"* Все программные продукты построены на классе basic-product\n"
"* Операционные системы представлены классами genera и unix\n"
"* Все операционные системы построены на классе basic-os"

#: ./en/ch04.md:297
msgid "### Checking Arguments with Multi-Methods"
msgstr "### Проверка аргументов с помощью мультиметодов"

#: ./en/ch04.md:299
msgid ""
"We want to provide one top-level function for installing any of our "
"supported products on any of our supported operating systems. We can do this "
"with a generic function install, which expects a software product as its "
"first argument and an operating system as its second argument:"
msgstr ""
"Мы хотим предоставить одну функцию верхнего уровня для установки любого из"
" наших поддерживаемых продуктов в любую из поддерживаемых нами операционных"
" систем. Мы можем сделать это с помощью обобщенной функции install, которая"
" ожидает программный продукт в качестве первого аргумента и операционную"
" систему в качестве второго аргумента:"

#: ./en/ch04.md:304
msgid ""
"<pre>\n"
"(defgeneric install (software-product operating-system) \n"
"   (:documentation \"Installs software on the operating system.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:306
msgid ""
"Method 1 is applicable when both arguments are valid; that is, the first "
"argument is of the type basic-product, and the second argument is of the "
"type basic-os:"
msgstr ""
"Метод 1 применим, когда оба аргумента допустимы; то есть первый аргумент"
" имеет тип basic-product, а второй аргумент имеет тип basic-os:"

#: ./en/ch04.md:312
msgid ""
"<pre>\n"
";;; Method 1 \n"
"(defmethod install ((sw basic-product) (os basic-os)) \n"
"   body) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:314
msgid ""
"Method 1 is a multi-method; it specializes two parameters. This method is "
"applicable only when both arguments are valid. The body of this method will "
"perform an installation. (We leave the body of the method blank for now.)"
msgstr ""
"Метод 1 является мультиметодом; он специализируется на двух параметрах. Этот"
" метод применим только в том случае, если оба аргумента допустимы. Тело этого"
" метода выполнит инсталяцию. (Пока мы оставляем тело метода пустым.)"

#: ./en/ch04.md:316
msgid ""
"What if the user calls install with invalid arguments? That is, what if the "
"first argument is not a software product, or the second argument is not an "
"operating system, or both? CLOS will look for applicable methods, find none, "
"and signal an error along the lines of \"No applicable method.\""
msgstr ""
"Что делать, если пользователь вызывает install с недопустимыми аргументами?"
" То есть, что, если первый аргумент не является программным продуктом, или"
" второй аргумент не является операционной системой, или и то, и другое? CLOS"
" будет искать применимые методы, не найдет ни одного и выдаст сообщение об"
" ошибке типа \"Нет применимого метода\"."

#: ./en/ch04.md:318
msgid ""
"Such an error message does not make it clear whether the error was caused by "
"a bug in the program or by the wrong kind of input given by the user. For an "
"installation tool, we should give the user a more informative error message. "
"We can supply three methods to do this job. "
msgstr ""
"Такое сообщение об ошибке не дает понять, была ли ошибка вызвана ошибкой в"
" программе или неправильным типом ввода, введенного пользователем. Для"
" средства установки мы должны предоставить пользователю более информативное"
" сообщение об ошибке. Мы можем предложить три метода для выполнения этой"
" работы."

#: ./en/ch04.md:324
msgid ""
"<pre>\n"
";;; Method 2 \n"
"(defmethod install ((sw basic-product) non-os) \n"
"   (error \"Cannot install because ~A is not \n"
"a recognized operating system.\" non-os)) "
msgstr ""

#: ./en/ch04.md:329
msgid ""
";;; Method 3 \n"
"(defmethod install (non-product (os basic-os)) \n"
"   (error \"Cannot install because ~A is not a \n"
"recognized software product.\" non-product)) "
msgstr ""

#: ./en/ch04.md:337
msgid ""
";;; Method 4 \n"
"(defmethod install (non-product non-os) \n"
"   (error \"Cannot install because ~A is not a \n"
"recognized software product and -A is not \n"
"a recognized operating system.\" \n"
"non-product non-os)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:339
msgid ""
"We intend that, for any pair of arguments, only one method is called. If "
"both arguments are valid, method 1 should be called to perform the "
"installation. Otherwise, the most appropriate method of methods 2, 3, and 4 "
"should be called, to give an informative message."
msgstr ""
"Мы предполагаем, что для любой пары аргументов вызывается только один метод."
" Если оба аргумента допустимы, для выполнения установки следует вызвать метод"
" 1. В противном случае следует вызвать наиболее подходящий метод из методов"
" 2, 3 и 4, чтобы выдать информативное сообщение."

#: ./en/ch04.md:341
msgid ""
"The methods are correctly written to fulfill their intended purposes. Since "
"they are all primary methods, we know that only the most specific applicable "
"method is called. CLOS selects that method by first finding the set of "
"applicable methods, and then ranking these methods in order of precedence. "
"The next two sections discuss the applicability and precedence order of "
"multi-methods."
msgstr ""
"Методы правильно написаны для выполнения их предполагаемых целей. Поскольку"
" все они являются первичными методами, мы знаем, что вызывается только"
" наиболее конкретный применимый метод. CLOSE выбирает этот метод, сначала"
" находя набор применимых методов, а затем ранжируя эти методы в порядке"
" приоритета. В следующих двух разделах обсуждается применимость и порядок"
" приоритета мультиметодов."

#: ./en/ch04.md:343
msgid "### Applicability of Multi-Methods"
msgstr "### Применимость Мульти-методов"

#: ./en/ch04.md:345
msgid ""
"CLOS allows methods for the same generic function to specialize any of the "
"required parameters. The methods for install take advantage of that "
"flexibility:"
msgstr ""
"CLOS позволяет методам для одной и той же обобщенной функции специализировать"
" любой из требуемых параметров. Методы установки используют преимущества этой"
" гибкости:"

#: ./en/ch04.md:352
msgid ""
"| Method     |  Lambda-list                      |\n"
"|------------|-----------------------------------|\n"
"| Method 1   | ((sw basic-product) (os basic-os))|\n"
"| Method 2   | ((sw basic-product) non-os)       |\n"
"| Method 3   | (non-product (os basic-os))       |\n"
"| Method 4   | (non-product non-os)              |"
msgstr ""

#: ./en/ch04.md:354
msgid ""
"When install is called, CLOS looks for the applicable methods. A method is "
"applicable if each specialized parameter is satisfied by the corresponding "
"argument to the generic function. \"Satisfied\" means that the argument is "
"of the type of the parameter specializer; it is an instance of the class "
"itself or an instance of a subclass."
msgstr ""
"Когда вызывается install, CLOS ищет применимые методы. Метод применим, если"
" каждому специализированному параметру удовлетворяет соответствующий аргумент"
" обобщенной функции. \"Удовлетворено\" означает, что аргумент имеет тип"
" специализатора параметра; это экземпляр самого класса или экземпляр"
" подкласса."

#: ./en/ch04.md:356
msgid ""
"An unspecialized parameter is equivalent to the class t being the parameter "
"specializer. Since all objects are of type t, an unspecialized parameter is "
"always satisfied by the argument. Thus, method 4 is applicable for any two "
"arguments, no matter what their types."
msgstr ""
"Неспециализированный параметр эквивалентен классу t, являющемуся"
" специализатором параметра. Поскольку все объекты имеют тип t, аргумент"
" всегда удовлетворяет неспециализированному параметру. Таким образом, метод 4"
" применим для любых двух аргументов, независимо от их типов."

#: ./en/ch04.md:358
msgid ""
"Suppose install is called with two valid arguments. Here, `*life*` is an "
"instance of life, and `*genera*` is an instance of genera. "
msgstr ""
"Предположим, что install вызывается с двумя допустимыми аргументами. Здесь"
" `*life*` - это экземпляр life, а `*general*` - это экземпляр general."

#: ./en/ch04.md:363
msgid ""
"<pre>\n"
";;; Here install is called with two valid arguments, \n"
"(install *life* *genera*) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:365
msgid "Both methods 1 and 2 are applicable, as seen by the following tests: "
msgstr "Оба метода 1 и 2 применимы, как видно из следующих тестов:"

#: ./en/ch04.md:374
msgid ""
"<pre>\n"
";;; Method 1 is applicable because these forms are true. \n"
"(typep *life* 'basic-product) \n"
"(typep *genera* 'basic-os) \n"
";;; Method 2 is applicable because these forms are true. \n"
"(typep *life* 'basic-product) \n"
"(typep *genera* 't) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:376
msgid "Similarly, methods 3 and 4 are applicable: "
msgstr "Аналогичным образом, применимы методы 3 и 4:"

#: ./en/ch04.md:385
msgid ""
"<pre>\n"
";;; Method 3 is applicable because these forms are true. \n"
"(typep *life* 't) \n"
"(typep *genera* 'basic-os) \n"
";;; Method 4 is applicable because these forms are true. \n"
"(typep *life* 't) \n"
"(typep *genera* 't) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:388
msgid ""
"Earlier, we stated that a method is applicable if each specialized parameter "
"is satisfied by the corresponding argument to the generic function. \n"
"This rule holds for multi-methods too. We can clarify this statement by "
"noting that all required parameters must be satisfied, and that any "
"unspecialized required parameters are treated as though they had the class "
"named t as their parameter specializers."
msgstr ""
"Ранее мы заявляли, что метод применим, если каждому специализированному"
" параметру удовлетворяет соответствующий аргумент обобщенной функции.\n"
"Это правило справедливо и для мультиметодов. Мы можем уточнить это"
" утверждение, отметив, что все требуемые параметры должны быть удовлетворены,"
" и что любые неспециализированные требуемые параметры обрабатываются так, как"
" если бы они имели класс с именем t в качестве специализаторов параметров."

#: ./en/ch04.md:395
msgid ""
"|    Rule of applicability of multi-methods:                            | \n"
"|-----------------------------------------------------------------------|\n"
"| A method is applicable if each of its required parameters is sat-     |\n"
"| isfied by the corresponding argument to the generic function.         |\n"
"| An unspecialized required parameter is equivalent to a parame-        |\n"
"| ter that specializes on the class named t.                            |"
msgstr ""
"| Правило применимости нескольких методов:                              |\n"
"|-----------------------------------------------------------------------|\n"
"| Метод применим, если каждому из его требуемых параметров удовлетворяет|\n"
"| соответствующий аргумент обобщенной  функции.                         |\n"
"| Неспециализированный обязательный параметр эквивалентен параметру,    |\n"
"| который специализируется на классе с именем t.                        |"

#: ./en/ch04.md:397
msgid ""
"When CLOS finds more than one applicable primary method, only the  most "
"specific one is called. Thus, CLOS must rank the applicable methods in order "
"of precedence. We continue this example and rank methods 1 through 4 in "
"order of precedence. "
msgstr ""
"Когда CLOS находит более одного применимого основного метода, вызывается"
" только самый конкретный из них. Таким образом, CLOS должны ранжировать"
" применимые методы в порядке приоритета. Мы продолжаем этот пример и"
" ранжируем методы с 1 по 4 в порядке приоритета."

#: ./en/ch04.md:399
msgid "### Precedence Order of Multi-Methods"
msgstr "### Порядок приоритета нескольких методов"

#: ./en/ch04.md:401
msgid ""
"CLOS ranks two applicable methods in order of precedence by considering the "
"required arguments of the method from left to right, with respect to their "
"parameter specializers. Mathematicians call this lexico-graphic order."
msgstr ""
"CLOS ранжирует два применимых метода в порядке приоритета, рассматривая"
" требуемые аргументы метода слева направо по отношению к их спецификаторам"
" параметров. Математики называют это лексико-графическим порядком."

#: ./en/ch04.md:403
msgid ""
"Here, we show the class of the parameter specializer of the first required "
"parameter, for the four methods:"
msgstr ""
"Здесь мы показываем класс специализатора параметров первого требуемого"
" параметра для четырех методов:"

#: ./en/ch04.md:410
msgid ""
"| Method   |First Parameter is Specialized by |\n"
"|----------|----------------------------------|\n"
"| Method 1 | basic-product                    |\n"
"| Method 2 | basic-product                    |\n"
"| Method 3 | t                                |\n"
"| Method 4 | t                                |"
msgstr ""
"| Метод    |Первый параметр специализирован на|\n"
"|----------|----------------------------------|\n"
"| Method 1 | basic-product                    |\n"
"| Method 2 | basic-product                    |\n"
"| Method 3 | t                                |\n"
"| Method 4 | t                                |"

#: ./en/ch04.md:412
msgid ""
"The class precedence list of the corresponding argument to the generic "
"function determines which of these classes is more specific. The class of "
"the first argument, *life*, is life, and its class precedence list is"
msgstr ""
"Список приоритетов классов соответствующего аргумента обобщенной функции"
" определяет, какой из этих классов является более специфичным. Класс первого"
" аргумента, *life*, - это life, а список приоритетов его класса -"

#: ./en/ch04.md:416
msgid ""
"<pre>\n"
"(life basic-product t) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:418
msgid ""
"Since basic-product is more specific than t, methods 1 and 2 are more "
"specific than methods 3 and 4. To rank the precedence of method 1 versus "
"method 2, CLOS proceeds to the next required parameter and compares the pair "
"of parameter specializers:"
msgstr ""
"Поскольку basic-product(базовый продукт) более специфичен, чем t, методы 1 и"
" 2 более специфичны, чем методы 3 и 4. Чтобы ранжировать приоритет метода 1"
" по сравнению с методом 2, CLOS переходит к следующему требуемому параметру и"
" сравнивает пару специфицирующих параметров:"

#: ./en/ch04.md:423
msgid ""
"| Method   | Second Parameter is Specialized by  |\n"
"|----------|-------------------------------------|\n"
"| Method 1 | basic-os                            |\n"
"| Method 2 | t                                   |"
msgstr ""
"| Метод    | Второй параметр специализирован на  |\n"
"|----------|-------------------------------------|\n"
"| Method 1 | basic-os                            |\n"
"| Method 2 | t                                   |"

#: ./en/ch04.md:425
msgid ""
"The class of the second argument, `*genera*`, is genera, and its class "
"precedence list is "
msgstr ""
"Класс второго аргумента, `*genera*`, является общим, и его список приоритетов"
" классов является"

#: ./en/ch04.md:429
msgid ""
"<pre>\n"
"(genera basic-os t) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:431
msgid ""
"Since basic-os is more specific than t, method 1 is more specific than "
"method 2. Using the same procedure, we find that method 3 is more specific "
"than method 4. Thus, the precedence order of the methods is (method-1 method-"
"2 method-3 method-4)"
msgstr ""
"Поскольку basic-os более специфичен, чем t, метод 1 более специфичен, чем"
" метод 2. Используя ту же процедуру, мы обнаруживаем, что метод 3 более"
" специфичен, чем метод 4. Таким образом, порядок приоритета методов таков"
" (метод-1 метод-2 метод-3 метод-4)"

#: ./en/ch04.md:433
msgid ""
"Just by looking at the lambda-lists of the methods, it probably feels right "
"that method 1 is the most specific (because it specializes both pa rameters)"
", and that method 4 is the least specific (because it does not specialize "
"either parameter). It is not intuitively obvious, however, which of methods "
"2 and 3 is more specific: "
msgstr ""
"Просто взглянув на лямбда-списки методов, вероятно, кажется правильным, что"
" метод 1 является наиболее специфичным (потому что он специализируется на"
" обоих параметрах), а метод 4 является наименее специфичным (потому что он не"
" специализируется ни на одном параметре). Однако интуитивно не очевидно,"
" какой из методов 2 и 3 является более конкретным:"

#: ./en/ch04.md:438
msgid ""
"|   Method  |   Lambda-list               |\n"
"|-----------|-----------------------------|\n"
"| Method 2  | ((sw basic-product) non-os) |\n"
"| Method 3  | (non-product (os basic-os)) |"
msgstr ""

#: ./en/ch04.md:440
msgid ""
"CLOS ranks method 2 as more specific than method 3 because of the left-to-"
"right order for comparing parameter specializers. That is, the order of the "
"parameters in the lambda-list affects the precedence of the methods. Since "
"the leftmost parameter specializer of method 2 is more specific than the "
"leftmost parameter specializer of method 3, method 2 is more specific than "
"method 3. The remaining parameter specializers are not considered."
msgstr ""
"CLOS оценивает метод 2 как более специфичный, чем метод 3, из-за порядка"
" сравнения спецификаторов параметров слева направо. То есть порядок"
" параметров в лямбда-списке влияет на приоритет методов. Поскольку"
" специализатор крайнего левого параметра метода 2 более специфичен, чем"
" специализатор крайнего левого параметра метода 3, метод 2 более специфичен,"
" чем метод 3. Остальные спецификаторы параметров не рассматриваются."

#: ./en/ch04.md:442
msgid ""
"The left-to-right precedence order of parameters is an arbitrary default. "
"You can change it by using the :argument-precedence-order option to "
"defgeneric; see \"Summary of Method Inheritance,\" page 98."
msgstr ""
"Порядок приоритета параметров слева направо является произвольным по"
" умолчанию. Вы можете изменить его, используя параметр"
" :argument-precedence-order на defgeneric; см. \"Краткое описание"
" наследования методов\", стр. 98."

#: ./en/ch04.md:444
msgid "### The Implementation of install"
msgstr "### Реализация install(установки)"

#: ./en/ch04.md:446
msgid ""
"Usually, the installation of a software product requires several distinct "
"steps, which must be performed in a certain order. We might find that all "
"installations consist of four separate steps:"
msgstr ""
"Обычно установка программного продукта требует нескольких отдельных шагов,"
" которые должны выполняться в определенном порядке. Мы могли бы обнаружить,"
" что все установки состоят из четырех отдельных этапов:"

#: ./en/ch04.md:451
msgid ""
"1.  Restoring the software from tape \n"
"2.  Compiling the software system \n"
"3.  Configuring the site to know about the new software \n"
"4.  Verifying the installation of the software product "
msgstr ""
"1. Восстановление программного обеспечения с ленты\n"
"2. Компиляция программной системы\n"
"3. Настройка сайта, чтобы узнать о новом программном обеспечении\n"
"4. Проверка установки программного продукта"

#: ./en/ch04.md:453
msgid ""
"We can implement install to call four generic functions. This framework "
"makes it convenient to write code in sharable modules."
msgstr ""
"Мы можем реализовать установку для вызова четырех обобщенных функций. Этот"
" фреймворк позволяет удобно писать код в совместно используемых модулях."

#: ./en/ch04.md:461
msgid ""
"<pre>\n"
"(defmethod install ((sw basic-product) (os basic-os)) \n"
"   (restore-product sw os) \n"
"   (compile-product sw os) \n"
"   (configure-site sw os) \n"
"   (verify-product sw os)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:463
msgid ""
"Here we consider what methods are needed for each of the four installation "
"operations. "
msgstr ""
"Здесь мы рассмотрим, какие методы необходимы для каждой из четырех операций"
" установки."

#: ./en/ch04.md:467
msgid ""
"     \t> Restore          This probably uses a system-dependent function for "
"restoring data from tape.\n"
"\t>                  Since this operation depends on only the type of "
"operating system, it can be\n"
"\t>                  implemented by one primary method for each type of "
"operating system:"
msgstr ""
"     \t> Restore(Восстановить)     Это, вероятно, использует зависящую от"
" системы функцию для восстановления данных с ленты.\n"
"\t>                          Поскольку эта операция зависит только от типа"
" операционной системы, она может быть\n"
"\t>                          реализована одним основным методом для каждого"
" типа операционной системы:"

#: ./en/ch04.md:472
msgid ""
"<pre>\n"
"(defmethod restore-product (sw (os genera)) body) \n"
"(defmethod restore-product (sw (os unix)) body) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:478
msgid ""
"\t>                  The sw argument is used for describing which product to "
"restore from tape.\n"
"\t>                  The only part of restore-product that depends on both "
"the type of the product\n"
"\t>                  and the type of the operating system is the pathname "
"where the source file\n"
"\t>                  should be stored. The bodies of the restore-product "
"methods call\n"
"\t>                  get-source-pathname for this information:"
msgstr ""
"\t>                  Аргумент sw используется для описания того, какой"
" продукт восстанавливать с ленты.\n"
"\t>                  Единственная часть restore-product, которая зависит как"
" от типа продукта, так и от типа\n"
"\t>                  операционной системы, - это путь, по которому должен"
" храниться исходный файл. Тела\n"
"\t>                  методов restore-product вызывают get-source-pathname для"
" получения этой информации:"

#: ./en/ch04.md:482
msgid ""
"<pre>\n"
"(defgeneric get-source-pathname (product os) \n"
"   (:documentation \"Returns a string.\")) "
msgstr ""

#: ./en/ch04.md:485
msgid ""
"(defmethod get-source-pathname ((sw life) (os unix)) \n"
"   \"/bin/games/life.lsp\") "
msgstr ""

#: ./en/ch04.md:488
msgid ""
"(defmethod get-source-pathname ((sw adventure) (os unix)) \n"
"   \"/bin/games/adventure.lsp\") "
msgstr ""

#: ./en/ch04.md:491
msgid ""
"(defmethod get-source-pathname ((sw life) (os genera)) \n"
"   \"sys:games;life.lisp\") "
msgstr ""

#: ./en/ch04.md:495
msgid ""
"(defmethod get-source-pathname ((sw adventure) (os genera)) \n"
"   \"sys:games;adventure.lisp\") \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:497
msgid ""
"\t> Compile            This operation can probably be done with one default "
"method. "
msgstr ""
"\t> Compile(Скомпилировать)  эту операцию, вероятно, можно с помощью одного"
" метода по умолчанию."

#: ./en/ch04.md:502
msgid ""
"<pre>\n"
"(defmethod compile-product (sw os) \n"
"(compile-file (get-source-pathname sw os))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:508
msgid ""
"\t> Configure          This step configures the site to understand about the "
"new software package.\n"
"\t>                    It might include updating some configuration files, "
"such as designating a\n"
"\t>                    location for storing any error messages generated by "
"the software. This step\n"
"\t>                    probably depends on both the type of software product "
"and the type of\n"
"\t>                    operating system:"
msgstr ""
"\t> Configure(Настройка)       Этот шаг настраивает сайт для ознакомления с"
" новым пакетом программного\n "
"\t>                                        обеспечения. Это может включать"
" обновление некоторых файлов конфигурации,\n"
"\t>                                        например, определение"
" местоположения для хранения любых сообщений об\n"
"\t>                                        ошибках, генерируемых программным"
" обеспечением. Этот шаг, вероятно, зависит\n"
"\t>                                        как от типа программного продукта,"
" так и от типа операционной системы:"

#: ./en/ch04.md:515
msgid ""
"<pre>\n"
"(defmethod configure-site ((sw life) (os genera)) body) \n"
"(defmethod configure-site ((sw adventure) (os genera)) bod \n"
"(defmethod configure-site ((sw life) (os unix)) body) \n"
"(defmethod configure-site ((sw adventure) (os unix)) body) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:520
msgid ""
"\t> Verify             This runs a test suite on the software product to "
"ensure that the installation\n"
"\t>                    was successful. Since the internal tests work the "
"same way for a given\n"
"\t>                    software product regardless of the type of operating "
"system, the methods\n"
"\t>                    specialize only the software product parameter:"
msgstr ""
"\t> Verify             При этом выполняется набор тестов программного"
" продукта, чтобы убедиться в успешности\n"
"\t>                      установки. Поскольку внутренние тесты работают"
" одинаково для данного программного\n"
"\t>                      продукта независимо от типа операционной системы,"
" методы специализируются только на\n"
"\t>                      параметре программного продукта:"

#: ./en/ch04.md:525
msgid ""
"<pre>\n"
"(defmethod verify-product ((sw life) os) body) \n"
"(defmethod verify-product ((sw adventure) os) body) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:527
msgid ""
"At this point, the design of the program is done and only the implementation "
"remains. We have sketched out an implementation based entirely on primary "
"methods. It might happen that this sketch does not account for every piece "
"of the installation. If we identify behavior that must be added to this "
"sketch, we can always use before- and after-methods."
msgstr ""
"На этом этапе разработка программы завершена, и остается только реализация."
" Мы набросали реализацию, полностью основанную на первичных методах. Может"
" случиться так, что этот эскиз не учитывает каждую часть инсталляции. Если мы"
" определим поведение, которое необходимо добавить в этот эскиз, мы всегда"
" можем использовать методы \"до\"(before-) и \"после\"(after-)."

#: ./en/ch04.md:529
msgid ""
"This design makes for a reasonable protocol. To add support for a new "
"software product or another operating system, we need only implement methods "
"for a subset of the installation operations. This design effectively "
"separates the complexities of the operating system from the software product:"
" "
msgstr ""
"Такой дизайн обеспечивает разумный протокол. Чтобы добавить поддержку нового"
" программного продукта или другой операционной системы, нам нужно реализовать"
" методы только для подмножества операций установки. Такой дизайн эффективно"
" отделяет сложности операционной системы от программного продукта:"

#: ./en/ch04.md:531
msgid ""
"*   We could add a new software product by defining methods for configure-"
"site, verify-product, and get-source-pathname "
msgstr ""
"*   Мы могли бы добавить новый программный продукт, определив методы для"
" configure-site, verify-product и get-source-pathname."

#: ./en/ch04.md:533
msgid ""
"*   We could support a new operating system by defining methods for "
"configure-site, restore-product, and get-source-pathname "
msgstr ""
"*   Мы могли бы поддерживать новую операционную систему, определив методы для"
" configure-site, restore-product и get-source-pathname."

#: ./en/ch04.md:535
msgid "## 4.4 METHODS FOR COMMON LISP TYPES "
msgstr "## 4.4 МЕТОДЫ ДЛЯ ТИПОВ COMMON LISP"

#: ./en/ch04.md:537
msgid ""
"CLOS provides classes corresponding to some (but not all) of the standard "
"Common Lisp types. The name of such a class is the same as the name of the "
"type. For example, there is a class named array corresponding to the type "
"array. These classes are provided for a single reason: to enable you to "
"write methods that specialize on Common Lisp types. "
msgstr ""
"CLOS предоставляет классы, соответствующие некоторым (но не всем) стандартным"
" типам Common Lisp. Имя такого класса совпадает с именем типа. Например,"
" существует класс с именем array, соответствующий типу array. Эти классы"
" предоставляются по единственной причине: чтобы вы могли писать методы,"
" которые специализируются на типах Common Lisp."

#: ./en/ch04.md:539
msgid "### Classes Corresponding to COMMON LISP Types"
msgstr "### Классы, соответствующие типам COMMON LISP"

#: ./en/ch04.md:541
msgid ""
"We have already seen one example of a class corresponding to a Common Lisp "
"type—the class t, which corresponds to the type t. The class t appears as "
"the last (least specific) class in all class precedence lists, including "
"classes defined by users and classes provided by CLOS."
msgstr ""
"Мы уже видели один пример класса, соответствующего типу Common Lisp — класс"
" t, который соответствует типу t. Класс t отображается как последний"
" (наименее специфичный) класс во всех списках приоритета классов, включая"
" классы, определенные пользователями, и классы, предоставляемые CLOS."

#: ./en/ch04.md:543
msgid ""
"Table 4.1 lists the classes corresponding to Common Lisp types and the class "
"precedence list of each class. This table is adapted from \"Common Lisp "
"Object System Specification\" with permission from the authors."
msgstr ""
"В таблице 4.1 перечислены классы, соответствующие типам Common Lisp, и список"
" приоритетов каждого класса. Эта таблица адаптирована из \"Спецификации"
" объектной системы Common Lisp\" с разрешения авторов."

#: ./en/ch04.md:563
msgid ""
"|   Class      |  Class Precedence List               |\n"
"|--------------|--------------------------------------|\n"
"| array        | (array t)                            |\n"
"| bit-vector   | (bit-vector vector array sequence t) |\n"
"| character    | (character t)                        |\n"
"| complex      | (complex number t)                   |\n"
"| cons         | (cons list sequence t)               |\n"
"| float        | (float number t)                     |\n"
"| integer      | (integer rational number t)          |\n"
"| list         | (list sequence t)                    |\n"
"| null         | (null symbol list sequence t)        |\n"
"| number       | (number t)                           |\n"
"| ratio        | (ratio rational number t)            |\n"
"| rational     | (rational number t)                  |\n"
"| sequence     | (sequence t)                         |\n"
"| string       | (string vector array sequence t)     |\n"
"| symbol       | (symbol t)                           |\n"
"| t            | (t)                                  |\n"
"| vector       | (vector array sequence t)            |"
msgstr ""
"| Класс        | Список приоритетов классов           |\n"
"|--------------|--------------------------------------|\n"
"| array        | (array t)                            |\n"
"| bit-vector   | (bit-vector vector array sequence t) |\n"
"| character    | (character t)                        |\n"
"| complex      | (complex number t)                   |\n"
"| cons         | (cons list sequence t)               |\n"
"| float        | (float number t)                     |\n"
"| integer      | (integer rational number t)          |\n"
"| list         | (list sequence t)                    |\n"
"| null         | (null symbol list sequence t)        |\n"
"| number       | (number t)                           |\n"
"| ratio        | (ratio rational number t)            |\n"
"| rational     | (rational number t)                  |\n"
"| sequence     | (sequence t)                         |\n"
"| string       | (string vector array sequence t)     |\n"
"| symbol       | (symbol t)                           |\n"
"| t            | (t)                                  |\n"
"| vector       | (vector array sequence t)            |"

#: ./en/ch04.md:565
msgid "Table 4.1 Precedence of classes corresponding to Common Lisp types."
msgstr "Таблица 4.1 Приоритет классов, соответствующих типам Common Lisp."

#: ./en/ch04.md:567
msgid ""
"These classes have multiple inheritance. The class/subclass relationships "
"among them parallel the type/subtype relationships described in Steele's "
"Common LISP: The Language. Consider the type vector: "
msgstr ""
"Эти классы имеют множественное наследование. Отношения класса/подкласса между"
" ними параллельны отношениям типа/подтипа, описанным в книге Стила Common"
" LISP: The Language. Рассмотрим вектор типа:"

#: ./en/ch04.md:570
msgid ""
"*  The type vector is a subtype of sequence and array \n"
"*  The class vector is a subclass of sequence and array "
msgstr ""
"* Тип vector - это подтип sequence(последовательности) и array(массива)\n"
"* Класс vector является подклассом sequence и array"

#: ./en/ch04.md:573
msgid ""
"For each class corresponding to a Common Lisp type, if Common LISP:\n"
"The Language specifies a type/subtype relationship, the class/subclass "
"relationship is determined accordingly. In some cases, however, no type/"
"subtype relationship was specified, and the CLOS working group decided on "
"the precedence order. For example, the type string is a subtype of both "
"array and sequence, but Common Lisp does not specify a type/subtype "
"relationship between array and sequence. The CLOS working group decided that "
"array should precede sequence in the class precedence list for string,"
msgstr ""
"Для каждого класса, соответствующего типу Common Lisp, если Common LISP:\n"
"Язык определяет отношение тип/подтип, соответственно определяется отношение"
" класс/подкласс. Однако в некоторых случаях не было указано соотношение"
" тип/подтип, и рабочая группа CLOS приняла решение о порядке приоритета."
" Например, строка типа является подтипом как массива, так и"
" последовательности, но Common Lisp не определяет отношения типа/подтипа"
" между массивом и последовательностью. Рабочая группа CLOS решила, что массив"
" должен предшествовать последовательности в списке приоритета класса для"
" строки,"

#: ./en/ch04.md:575
msgid ""
"There must be a completely specified class precedence list for each class, "
"in order for CLOS to choose the precedence of methods. One reason why the "
"CLOS working group did not specify that all Common Lisp types should have "
"corresponding classes is that some types have illdefined relationships to "
"other types, and it would be difficult to decide the precedence orders of "
"the types. For example, consider what happens if the argument is the "
"instance 7, and two methods are applicable: one specializes on (integer 0 10)"
" and the other specializes on (integer 5 15)—which method should be deemed "
"more specific? Since the semantics of some types do not lend themselves to a "
"strict precedence order, those types do not have corresponding classes."
msgstr ""
"Для каждого класса должен быть полностью определенный список приоритетов"
" классов, чтобы CLOS могли выбирать приоритет методов. Одна из причин, по"
" которой рабочая группа CLOS не указала, что все типы Common Lisp должны"
" иметь соответствующие классы, заключается в том, что некоторые типы имеют"
" неопределенные отношения с другими типами, и было бы трудно определить"
" порядок приоритета типов. Например, рассмотрим, что произойдет, если"
" аргументом является экземпляр 7, и применимы два метода: один"
" специализируется на (integer 0 10), а другой специализируется на (integer 5"
" 15) — какой метод следует считать более конкретным? Поскольку семантика"
" некоторых типов не поддается строгому порядку приоритета, у этих типов нет"
" соответствующих классов."

#: ./en/ch04.md:577
msgid ""
"If a Common Lisp type does not have a corresponding class, you cannot define "
"a method that specializes on that type. CLOS does not support classes for "
"type specifiers that are lists, such as"
msgstr ""
"Если тип Common Lisp не имеет соответствующего класса, вы не можете"
" определить метод, который специализируется на этом типе. CLOS не"
" поддерживает классы для спецификаторов типов, которые являются списками,"
" такими как"

#: ./en/ch04.md:584
msgid ""
"<pre>\n"
"(integer 0 10) \n"
"(string 25) \n"
"(not number) \n"
"(vector (mod 256)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:586
msgid "### Built-in Classes "
msgstr "### Встроенные классы"

#: ./en/ch04.md:588
msgid ""
"Usually, classes corresponding to Common Lisp types are implemented as "
"\"built-in classes,\" which means they do not have all the properties of "
"classes defined with defclass. Built-in classes are implemented in a "
"special, system-dependent way, to take advantage of a machine's "
"architecture, or for other reasons. For the most part, it does not make "
"sense to implement these classes with defclass, because they do not neatly "
"fit into that model."
msgstr ""
"Обычно классы, соответствующие типам Common Lisp, реализуются как"
" \"встроенные классы\", что означает, что они не обладают всеми свойствами"
" классов, определенных с помощью defclass. Встроенные классы реализуются"
" особым, зависящим от системы способом, чтобы использовать преимущества"
" архитектуры машины или по другим причинам. По большей части, не имеет смысла"
" реализовывать эти классы с помощью defclass, потому что они не совсем"
" вписываются в эту модель."

#: ./en/ch04.md:591
msgid ""
"The decision of how to implement classes corresponding to Common Lisp types "
"is made by each CLOS implementation. Any of these classes could be "
"implemented as a built-in class or as a user-defined class. \n"
"Although built-in classes follow the CLOS model in some ways (they have "
"multiple inheritance; they have instances; they inherit from the class t, "
"and you can define methods that specialize on them), they diverge from the "
"model in other ways. These are the significant differences between built-in "
"classes and user-defined classes: "
msgstr ""
"Решение о том, как реализовать классы, соответствующие типам Common Lisp,"
" принимается каждой реализацией CLOS. Любой из этих классов может быть"
" реализован как встроенный класс или как класс, определяемый пользователем.\n"
"Хотя встроенные классы в некоторых отношениях следуют модели CLOS (они имеют"
" множественное наследование; у них есть экземпляры; они наследуются от класса"
" t, и вы можете определить методы, которые специализируются на них), они"
" отличаются от модели другими способами. Это существенные различия между"
" встроенными классами и пользовательскими классами:"

#: ./en/ch04.md:596
msgid ""
"*   *Structure*. The structure of a user-defined class is in the form of "
"slots. However, the internal structure of built-in classes is usually not "
"represented by slots. For example, the value of a symbol is probably not "
"stored in a slot in most CLOS implementations. \n"
"*   *Creation of instances*. To create instances of user-defined classes, "
"you can use make-instance. However, CLOS does not allow using make-instance "
"to create instances of built-in classes. You use an independent mechanism "
"for creating instances, such as using the cons function to create an "
"instance of cons.\n"
"*    *Use as a superclass*. CLOS does not allow you to include a built-in "
"class as a direct superclass of any user-defined class. The only exception "
"to this rule is the class named t, which is automatically a superclass of "
"every class. \n"
"*     *Inheritance from* standard-object. Recall that standard-object is "
"implicitly included as a superclass of user-defined classes. In contrast, "
"standard-object is not a superclass of built-in classes. This distinction "
"makes it possible for implementations to provide default methods intended "
"for user-defined classes only."
msgstr ""
"* *Structure*.    Структура пользовательского класса представлена в виде"
" слотов. Однако внутренняя структура встроенных классов обычно не"
" представлена слотами. Например, значение символа, вероятно, не хранится в"
" слоте в большинстве реализаций CLOS.\n"
"* *Creation of instances*(*Создание экземпляров*). Для создания экземпляров"
" пользовательских классов вы можете использовать make-instance. Однако CLOS"
" не позволяет использовать make-instance для создания экземпляров встроенных"
" классов. Вы используете независимый механизм для создания экземпляров,"
" например, с помощью функции cons для создания экземпляра cons.\n"
"* *Use as a superclass*(*Использовать в качестве суперкласса*). CLOS не"
" позволяет вам включать встроенный класс в качестве прямого суперкласса"
" любого пользовательского класса. Единственным исключением из этого правила"
" является класс с именем t, который автоматически является суперклассом"
" каждого класса.\n"
"* *Inheritance from* standard-object(*Наследование от* стандартного объекта)."
" Напомним, что standard-object неявно включен как суперкласс пользовательских"
" классов. В отличие от этого, standard-object не является суперклассом"
" встроенных классов. Это различие позволяет реализациям предоставлять методы"
" по умолчанию, предназначенные только для пользовательских классов."

#: ./en/ch04.md:598
msgid ""
"The CLOS specification defines a set of requirements for implementations to "
"follow with regard to built-in classes, but it also allows implementations "
"to support extensions in this area. Here are two extensions that you might "
"encounter:"
msgstr ""
"Спецификация CLOS определяет набор требований, которым должны следовать"
" реализации в отношении встроенных классов, но она также позволяет"
" реализациям поддерживать расширения в этой области. Вот два расширения, с"
" которыми вы можете столкнуться:"

#: ./en/ch04.md:601
msgid ""
"*    CLOS implementations may provide classes for other Common Lisp types, "
"in addition to those required. This might include classes for pathname, "
"package, or others. All such classes must adhere to the precedence implied "
"by their type/subtype relationships defined in Steele's Common LISP: The "
"Language. \n"
"*     As mentioned earlier, CLOS implementations can choose to implement the "
"class for any Common Lisp type either as a built-in class (which follows the "
"restrictions noted) or as a user-defined class. For example, a CLOS "
"implementation is free to define the class string by using defclass. When "
"this is done, you can do anything with the class string that you can do with "
"other classes defined by defclass."
msgstr ""
"* Реализации CLOS могут предоставлять классы для других типов Common Lisp в"
" дополнение к тем, которые требуются. Это может включать классы для pathname,"
" package или других. Все такие классы должны придерживаться приоритета,"
" подразумеваемого их отношениями типа/подтипа, определенными в Common LISP"
" Стила: The Language.\n"
"* Как упоминалось ранее, реализации CLOS могут выбрать реализацию класса для"
" любого типа Common Lisp либо как встроенного класса (который соответствует"
" указанным ограничениям), либо как определяемого пользователем класса."
" Например, реализация CLOS может свободно определять строку класса с помощью"
" defclass. Когда это будет сделано, вы сможете делать со строкой класса все,"
" что вы можете делать с другими классами, определенными defclass."

#: ./en/ch04.md:603
msgid ""
"Note that programs that depend on extensions to CLOS are not readily "
"portable to other CLOS implementations. "
msgstr ""
"Обратите внимание, что программы, которые зависят от расширений для CLOS,"
" нелегко переносить на другие реализации CLOS."

#: ./en/ch04.md:605
msgid "### Examples of Methods for COMMON LISP Types"
msgstr "### Примеры методов для типов COMMON LISP"

#: ./en/ch04.md:608
msgid ""
"We can illustrate defining methods for Common Lisp types by implementing a "
"simple network protocol for performing remote evaluation. This program "
"enables a user to send a Lisp form to another machine over a network and "
"receive the result of evaluating that form. The ma- \n"
"chine that sends the form is called the client machine, and the machine that "
"performs the evaluation and returns the result to the client is called the "
"server machine."
msgstr ""
"Мы можем проиллюстрировать определение методов для типов Common Lisp,"
" реализовав простой сетевой протокол для выполнения удаленного"
" выполнения(оценки). Эта программа позволяет пользователю отправлять форму"
" Lisp на другой компьютер по сети и получать результат вычисления(оценки)"
" этой формы. Машина, которая отправляет форму, называется клиентской машиной,"
" а машина, которая выполняет вычисления и возвращает результат клиенту,"
" называется серверной машиной."

#: ./en/ch04.md:610
msgid ""
"The portion of this program pertaining to Common Lisp types lies in the "
"sending and receiving of Lisp objects over the network. A Lisp object lives "
"in one Lisp world, and it is not possible or desirable to transmit the "
"actual object. Instead, the client machine encodes a Lisp object into a "
"representation suitable for sending over the network. On the other side, the "
"server machine decodes the representation and creates or obtains a Lisp "
"object equivalent to the object that was encoded. The result of the "
"evaluation is then encoded by the server, transmitted, and decoded by the "
"client machine."
msgstr ""
"Часть этой программы, относящаяся к типам Common Lisp, заключается в отправке"
" и получении объектов Lisp по сети. Объект Lisp живет в одном мире Lisp, и"
" передавать фактический объект невозможно или желательно. Вместо этого"
" клиентская машина кодирует объект Lisp в представление, подходящее для"
" отправки по сети. С другой стороны, серверная машина декодирует"
" представление и создает или получает объект Lisp, эквивалентный объекту,"
" который был закодирован. Результат вычисления затем кодируется сервером,"
" передается и декодируется клиентской машиной."

#: ./en/ch04.md:612
msgid ""
"Figure 4.3 shows the interaction between the client and the server machines "
"during a remote evaluation."
msgstr ""
"На рисунке 4.3 показано взаимодействие между клиентской и серверной машинами"
" во время удаленного вычисления/оценки."

#: ./en/ch04.md:615
msgid ""
"![Figure 4.3: Remote evaluation.](images/f04-03.jpg)\n"
"**Figure 4.3: Remote evaluation.**"
msgstr ""
"![Рисунок 4.3: Удаленное вычисление/оценка.](images/f04-03.jpg )"
"**Рисунок 4.3: Удаленная вычисление/оценка.**"

#: ./en/ch04.md:617
msgid ""
"Decoding and encoding are analogous to the Lisp reading and printing "
"operations: The Lisp reader takes a typed-in representation of an object and "
"generates a Lisp object; the printer takes a Lisp object and generates a "
"representation of it suitable for printing. Like the printer and reader, the "
"decoding and encoding methods preserve only the \"simple\" characteristics "
"of objects. For example, the contents of an array are encoded, but any fill "
"pointer is not."
msgstr ""
"Декодирование и кодирование аналогичны операциям чтения и печати Lisp:"
" Программа чтения Lisp принимает введенное представление объекта и генерирует"
" объект Lisp; принтер принимает объект Lisp и генерирует его представление,"
" подходящее для печати. Подобно принтеру и считывателю, методы декодирования"
" и кодирования сохраняют только \"простые\" характеристики объектов."
" Например, содержимое массива кодируется, но любой указатель на заполнение -"
" нет."

#: ./en/ch04.md:619
msgid ""
"The implementation of encoding takes advantage of classes corresponding to "
"Common Lisp types. The remote-evaluation program supports the transmission "
"of simple Lisp objects, such as lists, integers, characters, strings, "
"symbols, and vectors. We provide methods for encoding these objects; these "
"methods specialize on the classes corresponding to the various types of "
"objects. It is possible to extend this model to send instances of user-"
"defined classes as well, by providing encoding and decoding methods for "
"those classes."
msgstr ""
"Реализация кодирования использует преимущества классов, соответствующих типам"
" Common Lisp. Программа удаленного вычисления поддерживает передачу простых"
" объектов Lisp, таких как списки, целые числа, символы, строки, символы и"
" векторы. Мы предоставляем методы для кодирования этих объектов; эти методы"
" специализируются на классах, соответствующих различным типам объектов. Можно"
" расширить эту модель, чтобы отправлять экземпляры пользовательских классов,"
" а также, предоставляя методы кодирования и декодирования для этих классов."

#: ./en/ch04.md:621
msgid ""
"Although the main point of this example is to show the encoding and "
"decoding, for the sake of completeness we also describe the top-level "
"functions that call the encoding and decoding generic functions."
msgstr ""
"Хотя основной смысл этого примера состоит в том, чтобы показать кодирование и"
" декодирование, для полноты картины мы также описываем функции верхнего"
" уровня, которые вызывают обобщенные функции кодирования и декодирования."

#: ./en/ch04.md:623
msgid "### A Sample Remote Evaluation Session"
msgstr "### Пример Сеанса Удаленного Вычисления"

#: ./en/ch04.md:625
msgid ""
"We begin by describing how to use the remote evaluation program. We create a "
"remote-eval-stream and call the remote-eval function to send forms to the "
"stream and receive the results. Finally, we close the stream:"
msgstr ""
"Мы начнем с описания того, как использовать программу удаленного вычисления."
" Мы создаем remote-eval-stream и вызываем функцию remote-eval для отправки"
" форм в поток и получения результатов. Наконец, мы закрываем поток:"

#: ./en/ch04.md:632
msgid ""
"<pre>\n"
"(setq *my-stream* (make-remote-eval-stream server-machine)) \n"
"(remote-eval *my-stream* \"hello\") => \"hello\" \n"
"(remote-eval *my-stream* '(+ 1 23)) => 24 \n"
"(close *my-stream*)\n"
"</pre>"
msgstr ""

#: ./en/ch04.md:634
msgid "### The Top-Level Functions"
msgstr "### Функции Верхнего уровня"

#: ./en/ch04.md:636
msgid ""
"make-remote-eval-stream creates a network connection to the server machine "
"and returns a bidirectional binary eight-bit byte stream. Once the stream "
"has been created, a process is started on the server to run the eval-server "
"function (defined below). Closing this stream kills the server process and "
"closes the network connection. Since the implementation of make-remote-eval-"
"stream is necessarily specific to the operating system, it is not given here."
msgstr ""
"make-remote-eval-stream создает сетевое подключение к серверной машине и"
" возвращает двунаправленный двоичный восьмибитный поток байтов. Как только"
" поток создан, на сервере запускается процесс для выполнения функции"
" eval-server (определенной ниже). Закрытие этого потока завершает серверный"
" процесс и закрывает сетевое соединение. Поскольку реализация"
" make-remote-eval-stream обязательно специфична для операционной системы, она"
" здесь не приводится."

#: ./en/ch04.md:639
msgid ""
"remote-eval implements the client side; it sends a form to the server, "
"receives the result of evaluating that form, and returns the result. The "
"form is evaluated in the server's environment, and any side effects happen "
"in that environment. This example does not transmit printed output, transmit "
"multiple return values, or handle errors generated by the \n"
"evaluation of the form on the server; any of these features could be added. "
msgstr ""
"remote-eval реализует клиентскую часть; он отправляет форму на сервер,"
" получает результат оценки этой формы и возвращает результат. Форма"
" вычисляется в среде сервера, и любые побочные эффекты происходят в этой"
" среде. Этот пример не передает распечатанный вывод, не передает несколько"
" возвращаемых значений и не обрабатывает ошибки, сгенерированные при оценке"
" формы на сервере; любая из этих функций может быть добавлена."

#: ./en/ch04.md:652
msgid ""
"<pre>\n"
";;; This must be defined on the client machine, \n"
"(defun remote-eval (stream form) \n"
"   (encode form stream) \n"
"   (force-output stream) \n"
"   ;; Read the return value \n"
"   ;; The first byte is a control byte \n"
"   (decode (read-byte stream) stream)) \n"
"</pre>\n"
"eval-server implements the server side; it continually reads forms sent \n"
"to it, evaluates the forms, and returns the results. When the stream is \n"
"closed, this process is killed. "
msgstr ""
"<pre>\n"
";;; This must be defined on the client machine, \n"
"(defun remote-eval (stream form) \n"
"   (encode form stream) \n"
"   (force-output stream) \n"
"   ;; Read the return value \n"
"   ;; The first byte is a control byte \n"
"   (decode (read-byte stream) stream)) \n"
"</pre>\n"
"eval-server реализует серверную часть; он постоянно считывает отправленные"
" ему формы, вычисляет/оценивает формы и возвращает результаты. Когда поток"
" закрывается, этот процесс завершается."

#: ./en/ch04.md:661
msgid ""
"<pre>\n"
";;; This must be defined on the server machine, \n"
"(defun eval-server (stream) \n"
"   (loop (encode \n"
"          (eval (decode (read-byte stream) stream)) \n"
"          stream) \n"
"         (force-output stream)))\n"
"</pre>"
msgstr ""

#: ./en/ch04.md:663
msgid "### The Encoding and Decoding Protocol"
msgstr "### Протокол кодирования и декодирования"

#: ./en/ch04.md:665
msgid ""
"The bulk of the program lies in the encoding and decoding of Lisp objects. "
"We shall use a simple protocol for this purpose. To encode an object, we "
"first transmit on the stream a control byte that declares the type of "
"object. (A control byte is an eight-bit byte.) We then encode and transmit "
"the representation of the object itself; the implementation of this varies, "
"depending on the type of object. When decoding, we read a control byte from "
"the stream; this byte indicates what type of object is being transmitted. We "
"then decode the bytes that follow and convert the encoded representation "
"into a Lisp object. The implementation of decoding an object depends on the "
"type of object."
msgstr ""
"Основная часть программы заключается в кодировании и декодировании объектов"
" Lisp. Для этой цели мы будем использовать простой протокол. Чтобы"
" закодировать объект, мы сначала передаем по потоку управляющий байт, который"
" объявляет тип объекта. (Управляющий байт - это восьмибитный байт.) Затем мы"
" кодируем и передаем представление самого объекта; реализация этого"
" варьируется в зависимости от типа объекта. При декодировании мы считываем"
" управляющий байт из потока; этот байт указывает, какой тип объекта"
" передается. Затем мы декодируем следующие байты и преобразуем закодированное"
" представление в объект Lisp. Реализация декодирования объекта зависит от"
" типа объекта."

#: ./en/ch04.md:667
msgid ""
"The method for encoding any one kind of object (such as symbols) works "
"together with the method for decoding that kind of object. Those methods "
"must use the same technique for encoding and decoding. However, the methods "
"for encoding and decoding another type of object (such as characters) can "
"use an entirely different technique for encoding and decoding from the "
"technique used for symbols. The only requirement is that the decoding method "
"for any given type of object must understand how the encoding method for "
"that type of object works."
msgstr ""
"Способ кодирования любого объекта одного типа (например, symbols/символов)"
" работает вместе со способом декодирования объекта такого типа. Эти методы"
" должны использовать одну и ту же технику для кодирования и декодирования."
" Однако способы кодирования и декодирования объектов другого типа (таких как"
" символы) могут использовать совершенно иную технику кодирования и"
" декодирования, чем техника, используемая для символов. Единственное"
" требование заключается в том, что метод декодирования для любого данного"
" типа объекта должен понимать, как работает метод кодирования для этого типа"
" объекта."

#: ./en/ch04.md:669
msgid "Our protocol consists of two generic functions: "
msgstr "Наш протокол состоит из двух обобщенных функций:"

#: ./en/ch04.md:674
msgid ""
"<pre>\n"
"(defgeneric encode (object stream) \n"
"   (:documentation \n"
"    \"Encode object and send the result to stream.\")) "
msgstr ""

#: ./en/ch04.md:680
msgid ""
"(defgeneric decode (code stream) \n"
"   (:documentation \n"
"    \"Based on the code, read an encoded representation \n"
"from the stream, decode, and create an object.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:682
msgid ""
"This is an extensible protocol; it is a straightforward matter to extend it "
"to support additional types of objects. To do so, we would supply methods "
"for encoding and decoding. There is no need to change the code that calls "
"encode and decode. This is one clear benefit of using generic functions "
"instead of having the callers use a typecase to select the code for encoding "
"and decoding the various types of objects."
msgstr ""
"Это расширяемый протокол; его несложно расширить для поддержки дополнительных"
" типов объектов. Для этого мы бы предоставили методы кодирования и"
" декодирования. Нет необходимости изменять код, который вызывает encode и"
" decode. Это одно из очевидных преимуществ использования обобщенных функций"
" вместо того, чтобы вызывающие использовали typecase для выбора кода для"
" кодирования и декодирования различных типов объектов."

#: ./en/ch04.md:684
msgid ""
"This example shows how to encode and decode a handful of types of objects. "
"Each type of object has a corresponding control byte. These control bytes are"
msgstr ""
"В этом примере показано, как кодировать и декодировать несколько типов"
" объектов. Каждый тип объекта имеет соответствующий управляющий байт. Эти"
" управляющие байты являются"

#: ./en/ch04.md:694
msgid ""
"<pre>\n"
"(defconstant %positive-integer 1) \n"
"(defconstant %negative-integer 2) \n"
"(defconstant Icharacter 3) \n"
"(defconstant Isymbol A) \n"
"(defconstant Istring 5) \n"
"(defconstant Hist 6) \n"
"(defconstant %vector 7) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:696
msgid "### Encoding Integers "
msgstr "### Кодирование целых чисел"

#: ./en/ch04.md:698
msgid ""
"To encode an integer, we send the control byte indicating positive or "
"negative integer, then the length of the integer, then the absolute value of "
"the integer itself. The length of the integer is always sent in one byte. "
msgstr ""
"Чтобы закодировать целое число, мы отправляем управляющий байт, указывающий"
" положительное или отрицательное целое число, затем длину целого числа, затем"
" абсолютное значение самого целого числа. Длина целого числа всегда"
" передается в одном байте."

#: ./en/ch04.md:712
msgid ""
"<pre>\n"
"(defmethod encode ((num integer) stream) \n"
"   (cond ((minusp num) \n"
"          (write-byte %negative-integer stream) \n"
"          (setq num (abs num))) \n"
"         (t \n"
"          (write-byte %positive-integer stream))) \n"
"   (let ((n-bytes (ceiling (integer-length num) 8))) \n"
"      (write-byte n-bytes stream) \n"
"      (dotimes (i n-bytes) \n"
"         (write-byte (ldb (byte 8 0) num) stream) \n"
"         (setq num (ash num -8)))))\n"
"</pre>"
msgstr ""

#: ./en/ch04.md:714
msgid ""
"To decode integers, we will need one method for decoding positive integers "
"and another method for decoding negative integers. The method that decodes "
"positive integers will be called when the code is %positive-integer. That "
"method will read the length of the integer and then the integer itself; it "
"can then create (read) the integer and be finished. The next byte on the "
"stream is a new control byte, which is the start of a new encoded object."
msgstr ""
"Чтобы декодировать целые числа, нам понадобится один метод для декодирования"
" положительных целых чисел и другой метод для декодирования отрицательных"
" целых чисел. Метод, который декодирует положительные целые числа, будет"
" вызван, когда код равен %positive-integer. Этот метод считает длину целого"
" числа, а затем само целое число; затем он может создать (прочитать) целое"
" число и завершить работу. Следующий байт в потоке - это новый управляющий"
" байт, который является началом нового закодированного объекта."

#: ./en/ch04.md:716
msgid ""
"By sending the length of integers in one byte, we have implicitly placed a "
"limitation on the value of integers transmitted: No value of num for which ("
"> (ceiling (integer-length (abs num)) 8) 255) is true can be transmitted, "
"which means the maximum integer length is 2040. Using the definition of "
"integer-length on page 224 of Steele's Common LISP: The Language, the "
"maximum positive integer is (1- (expt 2 (* 8 255))) and the most negative "
"integer is the negative of that. The limit is therefore very large, a bit "
"over 10 raised to the 614th power."
msgstr ""
"Отправляя длину целых чисел в одном байте, мы неявно наложили ограничение на"
" передаваемое значение целых чисел: не может быть передано значение num, для"
" которого (> (ceiling (integer-length (abs num)) 8) 255) равно true, что"
" означает, что максимальная длина целого числа равна 2040. Используя"
" определение целочисленной длины на странице 224 книги Стила Common LISP: The"
" Language, максимальное положительное целое число равно (1- (expt 2 (* 8"
" 255))), а самое отрицательное целое число является отрицательным от этого."
" Таким образом, предел очень велик, чуть более 10, увеличенный до 614-й"
" степени."

#: ./en/ch04.md:718
msgid ""
"The decoding methods are given in the next section, \"Methods for Individual "
"LISP Objects,\" page 94."
msgstr ""
"Методы декодирования приведены в следующем разделе, \"Методы для отдельных"
" объектов LISP\", стр. 94."

#: ./en/ch04.md:720
msgid "### Encoding Characters"
msgstr "### Кодировка Characters(символьных знаков)"

#: ./en/ch04.md:722
msgid ""
"To encode a character, we send the control byte indicating character and "
"then the ASCII code of the character in the next byte. This method sends "
"only the character's code, and ignores any font or bits."
msgstr ""
"Чтобы закодировать символьный знак, мы отправляем управляющий байт,"
" указывающий что это символьный знак, а затем ASCII-код символа в следующем"
" байте. Этот метод отправляет только код символьного знака и игнорирует любой"
" шрифт или биты."

#: ./en/ch04.md:724
msgid ""
"To allow for differences in the native character sets of the server and "
"client machines, we convert the character to its ASCII code when encoding, "
"and convert it from ASCII to the corresponding code in the native character "
"set when decoding. The function char-to-ascii is implementation dependent "
"and is not provided here. It is necessary that charto-ascii return a value "
"less than 256 so it will fit within an eight-bit byte. "
msgstr ""
"Чтобы учесть различия в собственных наборах символьных знаков серверной и"
" клиентской машин, мы преобразуем символьный знак в его код ASCII при"
" кодировании и преобразуем его из ASCII в соответствующий код в собственном"
" наборе символьных знаков при декодировании. Функция char-to-ascii зависит от"
" реализации и здесь не предоставляется. Необходимо, чтобы charto-ascii"
" возвращал значение меньше 256, чтобы оно помещалось в восьмибитный байт."

#: ./en/ch04.md:730
msgid ""
"<pre>\n"
"(defmethod encode ((char character) stream) \n"
"   (write-byte %character stream) \n"
"   (write-byte (char-to-ascii char) stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:732
msgid "### Encoding Lists and Vectors "
msgstr "### Кодирование списков и векторов"

#: ./en/ch04.md:734
msgid ""
"To encode a list or vector, we determine the appropriate control byte, then "
"call encode-sequence to send the control byte, the length of the sequence, "
"and the encoded representation of each element of the sequence."
msgstr ""
"Чтобы закодировать список или вектор, мы определяем соответствующий"
" управляющий байт, затем вызываем encode-sequence для отправки управляющего"
" байта, длины последовательности и кодированного представления каждого"
" элемента последовательности."

#: ./en/ch04.md:738
msgid ""
"<pre>\n"
"(defmethod encode ((list list) stream) \n"
"   (encode-sequence list stream %list)) "
msgstr ""

#: ./en/ch04.md:741
msgid ""
"(defmethod encode ((vector vector) stream) \n"
"   (encode-sequence vector stream %vector)) "
msgstr ""

#: ./en/ch04.md:749
msgid ""
"(defun encode-sequence (seq stream code) \n"
"   (let ((length (length seq))) \n"
"      (write-byte code stream) \n"
"      (encode length stream) \n"
"      (dotimes (i length) \n"
"         (encode (elt seq i) stream)))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:751
msgid ""
"The two methods call the encode-sequence function to do the sharable part of "
"the work. This is a modular design that uses an ordinary function instead of "
"a generic function. There is no advantage in implementing encode-sequence as "
"a generic function in this context."
msgstr ""
"Эти два метода вызывают функцию encode-sequence для выполнения разделяемой"
" части работы. Это модульная конструкция, которая использует обычную функцию"
" вместо обобщенной функции. В этом контексте нет никакого преимущества в"
" реализации encode-sequence как обобщенные функции."

#: ./en/ch04.md:753
msgid "### Encoding Strings"
msgstr "### Кодирование строк"

#: ./en/ch04.md:755
msgid ""
"A string is a vector, so the method for encoding vectors is applicable for "
"strings, and it would work fine for them. However, we are going to provide a "
"method for string for efficiency reasons. It is easy to optimize the "
"encoding of strings because we know that each element of a string is a "
"character and will fit in one byte. When we encode a string, there is no "
"need to encode each character of the string. In contrast, there is no way of "
"knowing what the elements of a vector are, so each element must be encoded."
msgstr ""
"Строка - это вектор, поэтому метод кодирования векторов применим к строкам, и"
" он будет отлично работать для них. Однако мы собираемся предоставить метод"
" для string по соображениям эффективности. Легко оптимизировать кодировку"
" строк, потому что мы знаем, что каждый элемент строки является символьным"
" знаком и умещается в одном байте(для ASCII символов, но не UTF8). Когда мы"
" кодируем строку, нет необходимости кодировать каждый символ строки."
" Напротив, нет никакого способа узнать, каковы элементы вектора, поэтому"
" каждый элемент должен быть закодирован."

#: ./en/ch04.md:757
msgid ""
"To encode a string, we send the control byte indicating string, then the "
"length of the string, then each character of the string. Any fill pointers, "
"bits, or fonts are not encoded. "
msgstr ""
"Чтобы закодировать строку, мы отправляем управляющий байт, указывающий"
" строку, затем длину строки, затем каждый символ строки. Любые указатели"
" заливки, биты или шрифты не кодируются."

#: ./en/ch04.md:767
msgid ""
"<pre>\n"
"(defmethod encode ((string string) stream) \n"
"   (let ((length (length string))) \n"
"      (write-byte %string stream) \n"
"      ;; careful to allow strings greater than 256 chars \n"
"      (encode length stream) \n"
"      (dotimes (i length) \n"
"         (write-byte (char-to-ascii (aref string i)) stream))))\n"
"</pre>"
msgstr ""

#: ./en/ch04.md:769
msgid ""
"When encode is called with a string as its first argument, two methods are "
"applicable: the method that specializes on string, and the method that "
"specializes on vector. To determine which method is more specific, CLOS "
"consults the class precedence list of string, which is"
msgstr ""
"Когда encode вызывается со строкой в качестве первого аргумента, применяются"
" два метода: метод, который специализируется на string, и метод, который"
" специализируется на vector. Чтобы определить, какой метод является более"
" конкретным, CLOS обращается к списку приоритетов класса string, который"
" является"

#: ./en/ch04.md:773
msgid ""
"<pre>\n"
"(string vector array sequence t) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:775
msgid ""
"Since the class string has precedence over the class vector, the method that "
"specializes on string is more specific than the method that specializes on "
"vector."
msgstr ""
"Поскольку класс string имеет приоритет над классом vector, метод, который"
" специализируется на string, более специфичен, чем метод, который"
" специализируется на vector."

#: ./en/ch04.md:777
msgid "### Encoding Symbols"
msgstr "### Кодирование Символов"

#: ./en/ch04.md:779
msgid ""
"To encode a symbol and its package, we send the control byte indicating "
"symbol, the encoded representation of the symbol's name, and the encoded "
"representation of the symbol's package. Note that the value, function "
"definition, and any properties of the symbol are not transmitted. Also, the "
"package must exist on the server side."
msgstr ""
"Чтобы закодировать символ и его пакет, мы отправляем управляющий байт,"
" указывающий на  символ, закодированное представление имени символа и"
" закодированное представление пакета символа. Обратите внимание, что"
" значение, определение функции и любые свойства символа не передаются. Кроме"
" того, пакет должен существовать на стороне сервера."

#: ./en/ch04.md:786
msgid ""
"<pre>\n"
"(defmethod encode ((symbol symbol) stream) \n"
"   (write-byte %symbol stream) \n"
"   (encode (symbol-name symbol) stream) \n"
"   (encode (package-name (symbol-package symbol)) stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:788
msgid "### Design and Efficiency Considerations"
msgstr "### Соображения по проектированию и эффективности"

#: ./en/ch04.md:790
msgid ""
"Note that the method for character is quite efficient; it sends one control "
"byte, then the ASCII character code. In contrast, the method for symbol "
"results in a lot of overhead. That method sends the control byte indicating "
"symbol, then the encoded representation of the symbol's name, then the "
"encoded representation of the symbol's package. Table 4.2 shows the encoded "
"representation of the symbol + in the package lisp. "
msgstr ""
"Обратите внимание, что метод для символьного знака довольно эффективен; он"
" отправляет один управляющий байт, затем код символа ASCII. Напротив, метод"
" для символа приводит к большим накладным расходам. Этот метод отправляет"
" управляющий байт, указывающий символ, затем закодированное представление"
" имени символа, затем закодированное представление пакета символа. В таблице"
" 4.2 показано кодированное представление символа + в пакете lisp."

#: ./en/ch04.md:807
msgid ""
"| Datum   | Meaning                   |\n"
"|---------|---------------------------|\n"
"| 4       | %symbol                   |\n"
"| 5       | %string                   |\n"
"| 1       | %positive-integer         |\n"
"| 1       | length of the integer     |\n"
"| 1       | length of the string      |\n"
"| 43      | ASCII character code of + |\n"
"| 5       | %string                   |\n"
"| 1       | %positive-integer         |\n"
"| 1       | length of the integer     |\n"
"| 4       | length of the string      |\n"
"| 76      | ASCII character code of L |\n"
"| 73      | ASCII character code of I |\n"
"| 83      | ASCII character code of S |\n"
"| 80      | ASCII character code of P |"
msgstr ""

#: ./en/ch04.md:809
msgid "Table 4.2 Encoding of the symbol + in the lisp package."
msgstr "Таблица 4.2 Кодировка символа + в пакете lisp."

#: ./en/ch04.md:811
msgid ""
"The encoded representation of symbols uses five control bytes. This is a "
"result of using encode on both the symbol's name and its package. If speed "
"is important, we can devise a more efficient strategy for encoding symbols. "
"However, the current strategy has two benefits. First, it allows for error "
"checking on the decoding side: the decode method expects a symbol to contain "
"a string (the symbol's name) followed by another string (the symbol's "
"package). Second, this method calls the method that specializes on string "
"instead of duplicating the work accomplished by that method."
msgstr ""
"Закодированное представление символов использует пять управляющих байтов. Это"
" результат использования encode как для имени символа, так и для его"
" упаковки. Если важна скорость, мы можем разработать более эффективную"
" стратегию кодирования символов. Однако нынешняя стратегия имеет два"
" преимущества. Во-первых, она позволяет проверять ошибки на стороне"
" декодирования: метод декодирования ожидает, что символ будет содержать"
" строку (имя символа), за которой следует другая строка (пакет символа)."
" Во-вторых, этот метод вызывает метод, который специализируется на string,"
" вместо того, чтобы дублировать работу, выполняемую этим методом."

#: ./en/ch04.md:813
msgid ""
"The overall design of encoding and decoding is simple, modular, and "
"effective. This design easily accommodates improvements and additions to the "
"program in several areas:"
msgstr ""
"Общая конструкция кодирования и декодирования проста, модульна и эффективна."
" Этот дизайн легко вмещает улучшения и дополнения к программе в нескольких"
" областях:"

#: ./en/ch04.md:819
msgid ""
"*   Tuning for greater efficiency \n"
"*   Transmitting multiple return values \n"
"*   Transmitting printed output \n"
"*   Handling errors encountered in the evaluation of the form on the server "
"\n"
"*   Extending this protocol for transmitting additional types of objects "
msgstr ""
"* Настройка для повышения эффективности\n"
"* Передача нескольких возвращаемых значений\n"
"* Передача печатного вывода\n"
"* Обработка ошибок, возникших при вычислении формы на сервере\n"
"* Расширение этого протокола для передачи дополнительных типов объектов"

#: ./en/ch04.md:821
msgid "## 4.5 METHODS FOR INDIVIDUAL LISP OBJECTS"
msgstr "## 4.5 МЕТОДЫ ДЛЯ ОТДЕЛЬНЫХ ОБЪЕКТОВ LISP"

#: ./en/ch04.md:823
msgid ""
"So far, we have seen methods that specialize on the class of the arguments "
"to the generic function. That is, the parameter specializers are classes. "
"Sometimes, it is useful to write a method that specializes on an individual "
"Lisp object. A method that specializes one of its parameters on an "
"individual Lisp object is called an individual method."
msgstr ""
"До сих пор мы видели методы, которые специализируются на классе аргументов"
" обообщенной функции. То есть специализаторы параметров - это классы. Иногда"
" бывает полезно написать метод, который специализируется на отдельном объекте"
" Lisp. Метод, который специализирует один из своих параметров на отдельном"
" объекте Lisp, называется индивидуальным(individual) методом."

#: ./en/ch04.md:825
msgid "### Applicability and Precedence of Individual Methods"
msgstr "### Применимость и приоритет Индивидуальных методов"

#: ./en/ch04.md:827
msgid ""
"Suppose you have an operation that works a certain way when the argument is "
"a number, but should work differently if the argument is the integer 0. "
"Method 2 is an individual method. Its second parameter is specialized on the "
"integer 0. The parameter specializer is the list (eql 0)."
msgstr ""
"Предположим, у вас есть операция, которая работает определенным образом,"
" когда аргументом является число, но должна работать по-другому, если"
" аргументом является целое число 0. Метод 2 - это индивидуальный метод. Его"
" второй параметр специализирован на целом числе 0. Специализатором параметра"
" является список (eql 0)."

#: ./en/ch04.md:837
msgid ""
"<pre>\n"
";;; Method 1 \n"
"(defmethod divide ((dividend number) (divisor number)) \n"
"   (/ dividend divisor)) \n"
";;; Method 2 \n"
"(defmethod divide ((dividend number) (zero (eql 0))) \n"
"   (error \"Cannot divide by zero.\")) \n"
"</pre>\n"
"The lambda-list of an individual method contains a parameter such as "
msgstr ""
"<pre>\n"
";;; Method 1 \n"
"(defmethod divide ((dividend number) (divisor number)) \n"
"   (/ dividend divisor)) \n"
";;; Method 2 \n"
"(defmethod divide ((dividend number) (zero (eql 0))) \n"
"   (error \"Cannot divide by zero.\")) \n"
"</pre>\n"
"Лямбда-список отдельного метода содержит такой параметр, как"

#: ./en/ch04.md:841
msgid ""
"<pre>\n"
"(var (eql form)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:843
msgid ""
"The parameter specializer is (eql object), where object is the result of "
"evaluating the form. The form is evaluated only once, when the method is "
"defined."
msgstr ""
"Специализатором параметра является (eql object), где object - это результат"
" вычисления формы. Форма вычисляется только один раз, когда определен метод."

#: ./en/ch04.md:845
msgid ""
"When divide is called with 0 as its second argument, both methods are "
"applicable. The rule of applicability of individual methods follows. Note "
"that since the test for .applicability uses eql, method 2 is applicable for "
"only the integer 0, and not for 0.0."
msgstr ""
"Когда divide вызывается с 0 в качестве второго аргумента, применимы оба"
" метода. Далее следует правило применимости отдельных методов. Обратите"
" внимание, что, поскольку в тесте на применимость используется eql, метод 2"
" применим только для целого числа 0, а не для 0.0."

#: ./en/ch04.md:853
msgid ""
"|    Rule of applicability of an individual method:                          "
"|\n"
"|----------------------------------------------------------------------------"
"|\n"
"| For a parameter specializer of the form (eql object), the argu-            "
"|\n"
"| ment to the generic function satisfies the parameter specializer           "
"|\n"
"| if the argument is eql to the object. In other words, this expres-         "
"|\n"
"| sion must be true:                                                         "
"|\n"
"| (eql argument 'object)                                                     "
"|"
msgstr ""
"| Правило применимости индивидуального метода:                              "
" |\n"
"|----------------------------------------------------------------------------|"
"\n"
"| Для специализатора параметров формы (объекта eql) аргумент обобщенной     "
" |\n"
"| функции удовлетворяет специализатору параметров, если аргумент является   "
" |\n"
"| eql для объекта. Другими словами, это выражение должно быть истинным:     "
" |\n"
"| (объект аргумента eql ')                                                   |"

#: ./en/ch04.md:855
msgid ""
"Method 2 is more specific, as you would expect. The rule of precedence  of "
"individual methods follows."
msgstr ""
"Метод 2 более специфичен, как и следовало ожидать. Следует правило приоритета"
" отдельных методов."

#: ./en/ch04.md:861
msgid ""
"|    Rule of precedence of an individual method:                             "
"|\n"
"|----------------------------------------------------------------------------"
"|\n"
"| When two parameter specializers are compared, a parameter                  "
"|\n"
"| specializer of the form (eql object) is always more specific than          "
"|\n"
"| a class.                                                                   "
"|"
msgstr ""
"| Правило приоритета отдельного метода:                                     "
" |\n"
"|----------------------------------------------------------------------------|"
"\n"
"| Когда сравниваются два специализатора параметров, параметр,               "
" |\n"
"| специализированный в форме (объект eql), всегда более специфичен, чем     "
" |\n"
"| класс.                                                                     |"

#: ./en/ch04.md:863
msgid "### Examples of Individual Methods"
msgstr "### Примеры индивидуальных методов"

#: ./en/ch04.md:865
msgid ""
"Consider the job of decoding the encoded representations of Lisp objects. "
"Each Lisp object is encoded and decoded according to its type, so it makes "
"sense to write separate methods for encoding and decoding each different "
"type of object."
msgstr ""
"Рассмотрим задачу декодирования закодированных представлений объектов Lisp."
" Каждый объект Lisp кодируется и декодируется в соответствии со своим типом,"
" поэтому имеет смысл писать отдельные методы для кодирования и декодирования"
" каждого отдельного типа объекта."

#: ./en/ch04.md:867
msgid ""
"The encoder has a Lisp object as its argument, so those methods can "
"specialize on the classes of objects. However, the decoder does not have "
"Lisp objects as arguments; instead it reads from a stream and is alerted to "
"the type of an object by the control byte preceding the object in the  "
"stream. Thus, the decoder cannot supply methods that specialize on classes, "
"but it can use individual methods that specialize on each of  these control "
"bytes."
msgstr ""
"Кодировщик имеет объект Lisp в качестве своего аргумента, поэтому эти методы"
" могут специализироваться на классах объектов. Однако декодер не имеет"
" объектов Lisp в качестве аргументов; вместо этого он считывает данные из"
" потока и получает предупреждение о типе объекта с помощью управляющего"
" байта, предшествующего объекту в потоке. Таким образом, декодер не может"
" предоставлять методы, которые специализируются на классах, но он может"
" использовать отдельные методы, которые специализируются на каждом из этих"
" управляющих байтов."

#: ./en/ch04.md:869
msgid "The generic function decode is repeated here:"
msgstr "Здесь повторяется декодирование обобщенной функции:"

#: ./en/ch04.md:876
msgid ""
"<pre>\n"
"(defgeneric decode (code stream) \n"
"   (:documentation \n"
"    \"Based on the code, read an encoded representation \n"
"from the stream, decode, and create an object.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:878
msgid ""
"Each method for decode specializes its first argument, and exactly one "
"method is applicable for each different control byte. Recall that decode is "
"called with one byte as its first argument (this is the control byte) and a "
"stream as its second argument. The definition of remote-eval is repeated "
"here to illustrate how decode is called:"
msgstr ""
"Каждый метод для decode(декодирования) специфицирует свой первый аргумент, и"
" ровно один метод применим для каждого отдельного управляющего байта."
" Напомним, что decode вызывается с одним байтом в качестве первого аргумента"
" (это управляющий байт) и потоком в качестве второго аргумента. Определение"
" remote-eval повторяется здесь, чтобы проиллюстрировать, как вызывается"
" decode:"

#: ./en/ch04.md:887
msgid ""
"<pre>\n"
"(defun remote-eval (stream form) \n"
"   (encode form stream) \n"
"   (force-output stream) \n"
"   ;; Read the return value \n"
"   ;; The first byte is a control byte \n"
"   (decode (read-byte stream) stream)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:889
msgid "### Decoding Integers "
msgstr "### Декодирование целых чисел"

#: ./en/ch04.md:891
msgid ""
"We need two methods to decode integers, because the method for encoding "
"integers sends two different control bytes, depending on whether the integer "
"is positive or negative. The first method is applicable when the first "
"argument is the control byte indicating positive integer. Similarly, the "
"second method is applicable when the first argument is the control byte "
"indicating negative integer."
msgstr ""
"Нам нужны два метода для декодирования целых чисел, потому что метод"
" кодирования целых чисел отправляет два разных управляющих байта, в"
" зависимости от того, является ли целое число положительным или"
" отрицательным. Первый метод применим, когда первым аргументом является"
" управляющий байт, указывающий на положительное целое число. Аналогично,"
" второй метод применим, когда первым аргументом является управляющий байт,"
" указывающий на отрицательное целое число."

#: ./en/ch04.md:895
msgid ""
"<pre>\n"
"(defmethod decode ((code (eql Ipositive-integer)) stream) \n"
"   (decode-integer stream)) "
msgstr ""

#: ./en/ch04.md:898
msgid ""
"(defmethod decode ((code (eql %negative-integer)) stream) \n"
"   (- (decode-integer stream))) "
msgstr ""

#: ./en/ch04.md:906
msgid ""
"(defun decode-integer (stream) \n"
"   (let ((num 0) \n"
"         (n-bytes (read-byte stream))) \n"
"      (dotimes (i n-bytes) \n"
"         (setq num (dpb (read-byte stream) (byte 8 (* i 8)) num))) \n"
"      num)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:908
msgid ""
"%positive-integer and %negative-integer are evaluated exactly once, at the "
"time these methods are defined."
msgstr ""
"%positive-integer и %negative-integer вычисляются ровно один раз, в момент"
" определения этих методов."

#: ./en/ch04.md:910
msgid ""
"The function decode-integer does the sharable part of the work; it is called "
"by both methods. There is no advantage in implementing decode-integer as a "
"generic function."
msgstr ""
"Функция decode-integer выполняет разделяемую часть работы; она вызывается"
" обоими методами. Нет никакого преимущества в реализации decode-integer в"
" качестве обобщенной функции."

#: ./en/ch04.md:912
msgid "### Decoding Characters "
msgstr "### Декодирование символьных знаков(Characters)"

#: ./en/ch04.md:914
msgid ""
"To decode a character, we read one byte and convert it from the ASCII code "
"to the corresponding character code in the native character set. The "
"function ascii-to-char is implementation dependent and is not provided here."
msgstr ""
"Чтобы декодировать символьный знак, мы считываем один байт и преобразуем его"
" из кода ASCII в соответствующий код символьного знака в нативном наборе"
" символьных знаков. Функция ascii-to-char зависит от реализации и здесь не"
" предусмотрена."

#: ./en/ch04.md:919
msgid ""
"<pre>\n"
"(defmethod decode ((code (eql %character)) stream) \n"
"   (ascii-to-char (read-byte stream))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:921
msgid "### Decoding Lists and Vectors"
msgstr "### Декодирование списков и векторов"

#: ./en/ch04.md:923
msgid ""
"To decode a list or vector, we read the length of the sequence, then decode "
"each element in the sequence. Again, we can use a function to do the "
"sharable part of the work."
msgstr ""
"Чтобы декодировать список или вектор, мы считываем длину последовательности,"
" затем декодируем каждый элемент в последовательности. Опять же, мы можем"
" использовать функцию для выполнения разделяемой части работы."

#: ./en/ch04.md:927
msgid ""
"<pre>\n"
"(defmethod decode ((code (eql %list)) stream) \n"
"   (decode-sequence stream 'list)) "
msgstr ""

#: ./en/ch04.md:930
msgid ""
"(defmethod decode ((code (eql %vector)) stream) \n"
"   (decode-sequence stream 'vector)) "
msgstr ""

#: ./en/ch04.md:939
msgid ""
"(defun decode-sequence (stream type) \n"
"   (let* ((length (decode (read-byte stream) stream)) \n"
"          (seq (make-sequence type length))) \n"
"      (dotimes (i length) \n"
"         (setf (elt seq i) \n"
"               (decode (read-byte stream) stream))) \n"
"      seq)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:941
msgid "### Decoding Strings "
msgstr "### Декодирование строк"

#: ./en/ch04.md:943
msgid ""
"To decode a string, we read the length of the string, then each character of "
"the string."
msgstr ""
"Чтобы декодировать строку, мы считываем длину строки, затем каждый символьный"
" знак строки."

#: ./en/ch04.md:952
msgid ""
"<pre>\n"
"(defmethod decode ((code (eql Istring)) stream) \n"
"   (let* ((length (decode (read-byte stream) stream)) \n"
"          (string (make-string length))) \n"
"      (dotimes (i length) \n"
"         (setf (aref string i) (ascii-to-char (read-byte stream)))) \n"
"      string)) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:954
msgid "### Decoding Symbols "
msgstr "### Декодирование символов"

#: ./en/ch04.md:956
msgid ""
"To decode a symbol, we first decode the name and then decode the package. "
"Note that this method does not create a package if it does not already "
"exist. "
msgstr ""
"Чтобы декодировать символьный знак, мы сначала расшифровываем название, а"
" затем расшифровываем пакет. Обратите внимание, что этот метод не создает"
" пакет, если он еще не существует."

#: ./en/ch04.md:973
msgid ""
"<pre>\n"
";;; Does not create the package. \n"
"(defmethod decode ((code (eql %symbol)) stream) \n"
"   (let ((code (read-byte stream))) \n"
"      (when (/- %string code) \n"
"         (error \"The symbol's name must be a string.\")) \n"
"      (let ((symbol-name (decode code stream))) \n"
"         (setq code (read-byte stream)) \n"
"         (when (/- %string code) \n"
"            (error \"The symbol's package name must be a string.\")) \n"
"         (let* ((pkg-name (decode code stream)) \n"
"                (pkg (find-package pkg-name))) \n"
"            (when (null pkg) \n"
"               (error \"Package named ~A not found.\" pkg-name)) \n"
"            (intern symbol-name pkg))))) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:975
msgid "## 4.6 SUMMARY OF METHOD INHERITANCE "
msgstr "## 4.6 КРАТКОЕ ОПИСАНИЕ НАСЛЕДОВАНИЯ МЕТОДОВ"

#: ./en/ch04.md:977
msgid ""
"The inheritance of methods involves two separate mechanisms. Both happen "
"automatically as part of the generic dispatch."
msgstr ""
"Наследование методов включает в себя два отдельных механизма. И то, и другое"
" происходит автоматически как часть generic dispatch(обобщенной"
" диспетчеризации)."

#: ./en/ch04.md:980
msgid ""
"1. Selecting the set of applicable methods \n"
"2. Ranking the applicable methods in order of precedence "
msgstr ""
"1. Выбор набора применимых методов"
"2. Ранжирование применимых методов в порядке приоритета"

#: ./en/ch04.md:982
msgid ""
"To select the set of applicable methods, CLOS requires knowledge of the "
"arguments to the generic function, and the methods defined for the generic "
"function. The following general rule takes into account all kinds of "
"methods, including methods that specialize only one parameter, multi-"
"methods, and individual methods:"
msgstr ""
"Чтобы выбрать набор применимых методов, CLOS требует знания аргументов"
" обобщенной функции и методов, определенных для обобщенной функции. Следующее"
" общее правило учитывает все виды методов, включая методы, которые"
" специализируются только на одном параметре, мультиметоды и отдельные методы:"

#: ./en/ch04.md:994
msgid ""
"|     General rule of method applicability:                                 |"
"\n"
"|---------------------------------------------------------------------------|"
"\n"
"|  A method is applicable if each of its required parameters is sat-        |"
"\n"
"|  isfied by the corresponding argument (arg) to the generic func-          |"
"\n"
"|  tion.                                                                    |"
"\n"
"|---------------------------------------------------------------------------|"
"\n"
"|         Required Parameter     |        Test                              |"
"\n"
"|--------------------------------|------------------------------------------|"
"\n"
"| (var (eql form))               |  (eql arg 'object)                       |"
"\n"
"| (var class-name)               |  (typep arg 'class-name)                 |"
"\n"
"|  var                           |  (typep arg 't)                          |"
msgstr ""
"| Общее правило применимости метода:                                         "
"                   |\n"
"|-----------------------------------------------------------------------------"
"--------------------------------------------|\n"
"| Метод применим, если каждому из его требуемых параметров удовлетворяет |\n"
"| соответствующий аргумент (arg) обобщенной функции.             |\n"
"\n"
"\n"
"| Требуемый параметр  | Тест                 |\n"
"|-----------------------------------|-------------------------|\n"
"| (var (eql form))             |  (eql arg 'object) |\n"
"| (var class-name)          |  (typep arg 'class-name)|\n"
"|  var                             |  (typep arg 't)    |"

#: ./en/ch04.md:996
msgid ""
"In the first case, the object is obtained by evaluating form once, at the "
"time the method is defined. In the last case, the required parameter is "
"unspecialized, which is equivalent to being specialized on the class t. Any "
"argument satisfies an unspecialized parameter, because every Lisp object is "
"of the type t."
msgstr ""
"В первом случае объект получается путем оценки формы один раз, в момент"
" определения метода. В последнем случае требуемый параметр является"
" неспециализированным, что эквивалентно специализации на классе t. Любой"
" аргумент удовлетворяет неспециализированному параметру, поскольку каждый"
" объект Lisp имеет тип t."

#: ./en/ch04.md:998
msgid ""
"To rank applicable methods in order of precedence, CLOS requires knowledge "
"of the following: "
msgstr ""
"Чтобы ранжировать применимые методы в порядке приоритета, CLOS требует знания"
" следующего:"

#: ./en/ch04.md:1002
msgid ""
"*    The set of applicable methods \n"
"*    The class precedence list of the class of each required argument to the "
"generic function \n"
"*    The argument precedence order of the generic function"
msgstr ""
"* Набор применимых методов\n"
"* Список приоритета класса каждого требуемого аргумента обобщенной функции\n"
"* Порядок приоритета аргументов обобщенной функции"

#: ./en/ch04.md:1004
msgid ""
"When ranking the precedence of two methods, CLOS compares the parameter "
"specializers of the methods. An unspecialized parameter is equivalent to the "
"class named t being the parameter specializier."
msgstr ""
"При ранжировании приоритета двух методов CLOS сравнивает специализаторы"
" параметров методов. Неспециализированный параметр эквивалентен классу с"
" именем t, являющемуся специализатором параметра."

#: ./en/ch04.md:1007
msgid ""
"Normally, the argument precedence order is left to right, meaning that CLOS "
"starts by comparing the first (leftmost) parameter specializer of method A "
"to the first parameter specializer of method B. If the two parameter "
"specializers are different, CLOS uses the following rule to determine which "
"parameter specializer is more specific and ranks the methods on that basis, "
"without considering any other parameter specializers. If the two parameter "
"specializers are the same, however, CLOS cannot rank the precedence of the "
"methods on that basis. CLOS proceeds to the next pair of parameter "
"specializers, and so on, until it finds a pair of parameter specializers "
"that are different; then the methods are \n"
"ranked on the basis of that pair of parameter specializers."
msgstr ""
"Обычно порядок приоритета аргументов слева направо, что означает, что CLOS"
" начинается со сравнения первого (крайнего левого) специализатора параметров"
" метода A с первым специализатором параметров метода B. Если два"
" специализатора параметров различны, CLOS использует следующее правило, чтобы"
" определить, какой специализатор параметров более специфичен, и ранжирует"
" методы на этой основе, не принимая во внимание какие-либо другие"
" специализаторы параметров. Однако, если два специализатора параметров"
" одинаковы, CLOS не может ранжировать приоритет методов на этой основе. CLOS"
" переходит к следующей паре специализаторов параметров и так далее, пока не"
" найдет пару специализаторов параметров, которые отличаются; затем методы"
" ранжируются на основе этой пары специализаторов параметров."

#: ./en/ch04.md:1009
msgid ""
"If two methods have all the same parameter specializers, they must have "
"different qualifiers. In this case, it does not matter which method is more "
"specific."
msgstr ""
"Если два метода имеют одинаковые спецификаторы параметров, они должны иметь"
" разные квалификаторы. В этом случае не имеет значения, какой метод является"
" более конкретным."

#: ./en/ch04.md:1014
msgid ""
"|   Rule of ranking parameter specializers:                              |\n"
"|------------------------------------------------------------------------|\n"
"| A parameter specializer of (eql object) is more specific than a        |\n"
"| class.                                                                 |"
msgstr ""
"| Правило ранжирования специализаторов параметров:                       |\n"
"|------------------------------------------------------------------------|\n"
"| Специализатор параметров (eql object) более специфичен, чем            |\n"
"| класс.                                                                 |"

#: ./en/ch04.md:1019
msgid ""
"When both parameter specializers are classes, they are ranked \n"
"according to the class precedence list of the class of the corre- \n"
"sponding argument to the generic function. The class precedence \n"
"list indicates which class is more specific than the other. "
msgstr ""
"Когда оба специализатора параметров являются классами, они ранжируются в"
" соответствии со списком приоритетов классов класса соответствующего"
" аргумента универсальной функции. Список приоритетов классов указывает, какой"
" класс более специфичен, чем другой."

#: ./en/ch04.md:1022
msgid "### Argument Precedence Order "
msgstr "### Порядок приоритета Аргументов"

#: ./en/ch04.md:1024
msgid ""
"The precedence of methods depends on the argument precedence order of the "
"generic function. By default, CLOS uses left-to-right argument precedence "
"order, which means the first argument (the leftmost) is more important in "
"ranking precedence than the following arguments. You can use the :argument-"
"precedence-order option to defgeneric to specify a different order."
msgstr ""
"Приоритет методов зависит от порядка приоритета аргументов обобщенной"
" функции. По умолчанию CLOS использует порядок приоритета аргументов слева"
" направо, что означает, что первый аргумент (самый левый) более важен для"
" ранжирования приоритета, чем следующие аргументы. Вы можете использовать"
" параметр :argument-precedence-order для defgeneric, чтобы указать другой"
" порядок."

#: ./en/ch04.md:1026
msgid ""
"The argument precedence order is important when CLOS ranks two methods that "
"specialize different parameters or methods that specialize more than one "
"parameter. Consider the following methods:"
msgstr ""
"Порядок приоритета аргументов важен, когда CLOS ранжирует два метода, которые"
" специализируются на разных параметрах, или методы, которые специализируются"
" более чем на одном параметре. Рассмотрим следующие методы:"

#: ./en/ch04.md:1031
msgid ""
"<pre>\n"
";;; Method A \n"
"(defmethod install ((sw basic-product) non-os) \n"
"   body)"
msgstr ""

#: ./en/ch04.md:1036
msgid ""
";;; Method B \n"
"(defmethod install (non-product (os basic-os)) \n"
"   body) \n"
"</pre>"
msgstr ""

#: ./en/ch04.md:1038
msgid ""
"Method A specializes its first parameter but leaves its second parameter "
"unspecialized. Method B specializes its second parameter but leaves its "
"first parameter unspecialized. If we consider the first parameters in "
"isolation, method A is more specific, because any specialized parameter "
"takes precedence over an unspecialized one. However, if we consider the "
"second parameters in isolation, method B is more specific. The argument "
"precedence order resolves this conflict by stating which of the arguments "
"should be considered first."
msgstr ""
"Метод A специализируется на своем первом параметре, но оставляет свой второй"
" параметр неспециализированным. Метод B специализирует свой второй параметр,"
" но оставляет свой первый параметр неспециализированным. Если мы рассмотрим"
" первые параметры изолированно, метод A более специфичен, поскольку любой"
" специализированный параметр имеет приоритет над неспециализированным."
" Однако, если мы рассмотрим вторые параметры изолированно, метод B более"
" специфичен. Порядок приоритета аргументов разрешает этот конфликт, указывая,"
" какой из аргументов следует рассмотреть первым."
