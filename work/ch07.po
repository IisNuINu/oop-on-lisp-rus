#. extracted from ./en/ch07.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-07 11:32+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch07.md:2
msgid "# Defining CLOS Elements"
msgstr "## Определение элементов CLOS"

#: ./en/ch07.md:4
msgid ""
"In this chapter, we describe what happens when you define classes, methods, "
"and generic functions. We discuss the following topics: the order in which "
"you should define CLOS elements, the congruence rules for lambda-lists of a "
"generic function and its methods, the Lisp objects that represent the CLOS "
"elements, and the relationships between these objects and their names."
msgstr ""
"В этой главе мы опишем, что происходит, когда вы определяете классы, методы и"
" обобщенные функции. Мы обсуждаем следующие темы: порядок, в котором вы"
" должны определять элементы CLOS, правила соответствия для лямбда-списков"
" обобщенной функции и ее методов, объекты Lisp, которые представляют элементы"
" CLOS, и отношения между этими объектами и их именами."

#: ./en/ch07.md:6
msgid "## 7.1 ORDER OF DEFINING CLOS ELEMENTS"
msgstr "## 7.1 ПОРЯДОК ОПРЕДЕЛЕНИЯ ЭЛЕМЕНТОВ CLOS"

#: ./en/ch07.md:8
msgid ""
"CLOS is quite flexible in allowing you to define CLOS elements in various "
"orders:"
msgstr ""
"CLOS достаточно гибок, позволяя вам определять элементы CLOS в различных"
" порядках:"

#: ./en/ch07.md:11
msgid ""
"*   When designing a class organization, you can define the classes in any "
"order; you can define a class before defining its superclasses. \n"
"*   You can define methods and generic functions in any order. If you define "
"a method before defining the generic function, CLOS automatically creates "
"the generic function. The lambda-list of the generic function is derived "
"from the method's lambda-list; all other aspects of the generic function are "
"defaulted. If you use defgeneric later, the existing generic function is "
"modified. "
msgstr ""
"* При проектировании организации классов вы можете определять классы в любом"
" порядке; вы можете определить класс до определения его суперклассов.\n"
"* Вы можете определять методы и обобщенные функции в любом порядке. Если вы"
" определяете метод до определения обобщенной функции, CLOS автоматически"
" создает обобщенную функцию. Лямбда-список обобщенной функции является"
" производным от лямбда-списка метода; все остальные аспекты обобщенной"
" функции по умолчанию. Если вы используете defgeneric позже, существующая"
" обобщенная функция будет изменена."

#: ./en/ch07.md:13
msgid "There are, however, some ordering dependencies: "
msgstr "Однако существуют некоторые зависимости от порядка:"

#: ./en/ch07.md:16
msgid ""
"*   Before you make an instance of a class, that class and all its "
"superclasses must be defined \n"
"*   Before you define a method that specializes on a class, that class "
"itself must be defined"
msgstr ""
"* Прежде чем вы создадите экземпляр класса, этот класс и все его суперклассы"
" должны быть определены"
"* Прежде чем вы определите метод, который специализируется на классе, сам"
" этот класс должен быть определен"

#: ./en/ch07.md:18
msgid "## 7.2 CONGRUENT LAMBDA-LISTS "
msgstr "## 7.2 КОНГРУЭНТНЫЕ ЛЯМБДА-СПИСКИ"

#: ./en/ch07.md:20
msgid ""
"When a defgeneric form is evaluated and no methods for the generic function "
"exist, the defgeneric form establishes a parameter pattern that must be "
"followed by all the methods. If a method is defined before a defgeneric form "
"has been evaluated, that method establishes the pattern. The parameter "
"pattern is derived from the lambda-list of the defmethod or defgeneric form. "
"It specifies the number of required parameters, the number of optional "
"parameters, and whether srest, skey, or both are used."
msgstr ""
"Когда вычисляется defgeneric форма и не существует методов для обобщенной"
" функции, defgeneric форма устанавливает шаблон параметров, которому должны"
" следовать все методы. Если метод определен до того, как была вычислена"
" defgeneric форма, этот метод устанавливает шаблон. Шаблон параметра является"
" производным от лямбда-списка формы defmethod или defgeneric. В нем"
" указывается количество обязательных параметров, количество необязательных"
" параметров и то, используются ли &rest, &key или оба."

#: ./en/ch07.md:22
msgid ""
"Once the pattern is established, if any defmethod form or defgeneric form is "
"evaluated that does not match the pattern, CLOS signals an error. To match "
"the pattern, the following CLOS congruence rules must be obeyed:"
msgstr ""
"Как только шаблон установлен, если вычисляется какая-либо форма defmethod или"
" форма defgeneric, которая не соответствует шаблону, CLOS сигнализирует об"
" ошибке. Чтобы соответствовать шаблону, необходимо соблюдать следующие"
" правила соответствия CLOS:"

#: ./en/ch07.md:26
msgid ""
"*   The number of required parameters must be the same as in the established "
"pattern. \n"
"*   The number of optional parameters must be the same as in the established "
"pattern. Methods can supply default values for optional parameters, but the "
"defgeneric form cannot. \n"
"*   If the established pattern uses srest or skey, all methods and the "
"defgeneric form must use srest, or skey, or both."
msgstr ""
"* Количество требуемых параметров должно быть таким же, как в установленном"
" шаблоне.\n"
"* Количество необязательных параметров должно быть таким же, как в"
" установленном шаблоне. Методы могут предоставлять значения по умолчанию для"
" необязательных параметров, но defgeneric форма не может.\n"
"* Если установленный шаблон использует &rest или &key, все методы и форма"
" defgeneric должны использовать &rest, или &key, или оба."

#: ./en/ch07.md:28
msgid ""
"Keyword parameters are treated specially. A defgeneric form can state a "
"requirement regarding skey parameters, whether or not the parameter pattern "
"was established before the defgeneric form was evaluated. We state the rules "
"for keyword parameters here, and then explain them further."
msgstr ""
"Параметры ключевых слов обрабатываются особым образом. Форма defgeneric может"
" указывать требование относительно параметров &key, независимо от того, был"
" ли шаблон параметров установлен до того, как была оценена форма defgeneric."
" Здесь мы излагаем правила для параметров ключевых слов, а затем объясняем их"
" далее."

#: ./en/ch07.md:31
msgid ""
"*   If a defgeneric form specifies skey, its set of keyword parameters must "
"be accepted by each of the methods. In other words, the defgeneric form "
"states the minimum set of keywords that must be accepted by all the methods. "
"The methods can accept the keywords by naming them explicitly with skey, by "
"using Srest and not skey, or by specifying sallow-other-keys. \n"
"*   Each method can name skey parameters in addition to the set specified by "
"the defgeneric form; the only requirement is that all methods must accept "
"the minimal set specified by the defgeneric."
msgstr ""
"* Если в форме defgeneric указан &key, его набор параметров ключевого слова"
" должен быть принят каждым из методов. Другими словами, в форме defgeneric"
" указывается минимальный набор ключевых слов, которые должны быть приняты"
" всеми методами. Методы могут принимать ключевые слова, явно называя их &key,"
" используя &rest, а не &key, или указывая &allow-other-keys.\n"
"* Каждый метод может называть параметры &key в дополнение к набору,"
" указанному в форме defgeneric; единственное требование состоит в том, что"
" все методы должны принимать минимальный набор, указанный в defgeneric."

#: ./en/ch07.md:33
msgid ""
"For generic functions that use skey parameters, the keyword arguments are "
"checked for validity when the generic function is called. The set of "
"accepted keywords is controlled by the defgeneric form and the applicable "
"methods. A keyword argument is accepted by the generic function call if it "
"is accepted by the defgeneric form or by one or more applicable methods."
msgstr ""
"Для обобщенной функций, использующих параметры &key, аргументы ключевого"
" слова проверяются на достоверность при вызове обобщенной функции. Набор"
" принятых ключевых слов контролируется формой defgeneric и применимыми"
" методами. Аргумент ключевого слова принимается вызовом обобщенной функции,"
" если он принят формой defgeneric или одним или несколькими применимыми"
" методами."

#: ./en/ch07.md:35
msgid ""
"In general, a generic function passes all its arguments to each method it "
"calls. Nevertheless, no error is signaled if a generic function calls a "
"method with a keyword argument that is not explicitly accepted by the "
"method. The generic function checks the validity of keyword arguments; this "
"checking is not done by the individual methods."
msgstr ""
"В общем случае обобщенная функция передает все свои аргументы каждому"
" вызываемому ею методу. Тем не менее, ошибка не выдается, если обобщенная"
" функция вызывает метод с аргументом ключевого слова, который явно не"
" принимается методом. Обобщенная функция проверяет достоверность аргументов"
" ключевого слова; эта проверка не выполняется отдельными методами."

#: ./en/ch07.md:37
msgid ""
"If the defgeneric form or any method for the generic function uses &allow-"
"other-keys, all keyword arguments are accepted when the generic function is "
"called."
msgstr ""
"Если defgeneric форма или любой метод для обобщенной функции использует"
" &allow-other-keys, все аргументы ключевого слова принимаются при вызове"
" обобщенной функции."

#: ./en/ch07.md:39
msgid ""
"In general, CLOS signals an error if a method or generic function is defined "
"that does not adhere to these congruence rules. This can happen in the "
"following situations:"
msgstr ""
"Как правило, CLOS сигнализирует об ошибке, если определен метод или"
" универсальная функция, которые не соответствуют этим правилам соответствия."
" Это может произойти в следующих ситуациях:"

#: ./en/ch07.md:43
msgid ""
"*   A defmethod or defgeneric form is evaluated that does not match the "
"established pattern \n"
"*   A defmethod form is evaluated that does not accept the minimal set of "
"keyword arguments specified by the defgeneric form \n"
"*   A defgeneric form is evaluated and an existing method does not accept "
"the minimal set of keyword arguments specified by the defgeneric form "
msgstr ""
"* Оценивается(вычисляется) defmethod или defgeneric форма, которая не"
" соответствует установленному шаблону\n"
"* Вычисляется форма defmethod, которая не принимает минимальный набор"
" аргументов ключевого слова, указанный формой defgeneric\n"
"* Вычисляется форма defgeneric, и существующий метод не принимает минимальный"
" набор аргументов ключевого слова, указанный defgeneric формой\n"

#: ./en/ch07.md:45
msgid "## 7.3 LISP OBJECTS REPRESENTING CLOS ELEMENTS"
msgstr "## 7.3 ОБЪЕКТЫ LISP, ПРЕДСТАВЛЯЮЩИЕ ЭЛЕМЕНТЫ CLOS"

#: ./en/ch07.md:47
msgid ""
"When you use defclass, the returned value is a class object. Similarly, "
"defgeneric returns a generic function object and defmethod returns a method "
"object. These Lisp objects are the internal representation of CLOS classes, "
"generic functions, and methods."
msgstr ""
"Когда вы используете defclass, возвращаемое значение является объектом"
" класса. Аналогично, defgeneric возвращает объект обобщенной функции, а"
" defmethod возвращает объект метода. Эти объекты Lisp являются внутренним"
" представлением классов CLOS, обобщенных функций и методов."

#: ./en/ch07.md:49
msgid ""
"When writing application programs, you usually do not need to deal directly "
"with the Lisp objects representing the CLOS elements. Instead, you refer to "
"these objects by their names. For example, when you use defclass, you create "
"a class object and give it a name. Later, you refer to the class by its name—"
"for example, when using make-instance. Similarly, you refer to a generic "
"function by its name when defining it (using defgeneric), creating methods "
"for it (using defmethod), and calling it."
msgstr ""
"При написании прикладных программ вам обычно не нужно иметь дело"
" непосредственно с объектами Lisp, представляющими элементы CLOS. Вместо"
" этого вы ссылаетесь на эти объекты по их именам. Например, когда вы"
" используете defclass, вы создаете объект класса и даете ему имя. Позже вы"
" будете ссылаться на класс по его имени — например, при использовании"
" make-instance. Аналогично, вы ссылаетесь на обобщенную функцию по ее имени"
" при ее определении (используя defgeneric), создании методов для нее"
" (используя defmethod) и вызове ее."

#: ./en/ch07.md:51
msgid ""
"The CLOS programmer interface can be divided into two separate levels. The "
"macros defclass, defmethod, and defgeneric are in the \"macro level,\" which "
"has a convenient syntax and enables you to deal with names of objects. The "
"macro level is implemented in terms of the \"functional level,\" which deals "
"with objects and not with names. Most application programs can be written "
"entirely in terms of the macro level. The functional level offers greater "
"flexibility, such as supporting anonymous classes and generic functions."
msgstr ""
"Интерфейс программатора CLOS можно разделить на два отдельных уровня. Макросы"
" defclass, defmethod и defgeneric находятся на \"Макроуровень/уровне"
" макросов\", который имеет удобный синтаксис и позволяет вам работать с"
" именами объектов. Макроуровень реализован в терминах \"функционального"
" уровня\", который имеет дело с объектами, а не с именами. Большинство"
" прикладных программ могут быть написаны полностью в терминах макроуровня."
" Функциональный уровень обеспечивает большую гибкость, такую как поддержка"
" анонимных классов и обобщенных функций."

#: ./en/ch07.md:53
msgid "## 7.4 MAPPING BETWEEN NAMES AND OBJECTS "
msgstr "## 7.4 СОПОСТАВЛЕНИЕ МЕЖДУ ИМЕНАМИ И ОБЪЕКТАМИ"

#: ./en/ch07.md:55
msgid ""
"This section describes the relationships between the names of CLOS elements "
"and the Lisp objects that represent them."
msgstr ""
"В этом разделе описываются взаимосвязи между именами элементов CLOS и"
" объектами Lisp, которые их представляют."

#: ./en/ch07.md:57
msgid "### Classes "
msgstr "### Классы"

#: ./en/ch07.md:59
msgid ""
"When you use defclass, the returned value is a class object. That class "
"object has a name, which is a symbol. Actually, there are two associations "
"between the name of the class and the class object. The defclass macro sets "
"up both of these associations automatically."
msgstr ""
"Когда вы используете defclass, возвращаемое значение является объектом"
" класса. У этого объекта класса есть имя, которое является символом. На самом"
" деле, есть две ассоциации между именем класса и объектом класса. Макрос"
" defclass автоматически устанавливает обе эти ассоциации."

#: ./en/ch07.md:61
msgid ""
"One association is maintained by the class object itself. You can query a "
"class object for its name by using class-name and use (setf class-name) to "
"change that association:"
msgstr ""
"Одна ассоциация поддерживается самим объектом класса. Вы можете запросить у"
" объекта класса его имя с помощью class-name и использовать (setf class-name)"
" для изменения этой ассоциации:"

#: ./en/ch07.md:66
msgid ""
"<pre>\n"
"(class-name class-object) \n"
"(setf (class-name class-object) symbol) \n"
"</pre>"
msgstr ""

#: ./en/ch07.md:68
msgid ""
"The other association is maintained by a symbol. You can query a symbol for "
"the class with that name by using find-class and use (setf find-class) to "
"change that association:"
msgstr ""
"Когда вы используете defclass, возвращаемое значение является объектом"
" класса. У этого объекта класса есть имя, которое является символом. На самом"
" деле, есть две ассоциации между именем класса и объектом класса. Макрос"
" defclass автоматически устанавливает обе эти ассоциации."

#: ./en/ch07.md:73
msgid ""
"<pre>\n"
"(find-class symbol) \n"
"(setf (find-class symbol) class-object) \n"
"</pre>"
msgstr ""

#: ./en/ch07.md:75
msgid ""
"You use class-name to ask \"What is the name of this class object?\" and you "
"use find-class to ask \"What is the class object with this name?\" "
msgstr ""
"Вы используете class-name, чтобы спросить \"Как называется этот объект"
" класса?\", и вы используете find-class, чтобы спросить \"Что это за объект"
" класса с таким именем?\""

#: ./en/ch07.md:78
msgid ""
"![Figure 7.1: Links between a class and its name.](images/f07-01.jpg)\n"
"**Figure 7.1: Links between a class and its name.**"
msgstr ""
"![Рисунок 7.1: Связи между классом и его именем.](images/f07-01.jpg )"
"**Рисунок 7.1: Связи между классом и его именем.**"

#: ./en/ch07.md:80
msgid ""
"Figure 7.1 shows that these two associations are independent. Changing the "
"class associated with a name (maintained by the symbol) does not affect the "
"name associated with a class (maintained by the class object). Therefore, "
"the two associations can become out of synch with each other."
msgstr ""
"На рисунке 7.1 показано, что эти две ассоциации независимы. Изменение класса,"
" связанного с именем (поддерживаемым символом), не влияет на имя, связанное с"
" классом (поддерживаемое объектом класса). Таким образом, две ассоциации"
" могут стать несинхронизированными друг с другом."

#: ./en/ch07.md:82
msgid "### Generic Functions "
msgstr "### Обобщенные функции"

#: ./en/ch07.md:84
msgid ""
"Generic functions are named just as ordinary functions are named. A generic "
"function object is stored in the function cell of a symbol; that symbol is "
"the name of the generic function. You can query a symbol for the generic "
"function associated with it by using symbol-function, and use (setf symbol-"
"function) to change that association."
msgstr ""
"Обобщенные функции именуются точно так же, как именуются обычные функции."
" Объект обобщенной функции хранится в функциональной ячейке символа; этот"
" символ является именем обобщенной функции. Вы можете запросить символ для"
" обобщенной функции, связанной с ним, используя symbol-function, и"
" использовать (setf symbol-function), чтобы изменить эту ассоциацию."

#: ./en/ch07.md:86
msgid ""
"Since generic and ordinary functions are named in the same way, the Common "
"Lisp technique of using packages to keep related functions and symbols "
"together is just as useful for generic functions as it is for ordinary "
"functions. Also, one symbol cannot name both an ordinary and a generic "
"function."
msgstr ""
"Поскольку обобщенные и обычные функции называются одинаково, технология"
" Common Lisp, заключающаяся в использовании пакетов для объединения связанных"
" функций и символов, так же полезна для обобщенных функций, как и для обычных"
" функций. Кроме того, один символ не может называть как обычную, так и"
" обобщенную функцию."

#: ./en/ch07.md:88
msgid ""
"In Lisp, functions need not have names; you can use lambda to define an "
"anonymous function. CLOS does not require that generic functions have names. "
"To create an anonymous generic function, you can use the generic-function "
"macro. It has the same syntax as defgeneric, except there is no argument for "
"the name of the generic function."
msgstr ""
"В Lisp функции не обязательно должны иметь имена; вы можете использовать"
" lambda для определения анонимной функции. CLOS не требует, чтобы обобщенные"
" функции имели имена. Чтобы создать анонимную обобщенную функцию, вы можете"
" использовать макрос generic-function. Он имеет тот же синтаксис, что и"
" defgeneric, за исключением того, что в нем нет аргумента для имени"
" обобщенной функции."

#: ./en/ch07.md:90
msgctxt "./en/ch07.md:90"
msgid "### Methods"
msgstr "### Методы"

#: ./en/ch07.md:92
msgid ""
"Methods do not have names. A method is identified by the generic function it "
"implements, its parameter specializes, and its qualifiers. Rarely would you "
"need to access a method directly. Usually, you simply define methods, and "
"they are called automatically by the generic dispatch procedure. One "
"situation in which you need to access a method occurs when you want to use "
"remove-method to break the association between a generic function and a "
"method. We give an example of this in \"Removing Generic Functions and "
"Methods,\" page 136. "
msgstr ""
"Методы не имеют имен. Метод идентифицируется по обобщенной функции, которую"
" он реализует, специализации его параметров и его квалификаторам. Редко вам"
" понадобится прямой доступ к методу. Обычно вы просто определяете методы, и"
" они автоматически вызываются generic dispatch procedure(процедурой общей "
" отправки). Одна ситуация, в которой вам необходимо получить доступ к методу,"
" возникает, когда вы хотите использовать remove-method, чтобы разорвать связь"
" между обобщенной функцией и методом. Мы приводим пример этого в разделе"
" \"Удаление Обобщенных функций и методов\", стр. 136."

#: ./en/ch07.md:94
msgid "### Parameter Specializers"
msgstr "### Специализаторы параметров"

#: ./en/ch07.md:96
msgid ""
"CLOS distinguishes between the names of parameter specializers and the "
"objects that represent them. Only parameter specializer names appear in the "
"defmethod lambda-list, whereas operators in the functional level use "
"parameter specializer objects."
msgstr ""
"CLOS различает имена специализаторов параметров и объекты, которые их"
" представляют. В лямбда-списке defmethod отображаются только имена"
" специализаторов параметров, тогда как операторы на функциональном уровне"
" используют объекты специализатора параметров."

#: ./en/ch07.md:103
msgid ""
"| Name         | Corresponding Object           |\n"
"|--------------|--------------------------------|\n"
"| a class name | the class object of that name, |\n"
"|              | which is obtained by find-class| \n"
"| (eql form)   | (eql object), where object is  |\n"
"|              | the result of evaluating form  |"
msgstr ""
"| Имя          | Соответствующий объект                 |\n"
"|--------------|----------------------------------------|\n"
"| имя класса   | объект класса с таким именем,          |\n"
"|              | который получается с помощью find-class|\n"
"| (форма eql)  |(объект eql), где объект - это          |\n"
"|              | результат оценки формы                 |"

#: ./en/ch07.md:105
msgid "## 7.5 REMOVING GENERIC FUNCTIONS AND METHODS"
msgstr "## 7.5 УДАЛЕНИЕ ОБОБЩЕННЫХ ФУНКЦИЙ И МЕТОДОВ"

#: ./en/ch07.md:107
msgid ""
"This section describes how to \"remove\" the definition of a generic "
"function or method, in the sense of making sure that it is never called."
msgstr ""
"В этом разделе описывается, как \"удалить(remove)\" определение обобщенной"
" функции или метода в смысле обеспечения того, чтобы она никогда не"
" вызывалась."

#: ./en/ch07.md:109
msgid "### Generic Functions"
msgstr "### Обобщенные функции"

#: ./en/ch07.md:111
msgid ""
"You can remove a generic function by breaking the association between the "
"name and the object. Just as for ordinary functions, you can do this by "
"using fmakunbound."
msgstr ""
"Вы можете удалить метод, разорвав связь между объектом метода и обобщенной"
" функцией. Хотя CLOS не предоставляет удобного макроса для этого, вы можете"
" использовать remove-method и find-method, два оператора на функциональном"
" уровне CLOS. Как упоминалось ранее, функциональный уровень имеет дело с"
" объектами, а не с именами. Чтобы использовать эти операторы, мы должны"
" получить доступ к объекту обобщенной  функции, объекту метода и объектам"
" специализатора параметров. Синтаксис remove-method таков"

#: ./en/ch07.md:113
msgctxt "./en/ch07.md:113"
msgid "### Methods"
msgstr "### Методы"

#: ./en/ch07.md:115
msgid ""
"You can remove a method by breaking the association between the method "
"object and the generic function. Although CLOS does not provide a convenient "
"macro for doing this, you can use remove-method and find-method, two "
"operators in the CLOS functional level. As mentioned earlier, the functional "
"level deals in objects, not names. To use these operators, we must access a "
"generic function object, a method object, and parameter specializer objects. "
"The syntax of remove-method is"
msgstr ""
"Вы можете удалить метод, разорвав связь между объектом метода и обобщенной"
" функцией. Хотя CLOS не предоставляет удобного макроса для этого, вы можете"
" использовать remove-method и find-method, два оператора на функциональном"
" уровне CLOS. Как упоминалось ранее, функциональный уровень имеет дело с"
" объектами, а не с именами. Чтобы использовать эти операторы, мы должны"
" получить доступ к объекту обобщенной  функции, объекту метода и объектам"
" специализатора параметров. Синтаксис remove-method таков"

#: ./en/ch07.md:119
msgid ""
"<pre>\n"
"(remove-method generic-function-object method-object) \n"
"</pre>"
msgstr ""

#: ./en/ch07.md:121
msgid ""
"To access the generic function object, use symbol-function of the name of "
"the generic function. To access the method object, use the find-method "
"generic function. The syntax of find-method is "
msgstr ""
"Чтобы получить доступ к объекту обобщенной функции, используйте"
" символ-функцию имени обобщенной функции. Чтобы получить доступ к объекту"
" метода, используйте обобщенную функцию find-method. Синтаксис find-method"
" таков"

#: ./en/ch07.md:127
msgid ""
"<pre>\n"
"(find-method generic-function-object \n"
"             ({method-qualifier} *) \n"
"             ({parameter-specializer-objects} *)) \n"
"</pre>"
msgstr ""

#: ./en/ch07.md:129
msgid ""
"The list of parameter specializer objects must have as many elements as "
"there are required parameters. An unspecialized required parameter has the "
"class named t as its parameter specializer."
msgstr ""
"Список объектов специализатора параметров должен содержать столько элементов,"
" сколько имеется требуемых параметров. Неспециализированный требуемый"
" параметр имеет класс с именем t в качестве специализатора параметров."

#: ./en/ch07.md:131
msgid ""
"Here, we show an example of removing a method. The parameter specializer "
"names are class names, so we access the parameter specializer objects by "
"using find-class."
msgstr ""
"Здесь мы покажем пример удаления метода. Имена специализатора параметров -"
" это имена классов, поэтому мы получаем доступ к объектам специализатора"
" параметров с помощью findclass."

#: ./en/ch07.md:136
msgid ""
"<pre>\n"
";;; The method to remove \n"
"(defmethod restore-product :before (sw (os genera)) \n"
"   body) "
msgstr ""

#: ./en/ch07.md:144
msgid ""
";;; Removing the method \n"
"(let* ((generic-function (symbol-function 'restore-product)) \n"
"       (method (find-method generic-function \n"
"                            '(:before) \n"
"                            (list (find-class 't) \n"
"                                  (find-class 'genera))))) \n"
"   (remove-method generic-function method)) \n"
"</pre>"
msgstr ""
