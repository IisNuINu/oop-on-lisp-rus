#. extracted from ./en/ch08.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-07 21:10+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch08.md:2
msgid "# Redefining CLOS Elements"
msgstr "# Переопределение элементов CLOS"

#: ./en/ch08.md:4
msgid ""
"To redefine an element of CLOS is to evaluate a new defining form (such as a "
"defmethod form) when that element (the method) already exists. In general, "
"CLOS replaces the old definition with the new."
msgstr ""
"Переопределение элемента CLOS означает вычисление/оценку новой определяющей"
" формы (например, формы defmethod), когда этот элемент (метод) уже"
" существует. В общем, CLOS заменяет старое определение новым."

#: ./en/ch08.md:6
msgid ""
"The capability of redefining classes and methods is crucial to software "
"development. It allows you to continue to refine your design of a running "
"program even after you have created instances; when a class is redefined, "
"any existing instances are updated to the new definition. Often, the most "
"challenging part of designing an object-oriented program is choosing the "
"right modularity. Sometimes, when you begin writing methods, you think of a "
"better organization of classes that would yield more modular code. CLOS "
"supports a flexible means of redefining classes and methods, so you have the "
"freedom to modify your original design, including the organization of "
"classes."
msgstr ""
"Возможность переопределения классов и методов имеет решающее значение для"
" разработки программного обеспечения. Это позволяет вам продолжать"
" совершенствовать дизайн запущенной программы даже после создания"
" экземпляров; когда класс переопределяется, все существующие экземпляры"
" обновляются до нового определения. Часто самой сложной частью проектирования"
" объектно-ориентированной программы является выбор правильной модульности."
" Иногда, когда вы начинаете писать методы, вы думаете о лучшей организации"
" классов, которая дала бы более модульный код. CLOS поддерживает гибкие"
" средства переопределения классов и методов, поэтому у вас есть свобода"
" изменять свой первоначальный дизайн, включая организацию классов."

#: ./en/ch08.md:8
msgid ""
"In this chapter, we give an example of redefining a class, updating "
"instances to the new class definition, and redefining affected methods. The "
"first goal of this example is to illustrate the mechanics of redefining CLOS "
"elements. The second goal is to give some guidelines on designing a program "
"in which most of the elements are independent of one another; in such a "
"program, you can redefine one element without affecting most of the other "
"elements. "
msgstr ""
"В этой главе мы приводим пример переопределения класса, обновления"
" экземпляров в соответствии с новым определением класса и переопределения"
" затронутых методов. Первая цель этого примера - проиллюстрировать механику"
" переопределения элементов CLOS. Вторая цель состоит в том, чтобы дать"
" некоторые рекомендации по разработке программы, в которой большинство"
" элементов независимы друг от друга; в такой программе вы можете"
" переопределить один элемент, не затрагивая большинство других элементов."

#: ./en/ch08.md:10
msgid "## 8.1 REDEFINING CLASSES"
msgstr "## 8.1 ПЕРЕОПРЕДЕЛЕНИЕ КЛАССОВ"

#: ./en/ch08.md:12
msgid ""
"If you evaluate a defclass form and a class of that name already exists, the "
"new class definition replaces the old. You can redefine a class to change "
"any aspect of it, including its slots, its superclasses, its accessor "
"methods, and any defclass options."
msgstr ""
"Если вы оцениваете форму defclass и класс с таким именем уже существует,"
" новое определение класса заменяет старое. Вы можете переопределить класс,"
" чтобы изменить любой его аспект, включая его слоты, суперклассы, методы"
" доступа и любые параметры defclass."

#: ./en/ch08.md:14
msgid "### What Is Affected by the Redefinition"
msgstr "### На что влияет переопределение"

#: ./en/ch08.md:16
msgid ""
"Note that changing a class definition affects all subclasses of the class, "
"because they inherit structure from the class. Since a class controls the "
"structure of its instances, all instances of the class and subclasses are "
"also affected. In addition, since defclass options define methods for "
"readers and writers, these methods might also be affected by redefining a "
"class. When you redefine a class, CLOS automatically propagates the changes "
"to everything that is affected, including subclasses, instances of the class "
"and of subclasses, and methods for accessors."
msgstr ""
"Обратите внимание, что изменение определения класса влияет на все подклассы"
" класса, поскольку они наследуют структуру от класса. Поскольку класс"
" управляет структурой своих экземпляров, это также влияет на все экземпляры"
" класса и подклассов. Кроме того, поскольку параметры defclass определяют"
" методы для чтения и записи, переопределение класса также может повлиять на"
" эти методы. Когда вы переопределяете класс, CLOS автоматически"
" распространяет изменения на все, что затронуто, включая подклассы,"
" экземпляры класса и подклассов, а также методы для средств доступа."

#: ./en/ch08.md:18
msgid "### What Happens to Accessor Methods"
msgstr "### Что происходит с методами доступа"

#: ./en/ch08.md:20
msgid ""
"Any accessor method that was created by the old class definition (by means "
"of the :accessor, : reader, or :writer slot options), but is not requested "
"by the new class definition, is removed from the generic function."
msgstr ""
"Любой метод доступа, который был создан в соответствии со старым определением"
" класса (с помощью параметров слота :accessor, :reader или :writer), но не"
" запрашивается новым определением класса, удаляется из обобщенной функции."

#: ./en/ch08.md:22
msgid "### Automatic Updating of Instances"
msgstr "### Автоматическое обновление экземпляров"

#: ./en/ch08.md:24
msgid ""
"When you redefine a class such that the structure of the instances changes ("
"which happens when you add or delete slots, for example), all instances of "
"the class and its subclasses must be updated to the new structure. CLOS "
"updates the instances automatically."
msgstr ""
"Когда вы переопределяете класс таким образом, что структура экземпляров"
" изменяется (что происходит, например, при добавлении или удалении слотов),"
" все экземпляры класса и его подклассы должны быть обновлены до новой"
" структуры. CLOS автоматически обновляет экземпляры."

#: ./en/ch08.md:26
msgid ""
"CLOS specifies that the updating of each instance happens at some time "
"before any slot of that instance is accessed for reading or writing. "
"Although you cannot assume the updating of instances happens immediately "
"upon evaluating the new class definition, the effect is semantically the "
"same; you are safeguarded from ever accessing an obsolete instance."
msgstr ""
"CLOS указывает, что обновление каждого экземпляра происходит за некоторое"
" время до того, как какой-либо слот этого экземпляра будет доступен для"
" чтения или записи. Хотя вы не можете предположить, что обновление"
" экземпляров происходит сразу после оценки нового определения класса,"
" семантически эффект тот же; вы защищены от любого доступа к устаревшему"
" экземпляру."

#: ./en/ch08.md:28
msgid ""
"CLOS updates instances as they are needed, instead of all at once. Thus, "
"CLOS does not need to keep track of all instances of a class and any "
"unreferenced instances can be garbage collected. "
msgstr ""
"CLOS обновляет экземпляры по мере необходимости, а не все сразу. Таким"
" образом, CLOS не нужно отслеживать все экземпляры класса, и любые экземпляры"
" без ссылок могут быть убраны сборщиком мусора."

#: ./en/ch08.md:30
msgid "### What Happens to the Slots of Existing Instances"
msgstr "### Что происходит со слотами существующих экземпляров"

#: ./en/ch08.md:32
msgid ""
"When you redefine a class, the slots specified in the new definition might "
"be different from the slots of the old definition. There are three common "
"cases:"
msgstr ""
"Когда вы переопределяете класс таким образом, что структура экземпляров"
" изменяется (что происходит, например, при добавлении или удалении слотов),"
" все экземпляры класса и его подклассы должны быть обновлены до новой"
" структуры. CLOS автоматически обновляет экземпляры."

#: ./en/ch08.md:36
msgid ""
"*   When the same slot is specified in both definitions, the value of the "
"slot is preserved. \n"
"*    When a slot is specified by the new definition, but was not specified "
"by the old, the slot is added to instances and initialized according to the :"
"initform option. \n"
"*    When a slot specified by the old definition is not specified by the "
"new, the slot is deleted from the instance and any value is discarded. "
"However, the values of deleted slots are not immediately discarded; you can "
"access them by writing a method to customize the updating."
msgstr ""
"* Если в обоих определениях указан один и тот же слот, значение слота"
" сохраняется.\n"
"* Когда слот указан в новом определении, но не был указан в старом, слот"
" добавляется в экземпляры и инициализируется в соответствии с параметром"
" :initform.\n"
"* Когда слот, указанный в старом определении, не указан в новом, слот"
" удаляется из экземпляра и любое значение отбрасывается. Однако значения"
" удаленных слотов не удаляются сразу; вы можете получить к ним доступ,"
" написав метод для настройки обновления."

#: ./en/ch08.md:38
msgid ""
"We summarize this information in Table 8.1, which also shows what happens "
"when the allocation type of a slot is changed from local to shared, or from "
"shared to local. The entries in Table 8.1 have the following meanings:"
msgstr ""
"Мы обобщаем эту информацию в таблице 8.1, в которой также показано, что"
" происходит, когда тип распределения слота изменяется с локального на общий"
" или с общего на локальный. Записи в таблице 8.1 имеют следующие значения:"

#: ./en/ch08.md:42
msgid ""
"\t     > preserved         The value of the slot is the same before and "
"after the instance is\n"
"\t     >                   updated. If the slot was previously unbound, it "
"is still unbound after\n"
"\t     >                   the updating."
msgstr ""
"\t     > preserved(сохранено)       Значение слота остается одинаковым до и"
" после обновления экземпляра. \n"
"\t     >                                        Если слот ранее был не"
" привязан, он все еще не привязан после обновления."

#: ./en/ch08.md:46
msgid ""
"\t     > initialized       The slot receives the value of the :initform of "
"the slot, if one is\n"
"\t     >                   specified by the class or inherited from "
"superclasses. If there is no\n"
"\t     >                   :initform, the value of the slot is unbound."
msgstr ""
"\t     > initialized(инициализирован)    Слот получает значение :initform"
" слота, если он указан классом или\n"
"\t     >                                               унаследован от"
" суперклассов. Если нет :initform, значение слота не\n"
"\t     >                                               привязано."

#: ./en/ch08.md:48
msgid ""
"\t     > discarded         The slot is deleted from instances and its value "
"is lost."
msgstr ""
"\t     > discarded(отброшен)            Слот удаляется из экземпляров, и его"
" значение теряется."

#: ./en/ch08.md:54
msgid ""
"|             | Shared (New) | Local (New) | None (New) |\n"
"|-------------|--------------|-------------|------------|\n"
"| shared (old)| preserved    | preserved   | discarded  |\n"
"| local (old) | initialized  | preserved   | discarded  |\n"
"| none (old)  | initialized  | initialized | no action  |"
msgstr ""

#: ./en/ch08.md:56
msgid "Table 8.1 Effects on slots when a class is redefined. "
msgstr "Таблица 8.1 Влияет на слоты при переопределении класса."

#: ./en/ch08.md:58
msgctxt "./en/ch08.md:58"
msgid "### Customizing the Updating "
msgstr "### Настройка обновления"

#: ./en/ch08.md:60
msgid ""
"CLOS enables you to specify other actions to be taken when an instance is "
"updated to conform to the new definition of the class. To do so, you can "
"provide a method for update-instance-for-redefined-class to do further work "
"in updating instances. The body of the method can access the values of "
"discarded slots, which you can use to initialize other slots."
msgstr ""
"CLOS позволяет указать другие действия, которые необходимо предпринять при"
" обновлении экземпляра в соответствии с новым определением класса. Для этого"
" вы можете предоставить метод update-instance-for-redefined-class для"
" выполнения дальнейшей работы по обновлению экземпляров. Тело метода может"
" получить доступ к значениям отброшенных слотов, которые вы можете"
" использовать для инициализации других слотов."

#: ./en/ch08.md:62
msgid ""
"When you redefine a class, CLOS updates the structure of the class and the "
"subclasses (if necessary) and removes or adds accessor methods (if necessary)"
". CLOS updates the structure of each instance (at an implementation-"
"dependent time prior to the next access of a slot of the instance), by "
"adding new slots and deleting obsolete slots. Finally, CLOS calls the update-"
"instance-for-redefined-class generic function. The default primary method "
"for update-instance-for-redefined-class initializes slots in the way "
"described previously."
msgstr ""
"Когда вы переопределяете класс, CLOS обновляет структуру класса и подклассов"
" (при необходимости) и удаляет или добавляет методы доступа (при"
" необходимости). CLOS обновляет структуру каждого экземпляра (в зависящее от"
" реализации время до следующего доступа к слоту экземпляра), добавляя новые"
" слоты и удаляя устаревшие слоты. Наконец, CLOS вызывает обобщенную функцию"
" update-instance-for-redefined-class. Основной метод по умолчанию для"
" update-instance-for-redefined-class инициализирует слоты способом, описанным"
" ранее."

#: ./en/ch08.md:64
msgid ""
"In most cases, users should provide before- or after-methods for update-"
"instance-for-redefined-class, not primary methods. A primary method would "
"override the default method that initializes new slots, and would prevent "
"the usual initialization from happening. If you initialize a slot in a "
"before-method, the default primary method does not fill the slot with its "
"initform."
msgstr ""
"В большинстве случаев пользователи должны предоставлять методы before-(до)"
" или after-(после) для update-instance-for-redefined-class, а не первичные"
" методы. Основной метод переопределил бы метод по умолчанию, который"
" инициализирует новые слоты, и предотвратил бы обычную инициализацию. Если вы"
" инициализируете слот в методе before, основной метод по умолчанию не"
" заполняет слот своей initform."

#: ./en/ch08.md:66
msgid ""
"You can customize update-instance-for-redefined-class to store values in the "
"new slots based on values of slots being discarded. As a simple example, to "
"rename a slot you can write a method to store the value of the discarded "
"slot into the new slot."
msgstr ""
"Вы можете настроить update-instance-for-redefined-class для сохранения"
" значений в новых слотах на основе значений отбрасываемых слотов. В качестве"
" простого примера, чтобы переименовать слот, вы можете написать метод для"
" сохранения значения отброшенного слота в новый слот."

#: ./en/ch08.md:68
msgid ""
"The update-instance-for-redefined-class generic function has four required "
"arguments and one srest argument:"
msgstr ""
"Обобщенная функция update-instance-for-redefined-class имеет четыре"
" обязательных аргумента и один аргумент &rest:"

#: ./en/ch08.md:70
msgid ""
"\t     > instance           The instance, which has been updated to the new "
"structure "
msgstr ""
"\t     > instance(экземпляр)       Экземпляр, который был обновлен до новой"
" структуры"

#: ./en/ch08.md:72
msgid "\t     > added-slots        A list of the names of the added slots"
msgstr ""
"\t     > added-slots(добавленные слоты)      Список названий добавленных"
" слотов"

#: ./en/ch08.md:74
msgid "\t     > discarded-slots    A list of the names of the discarded slots"
msgstr ""
"\t     > discarded-slots(отброшенные слоты)  Список названий отброшенных"
" слотов"

#: ./en/ch08.md:78
msgid ""
"\t     > property-list      A list containing alternating names and values "
"of the discarded slots\n"
"\t     >                    (not including any discarded slots that were "
"unbound), and any slots\n"
"\t     >                    specified as local in the old definition and "
"shared in the new definition"
msgstr ""
"\t     > property-list(свойство-список)      Список, содержащий чередующиеся"
" имена и значения отброшенных\n"
"\t     >                                                   слотов (не включая"
" любые отброшенные слоты, которые были\n "
"\t     >                                                   несвязаны), и"
" любые слоты, указанные как локальные в старом\n"
"\t     >                                                   определении и"
" совместно используемые в новом определении"

#: ./en/ch08.md:81
msgid ""
"\t     > &rest initargs     The srest argument is rarely used; we discuss it "
"in \"Performing \n"
"\t     >                    Initialization by Initargs,\" page 168 "
msgstr ""
"\t    > &rest initargs           Аргумент &rest используется редко; мы"
" обсуждаем его в разделе \"Выполнение\n"
"\t    >                               инициализации с помощью Initargs\","
" стр. 168"

#: ./en/ch08.md:83
msgid ""
"The most useful argument is the property-list, which gives you a way to "
"access the values of discarded slots. For an example of redefining a class "
"and defining a method for update-instance-for-redefined-class, see \"Example "
"of Redefining CLOS Elements,\" page 144."
msgstr ""
"Наиболее полезным аргументом является список свойств, который дает вам"
" возможность получить доступ к значениям отброшенных слотов. Пример"
" переопределения класса и определения метода для обновления экземпляра для"
" переопределенного класса см. в разделе \"Пример переопределения элементов"
" CLOS\", стр. 144."

#: ./en/ch08.md:85
msgid "## 8.2 REDEFINING METHODS AND GENERIC FUNCTIONS"
msgstr "## 8.2 ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ И ОБОБЩЕННЫХ ФУНКЦИЙ"

#: ./en/ch08.md:87
msgid "### Methods"
msgstr "### Методы"

#: ./en/ch08.md:89
msgid ""
"If you evaluate a defmethod form, and a method already exists for the same "
"generic function, with the same parameter specializes and the same "
"qualifiers, the new method definition replaces the old."
msgstr ""
"Если вы вычисляете форму defmethod, и метод уже существует для той же"
" обобщенной функции с тем же специализирующим параметром и теми же"
" квалификаторами, новое определение метода заменяет старое."

#: ./en/ch08.md:91
msgid ""
"Any future calls to the generic function will see the new definition of the "
"method. If the method is redefined during the execution of the generic "
"function itself, the effects are not predictable. Many CLOS implementations "
"optimize portions of the generic dispatch, so it is possible that the new "
"method definition will not be used for this generic function call."
msgstr ""
"Любые будущие вызовы обобщенной функции будут видеть новое определение"
" метода. Если метод переопределяется во время выполнения самой обобщенной"
" функции, последствия непредсказуемы. Многие реализации CLOS оптимизируют"
" части общей отправки, поэтому возможно, что новое определение метода не"
" будет использоваться для этого вызова обобщенной  функции."

#: ./en/ch08.md:93
msgid "### Generic Functions"
msgstr "### Обобщенные функции"

#: ./en/ch08.md:95
msgid ""
"If you evaluate a defgeneric form and a generic function already exists by "
"that name, defgeneric redefines the existing generic function. An error is "
"signaled if any methods for the generic function are not congruent with the "
"lambda-list specified by the defgeneric. When you redefine a generic "
"function, the new definition of the generic function replaces the old "
"definition."
msgstr ""
"Если вы вычисляете defgeneric форму и обобщенная функция с таким именем уже"
" существует, defgeneric переопределяет существующую обобщенную функцию."
" Выдается сообщение об ошибке, если какие-либо методы для обобщенной функции"
" не соответствуют лямбда-списку, указанному defgeneric. Когда вы"
" переопределяете обобщенную функцию, новое определение обобщенной функции"
" заменяет старое определение."

#: ./en/ch08.md:97
msgid ""
"A defgeneric form can define methods, by including the :method option. The :"
"method option to defgeneric has the same effect as using defmethod to define "
"a method for that generic function. Sometimes, it is useful to define "
"methods in the defgeneric form itself, especially for default methods. This "
"is a way to highlight the default behavior. For examples of using that "
"syntax, see \"Defining Directional Streams,\" page 180."
msgstr ""
"Форма defgeneric может определять методы, включая параметр :method. Параметр"
" :method для defgeneric имеет тот же эффект, что и использование defmethod"
" для определения метода для этой обобщенной функции. Иногда полезно"
" определять методы в самой форме defgeneric, особенно для методов по"
" умолчанию. Это способ выделить поведение по умолчанию. Примеры использования"
" этого синтаксиса см. в разделе \"Определение направленных потоков\", стр."
" 180."

#: ./en/ch08.md:100
msgid ""
"If you redefine a generic function and the new defgeneric form uses the :"
"method option, two things can happen. If that method already exists (a "
"method for the same generic function with the same parameter specializers "
"and the same qualifiers), it is replaced by the method defined in the :"
"method option. If that method does not already exist, it is created. "
"Redefining a generic function might add methods to the generic function and "
"might replace methods, but it never removes methods: If the previous "
"defgeneric defined a method with the :method option, but the current "
"defgeneric does not define that method, the method object \n"
"continues to exist in Lisp."
msgstr ""
"Если вы переопределяете обобщенные функцию, а новая форма defgeneric"
" использует параметр :method, могут произойти две вещи. Если этот метод уже"
" существует (метод для той же обобщенной функции с теми же спецификаторами"
" параметров и теми же квалификаторами), он заменяется методом, определенным в"
" опции :method. Если этот метод еще не существует, он создается."
" Переопределение обобщенной функции может добавить методы к обобщенной"
" функции и может заменить методы, но оно никогда не удаляет методы: если"
" предыдущий defgeneric определил метод с параметром :method, но текущий"
" defgeneric не определяет этот метод, объект метода продолжает существовать в"
" Lisp."

#: ./en/ch08.md:102
msgid ""
"You cannot use defgeneric to redefine an ordinary Lisp function, macro, or "
"special form. An error is signaled if you evaluate a defgeneric form and the "
"first argument is the name of an ordinary function, macro, or special form. "
"In contrast, you can use defun to redefine a generic function. If you define "
"an ordinary Lisp function, macro, or special form with the same name as an "
"existing generic function, that name is no longer associated with the "
"generic function."
msgstr ""
"Вы не можете использовать defgeneric для переопределения обычной функции"
" Lisp, макроса или специальной формы. Сообщение об ошибке выдается, если вы"
" вычисляете defgeneric форму, а первым аргументом является имя обычной"
" функции, макроса или специальной формы. Напротив, вы можете использовать"
" defun для переопределения обобщенной функции. Если вы определяете обычную"
" функцию Lisp, макрос или специальную форму с тем же именем, что и"
" существующая обобщенная функция, это имя больше не связано с обобщенной"
" функцией."

#: ./en/ch08.md:104
msgid "## 8.3 EXAMPLE OF REDEFINING CLOS ELEMENTS"
msgstr "## 8.3 ПРИМЕР ПЕРЕОПРЕДЕЛЕНИЯ ЭЛЕМЕНТОВ CLOS"

#: ./en/ch08.md:106
msgid ""
"The purpose of this example is to show how easily you can redefine portions "
"of a CLOS program, even after instances have been created and clients are "
"using the program."
msgstr ""
"Цель этого примера - показать, как легко вы можете переопределить части"
" программы CLOS, даже после того, как экземпляры были созданы и клиенты"
" используют программу."

#: ./en/ch08.md:108
msgid ""
"First, we define two protocols for dealing with triangles, one external ("
"intended for clients) and one internal (to be used within the implementation "
"of this program). We then define the implementation of both protocols, "
"including the class for representing triangles and a set of methods."
msgstr ""
"Сначала мы определяем два протокола для работы с треугольниками, один внешний"
" (предназначенный для клиентов) и один внутренний (который будет"
" использоваться в рамках реализации этой программы). Затем мы определяем"
" реализацию обоих протоколов, включая класс для представления треугольников и"
" набор методов."

#: ./en/ch08.md:110
msgid ""
"Later, we decide to change the internal representation of triangles. We can "
"do this without altering the external protocol at all. However, the change "
"requires only that we redefine some of the methods for the internal protocol "
"and provide a method for updating any existing triangles to the new "
"representation."
msgstr ""
"Позже мы решаем изменить внутреннее представление треугольников. Мы можем"
" сделать это вообще без изменения внешнего протокола. Однако изменение"
" требует только того, чтобы мы переопределили некоторые методы для"
" внутреннего протокола и предоставили метод для обновления любых существующих"
" треугольников до нового представления."

#: ./en/ch08.md:112
msgid "### The External Triangle Protocol "
msgstr "### Внешний Протокол треугольника"

#: ./en/ch08.md:114
msgid ""
"The interface that we advertise to clients consists of the following "
"operations: "
msgstr ""
"Интерфейс, который мы рекламируем(предоставляем) клиентам, состоит из"
" следующих операций:"

#: ./en/ch08.md:118
msgid ""
"\t     >  make-triangle side-a side-b side-c\n"
"\t     >           Returns a new triangle; each argument is the length of "
"one side of \n"
"\t     >           the triangle "
msgstr ""
"\t     >  make-triangle side-a side-b side-c\n"
"\t     >           Возвращает новый треугольник; каждый аргумент - это длина"
" одной стороны треугольника"

#: ./en/ch08.md:121
msgid ""
"\t     >  area triangle \n"
"\t     >           Returns the area of the triangle"
msgstr ""
"\t     >  area triangle \n"
"\t     >           Возвращает площадь треугольника"

#: ./en/ch08.md:126
msgid ""
"\t     >  dimensions triangle \n"
"\t     >           Returns a list of the lengths of the three sides of the "
"triangle \n"
"\t     >           angles triangle \n"
"\t     >           Returns a list of the three angles of the triangle "
msgstr ""
"\t     >  dimensions triangle \n"
"\t     >           Возвращает список длин трех сторон треугольника \n"
"\t     >  angles triangle \n"
"\t     >           Возвращает список трех углов треугольника"

#: ./en/ch08.md:128
msgid "### The Internal Triangle Protocol "
msgstr "### Внутренний Протокол треугольника"

#: ./en/ch08.md:130
msgid ""
"The following six operations are useful within the implementation, because "
"they are all needed for supporting the external protocol. Clients are not "
"expected to use these operations."
msgstr ""
"Следующие шесть операций полезны в рамках реализации, поскольку все они"
" необходимы для поддержки внешнего протокола. Ожидается, что клиенты не будут"
" использовать эти операции."

#: ./en/ch08.md:134
msgid ""
"\t     >        side-a triangle                    angle-A triangle \n"
"\t     >        side-b triangle                    angle-B triangle \n"
"\t     >        side-c triangle                    angle-C triangle "
msgstr ""

#: ./en/ch08.md:136
msgid ""
"Each of these operations returns one aspect of the triangle: either the "
"length of one side, or the measurement of one angle. Note that angle-A is "
"the angle opposite side-a. Figure 8.1 shows how the angles and sides are "
"related to one another."
msgstr ""
"Каждая из этих операций возвращает один аспект треугольника: либо длину одной"
" стороны, либо измерение одного угла. Обратите внимание, что angle-A - это"
" угол, противоположной стороне side-a. На рисунке 8.1 показано, как углы и"
" стороны связаны друг с другом."

#: ./en/ch08.md:139
msgid ""
"![Figure 8.1: Angles and sides of a triangle.](images/f07-01.jpg)\n"
"**Figure 8.1: Angles and sides of a triangle.**"
msgstr ""
"![Рисунок 8.1: Углы и стороны треугольника.](images/f07-01.jpg )"
"**Рисунок 8.1: Углы и стороны треугольника.**"

#: ./en/ch08.md:141
msgid "### The Initial Implementation "
msgstr "### Первоначальная Реализация"

#: ./en/ch08.md:143
msgid ""
"First, we implement the triangle class. The internal representation of "
"triangles is straightforward; we store the length of each side in a slot. By "
"using the :reader option, we can conveniently provide methods for side-a, "
"side-b, and side-c."
msgstr ""
"Во-первых, мы реализуем класс triangle. Внутреннее представление"
" треугольников простое; мы сохраняем длину каждой стороны в ячейке. Используя"
" опцию :reader, мы можем удобно предоставить методы для side-a, side-b и"
" side-c."

#: ./en/ch08.md:147
msgid ""
"<pre>\n"
"(defclass shape () () \n"
"  (:documentation \"The foundation of all shapes.\")) "
msgstr ""

#: ./en/ch08.md:154
msgid ""
"(defclass triangle (shape) \n"
"  ((a :reader side-a :initarg :side-a) \n"
"   (b :reader side-b :initarg :side-b) \n"
"   (c :reader side-c :initarg :side-c))) \n"
"</pre>\n"
"Next, we provide the constructor, make-triangle. This constructor coerces "
"each side length into the type float prior to making the instance, to ensure "
"that all mathematical operations on sides use floating-point arithmetic."
msgstr ""
"(defclass triangle (shape) \n"
"  ((a :reader side-a :initarg :side-a) \n"
"   (b :reader side-b :initarg :side-b) \n"
"   (c :reader side-c :initarg :side-c))) \n"
"</pre>\n"
"Далее мы предоставляем конструктор make-triangle. Этот конструктор приводит"
" длину каждой стороны к типу float перед созданием экземпляра, чтобы"
" гарантировать, что все математические операции со сторонами используют"
" арифметику с плавающей запятой."

#: ./en/ch08.md:162
msgid ""
"<pre>\n"
"(defun make-triangle (a b c) \n"
"   ;; All sides should be represented as floats \n"
"   (make-instance 'triangle :side-a (coerce a 'float) \n"
"                            :side-b (coerce b 'float) \n"
"                            :side-c (coerce c 'float))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:164
msgid ""
"The function three-sides-to-angle will be useful in the bodies of the "
"methods that return the angles of the triangle. "
msgstr ""
"Функция three-sides-to-angle будет полезна в телах методов, которые"
" возвращают углы треугольника."

#: ./en/ch08.md:175
msgid ""
"<pre>\n"
";;; Return the angle A between adjacent sides b and c \n"
";;; and opposite side a, given all sides of a triangle \n"
";;; Law of Cosines: aA2 - bA2 + cA2 - 2bc(cos A) \n"
"(defun three-sides-to-angle (a b c) \n"
"   (acos (/ (- (+ (expt b 2) \n"
"                  (expt c 2)) \n"
"               (expt a 2)) \n"
"            (* 2 b c)))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:177
msgid ""
"Next, we define the methods for returning the individual angles of a "
"triangle: "
msgstr "Далее мы определяем методы для возврата отдельных углов треугольника:"

#: ./en/ch08.md:182
msgid ""
"<pre>\n"
"(defmethod angle-A ((tri triangle)) \n"
"   (three-sides-to-angle \n"
"    (side-a tri) (side-b tri) (side-c tri))) "
msgstr ""

#: ./en/ch08.md:186
msgid ""
"(defmethod angle-B ((tri triangle)) \n"
"   (three-sides-to-angle \n"
"    (side-b tri) (side-c tri) (side-a tri))) "
msgstr ""

#: ./en/ch08.md:191
msgid ""
"(defmethod angle-C ((tri triangle)) \n"
"   (three-sides-to-angle \n"
"    (side-c tri) (side-a tri) (side-b tri))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:193
msgid ""
"We choose to define explicitly the generic functions for the operations that "
"are part of the external protocol. The defgeneric forms indicate that these "
"three operations are intended to work on any shape: "
msgstr ""
"Мы решили явно определить общие функции для операций, которые являются частью"
" внешнего протокола. Defgeneric формы указывают, что эти три операции"
" предназначены для работы с любой формой:"

#: ./en/ch08.md:197
msgid ""
"<pre>\n"
"(defgeneric dimensions (shape) \n"
"   (:documentation \"Returns list of side lengths.\")) "
msgstr ""

#: ./en/ch08.md:200
msgid ""
"(defgeneric angles (shape) \n"
"   (:documentation \"Returns list of angles.\")) "
msgstr ""

#: ./en/ch08.md:204
msgid ""
"(defgeneric area (shape) \n"
"   (:documentation \"Returns area of the shape.\")) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:206
msgid ""
"The three external operations that deal with existing triangles can be "
"defined in terms of the internal operations, without depending on any "
"knowledge of how those internal operations are implemented. "
msgstr ""
"Три внешние операции, которые имеют дело с существующими треугольниками,"
" могут быть определены в терминах внутренних операций, не зависящих от"
" каких-либо знаний о том, как реализуются эти внутренние операции."

#: ./en/ch08.md:212
msgid ""
"<pre>\n"
"(defmethod dimensions ((tri triangle)) \n"
"   (list (side-a tri) \n"
"         (side-b tri) \n"
"         (side-c tri))) "
msgstr ""

#: ./en/ch08.md:217
msgid ""
"(defmethod angles ((tri triangle)) \n"
"   (list (angle-A tri) \n"
"         (angle-B tri) \n"
"         (angle-C tri)))"
msgstr ""

#: ./en/ch08.md:225
msgid ""
";;; Return the area of a triangle \n"
";;; Algorithm is: area = ab(sin C)/2 \n"
"(defmethod area ((tri triangle)) \n"
"   (* (side-a tri) (side-b tri) \n"
"      (sin         (angle-C tri)) \n"
"      .5)) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:227
msgid "### Changing the Representation of Triangles "
msgstr "### Изменение представления треугольников"

#: ./en/ch08.md:229
msgid ""
"Now we decide to change the internal representation of triangles. We want to "
"redefine the triangle class to store two sides and the angle between them, "
"instead of storing three sides."
msgstr ""
"Теперь мы решаем изменить внутреннее представление треугольников. Мы хотим"
" переопределить класс triangle, чтобы хранить две стороны и угол между ними,"
" вместо того, чтобы хранить три стороны."

#: ./en/ch08.md:231
msgid ""
"For a real program, one possible motivation for changing the internal "
"representation would be to increase the efficiency of an operation. In this "
"case, the angle-C operation probably will be faster when the method simply "
"reads the value of a slot instead of doing the somewhat expensive "
"calculation of computing the angle from the three sides. On the other hand, "
"side-c will be slower. This is a tradeoff based on how the program is used."
msgstr ""
"Для реальной программы одной из возможных мотиваций для изменения внутреннего"
" представления было бы повышение эффективности операции. В этом случае"
" операция angle-C, вероятно, будет быстрее, когда метод просто считывает"
" значение слота вместо выполнения несколько дорогостоящего вычисления угла с"
" трех сторон. С другой стороны, side-c будет медленнее. Это компромисс,"
" основанный на том, как используется программа."

#: ./en/ch08.md:233
msgid ""
"The following class definition can replace the previous class definition. At "
"this point, we write the defclass form, but we do not evaluate it "
"immediately. Prior to redefining the class, we must ensure that any existing "
"instances will be updated properly."
msgstr ""
"Следующее определение класса может заменить предыдущее определение класса. На"
" этом этапе мы пишем форму defclass, но не вычисляем ее сразу. Прежде чем"
" переопределять класс, мы должны убедиться, что все существующие экземпляры"
" будут обновлены должным образом."

#: ./en/ch08.md:240
msgid ""
"<pre>\n"
"(defclass triangle (shape) \n"
"  ((a :reader side-a :initarg :side-a) \n"
"   (b :reader side-b :initarg :side-b) \n"
"   (angle-C :reader angle-C :initarg :angle-C))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:242
msgid ""
"Note that this class definition creates a method for the reader generic "
"function, angle-C. In fact, this method will replace the existing method for "
"the generic function angle-C. (We should also remove the previous definition "
"of the angle-C method from the source.) This is exactly what we want; when "
"the new class definition is evaluated, the angle-C generic function will "
"return the value of the angle-C slot, instead of calculating the angle from "
"the three sides of the triangle. "
msgstr ""
"Обратите внимание, что это определение класса создает метод для обобщенной"
" функции чтения(reader), angle-C. Фактически, этот метод заменит существующий"
" метод для обобщенной функции angle-C. (Мы также должны удалить предыдущее"
" определение метода angle-C из источника.) Это именно то, что мы хотим; при"
" вычислении нового определения класса обобщенной функция angle-C вернет"
" значение слота angle-C вместо вычисления угла с трех сторон треугольника."

#: ./en/ch08.md:244
msgid ""
"To update the instances, we provide a method for update-instance-for-"
"redefined-class. We choose to supply an after-method, so as not to override "
"the system-supplied default method. This is a safe practice, even though in "
"this case none of the slots use the :initform slot option, and thus do not "
"need to be initialized in this way. Possibly the class triangle has a "
"subclass with slots that do need to be initialized from their initforms. "
"Unless we have an explicit reason for preventing the system-supplied method "
"from occurring, it is best to allow it to run."
msgstr ""
"Чтобы обновить экземпляры, мы предоставляем метод для"
" update-instance-for-redefined-class. Мы выбираем использовать метод"
" after-method, чтобы не переопределять системный метод по умолчанию. Это"
" безопасная практика, даже несмотря на то, что в этом случае ни один из"
" слотов не использует опцию слота :initform и, следовательно, не нуждается в"
" инициализации таким образом. Возможно, у класса triangle есть подкласс со"
" слотами, которые необходимо инициализировать из их initforms. Если у нас нет"
" явной причины для предотвращения запуска системного метода, лучше всего"
" разрешить ему запуск."

#: ./en/ch08.md:246
msgid ""
"The values of the slots a and b are preserved, since these are local slots "
"that are defined in both the previous and the new classes. Before this "
"method is called, the slot c will be deleted from the instance and the slot "
"angle-C will be added. This method will use the value of the discarded slot "
"c to calculate the value of the new slot angle-C, and will store the value "
"in the slot."
msgstr ""
"Значения слотов a и b сохраняются, поскольку это локальные слоты, которые"
" определены как в предыдущем, так и в новом классах. Перед вызовом этого"
" метода слот c будет удален из экземпляра и будет добавлен слот angle-C. Этот"
" метод будет использовать значение отброшенного слота c для вычисления"
" значения нового угла angle-C и сохранит значение в слоте."

#: ./en/ch08.md:248
msgid ""
"Keep in mind that a class can be redefined more than once. We might later "
"decide that yet another representation of triangles is preferable. Since "
"instances are not necessarily updated immediately upon redefinition, some "
"existing instances might be several formats behind the current format. This "
"method attempts to be safe in the face of multiple class redefinitions. "
"Before doing anything else, this method checks that the instance is being "
"updated in the expected way; that is, that slot c is being discarded and "
"slot angle-C is being added. If both of these conditions are met, the method "
"computes the appropriate value for the slot angle-C and stores it in the "
"slot. "
msgstr ""
"Имейте в виду, что класс может быть переопределен более одного раза. Позже мы"
" могли бы решить, что предпочтительнее еще одно представление треугольников."
" Поскольку экземпляры не обязательно обновляются сразу после переопределения,"
" некоторые существующие экземпляры могут отличаться от текущего формата на"
" несколько форматов. Этот метод пытается быть безопасным перед лицом"
" множественных переопределений классов. Прежде чем делать что-либо еще, этот"
" метод проверяет, что экземпляр обновляется ожидаемым образом; то есть, что"
" слот c отбрасывается и добавляется слот angle-C. Если оба эти условия"
" выполнены, метод вычисляет соответствующее значение для слота  angle-C и"
" сохраняет его в слоте."

#: ./en/ch08.md:267
msgid ""
"<pre>\n"
";;; Here we delete slot c and add angle-C \n"
";;; We need to initialize the new slot angle-C \n"
"(defmethod update-instance-for-redefined-class :after \n"
"    ((instance triangle) \n"
"     added-slots discarded-slots \n"
"     plist &rest initargs) \n"
"   (declare (ignore initargs)) \n"
"   ;; Identify this particular redefinition \n"
"   (if (and (member 'c discarded-slots) \n"
"            (member 'angle-C added-slots)) \n"
"       (setf (slot-value instance 'angle-C) \n"
"             (three-sides-to-angle \n"
"              (getf plist 'c) \n"
"              (side-a instance) \n"
"              (side-b instance))))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:269
msgid ""
"It is crucial to evaluate the method for update-instance-for-redefined-class "
"before evaluating the new class definition. Otherwise, in the interval after "
"redefining the class and before evaluating the method for update-instance-"
"for-redefined-class, it is possible for instances to be updated to the new "
"definition. An instance is updated sometime before any of its slots are "
"accessed. If an instance is updated before the method is defined, only the "
"slots a and b will have values. There will be no way of calculating the "
"angle-C slot, because the value of the deleted slot c will have been "
"discarded."
msgstr ""
"Крайне важно оценить метод для update-instance-for-redefined-class, прежде"
" чем оценивать новое определение класса. В противном случае, в промежутке"
" после переопределения класса и перед оценкой метода для обновления"
" экземпляра для переопределенного класса, экземпляры могут быть обновлены до"
" нового определения. Экземпляр обновляется за некоторое время до того, как"
" будет получен доступ к любому из его слотов. Если экземпляр обновляется до"
" определения метода, только слоты a и b будут иметь значения. Не будет"
" никакого способа вычислить слот angle-C, потому что значение удаленного"
" слота c будет отброшено."

#: ./en/ch08.md:271
msgid ""
"The methods for side-a and side-b are unchanged; they continue to work as "
"before. However, the method for side-c (which was a reader method generated "
"by the previous class definition) will be removed from Lisp when the new "
"class definition is evaluated. Therefore, we need to write a new method for "
"side-c. The method calculates the third side of a triangle, based on two "
"sides and the angle between them."
msgstr ""
"Методы для side-a и side-b не изменились; они продолжают работать"
" по-прежнему. Однако метод для side-c (который был методом чтения,"
" сгенерированным предыдущим определением класса) будет удален из Lisp при"
" вычислении/оценке нового определения класса. Следовательно, нам нужно"
" написать новый метод для side-c. Метод вычисляет третью сторону"
" треугольника, основываясь на двух сторонах и угле между ними."

#: ./en/ch08.md:277
msgid ""
"<pre>\n"
"(defmethod side-c ((tri triangle)) \n"
"   (third-side (side-a tri) \n"
"               (side-b tri) \n"
"               (angle-C tri)))"
msgstr ""

#: ./en/ch08.md:284
msgid ""
";;; Algorithm is: c^2 = a^2 + b^2 - 2ab(cos C) \n"
"(defun third-side (a b angle-C) \n"
"   (sqrt (- (+ (expt a 2) \n"
"               (expt b 2)) \n"
"            (* 2 a b (cos angle-C))))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:286
msgid ""
"We also need to revise our constructor function, because it calls make-"
"instance with the initarg :side-c, which is no longer a valid initarg. It is "
"an easy matter to write a new constructor that takes the same arguments, but "
"fills different slots using that information. This constructor uses the c "
"argument to calculate the appropriate value for the angle-C slot."
msgstr ""
"Нам также необходимо пересмотреть нашу функцию конструктора, потому что она"
" вызывает make-instance с помощью initarg :side-c, который больше не является"
" допустимым initarg. Легко написать новый конструктор, который принимает те"
" же аргументы, но заполняет разные слоты, используя эту информацию. Этот"
" конструктор использует аргумент c для вычисления соответствующего значения"
" для слота angle-C."

#: ./en/ch08.md:298
msgid ""
"<pre>\n"
"(defun make-triangle (a b c) \n"
"   (let* ((float-a (coerce a 'float)) \n"
"          (float-b (coerce b 'float)) \n"
"          (float-c (coerce c 'float)) \n"
"          (angle-C (three-sides-to-angle \n"
"                    float-c float-a float-b))) \n"
"      (make-instance 'triangle :side-a float-a \n"
"                               :side-b float-b \n"
"                               :angle-C angle-C))) \n"
"</pre>"
msgstr ""

#: ./en/ch08.md:300
msgid ""
"Often a constructor needs to be redefined when the class itself is "
"redefined. Constructors are closely tied to the structure of the class, "
"because they usually take arguments and use them to fill slots."
msgstr ""
"Часто конструктор нуждается в переопределении, когда переопределяется сам"
" класс. Конструкторы тесно связаны со структурой класса, потому что они"
" обычно принимают аргументы и используют их для заполнения слотов."

#: ./en/ch08.md:302
msgid "### What Changed, and What Stayed the Same "
msgstr "### Что изменилось, а Что Осталось прежним"

#: ./en/ch08.md:304
msgid ""
"It is essential that, no matter what changes occur in the internals of the "
"program, the documented external protocol remains the same. This allows any "
"client code to continue to work. Here we also endeavored to keep the "
"documented internal protocol the same, which minimized the amount of "
"internal code that needed to be changed."
msgstr ""
"Важно, чтобы, независимо от того, какие изменения происходят во внутренних"
" компонентах программы, документированный внешний протокол оставался"
" неизменным. Это позволяет любому клиентскому коду продолжать работать. Здесь"
" мы также постарались сохранить задокументированный внутренний протокол"
" неизменным, что минимизировало объем внутреннего кода, который необходимо"
" было изменить."

#: ./en/ch08.md:313
msgid ""
"|   What Changed                   | What Stayed the Same           |\n"
"|----------------------------------|--------------------------------|\n"
"| Definition of the triangle class | User's perception of triangles |\n"
"| Implementation of side-c,        | Documented external protocol   |\n"
"| agle-C, and make-triangle        | Documented internal protocol   |\n"
"|                                  | Implementation of side-a,      |\n"
"|                                  | side-b, angle-A, angle-B, area,|\n"
"|                                  | dimensions, and angles         |"
msgstr ""
"| Что Изменилось                      |   Что Осталось прежним               "
"  |\n"
"|-------------------------------------|---------------------------------------"
"-|\n"
"| Определение класса треугольников    | Восприятие треугольников"
" пользователем |\n"
"| Реализация side-c,                  | Документированный внешний протокол   "
"  |\n"
"| agle-C и make-triangle              | Документированный внутренний протокол"
"  |\n"
"|                                     | Реализация side-a,                   "
"  |\n"
"|                                     | side-b, angle-A, angle-B, area,      "
"  |\n"
"|                                     | dimensions и angles                  "
"  |"

#: ./en/ch08.md:315
msgid ""
"Since the constructor takes the three sides as arguments, we are encouraging "
"the users to think of triangles as being represented by the three sides. The "
"new internal representation of triangles does not match this perception, but "
"since the external protocol remains the same, we are not requiring users to "
"change their mental model of triangles. Similarly, our documentation of the "
"external protocol intentionally did not state that side-c was previously "
"implemented as a reader. The documentation of the external protocol should "
"never expose the internals, such as mentioning that a generic function is "
"implemented as an accessor."
msgstr ""
"Поскольку конструктор принимает три стороны в качестве аргументов, мы"
" призываем пользователей думать о треугольниках как о представленных тремя"
" сторонами. Новое внутреннее представление треугольников не соответствует"
" этому восприятию, но поскольку внешний протокол остается прежним, мы не"
" требуем от пользователей менять свою ментальную модель треугольников."
" Аналогичным образом, в нашей документации по внешнему протоколу намеренно не"
" указано, что side-c ранее был реализован как средство чтения. Документация"
" внешнего протокола никогда не должна раскрывать внутренние компоненты,"
" например, упоминать, что обобщенная функция реализована как средство доступа."

#: ./en/ch08.md:317
msgid ""
"We were \"lucky\" that a great deal of the implementation of the program "
"continued to work when the representation of triangles changed. Actually, "
"this is not luck at all, but rather is a direct result of documenting and "
"adhering to an internal protocol."
msgstr ""
"Нам \"повезло\", что большая часть реализации программы продолжала работать,"
" когда изменилось представление треугольников. На самом деле, это вовсе не"
" удача, а скорее прямой результат документирования и соблюдения внутреннего"
" протокола."

#: ./en/ch08.md:319
msgid ""
"First, consider the operations area, dimensions, and angles. These external "
"operations are all implemented in terms of the internal protocol, which we "
"continued to support after redefining the class. The internal protocol "
"guarantees that those three operations remain valid."
msgstr ""
"Во-первых, рассмотрите опарации area, dimensions и angles. Все эти внешние"
" операции реализованы в терминах внутреннего протокола, который мы продолжали"
" поддерживать после переопределения класса. Внутренний протокол гарантирует,"
" что эти три операции остаются действительными."

#: ./en/ch08.md:321
msgid ""
"Next, consider the internal operations themselves. Each one fulfills a "
"specific task, returning one angle or side. This modularity of design "
"implies that a method needs to be rewritten only if it depends on some "
"aspect of the class definition that has been changed. For example, since the "
"slots a and b remain the same, the methods for side-a and side-b continue to "
"be valid."
msgstr ""
"Далее рассмотрим сами внутренние операции. Каждый из них выполняет"
" определенную задачу, возвращая один угол или сторону. Эта модульность"
" проектирования подразумевает, что метод необходимо переписывать только в том"
" случае, если он зависит от какого-либо аспекта определения класса, который"
" был изменен. Например, поскольку слоты a и b остаются неизменными, методы"
" для side-a и side-b остаются действительными."

#: ./en/ch08.md:323
msgid ""
"Another reason that most methods for the internal operations remain valid is "
"that those methods depend on the internal protocol, and not on the internal "
"structure of the class. Except for the accessors (which necessarily depend "
"on the slots), none of the methods use knowledge of the internal details of "
"the class. For example, to get the length of side-c, the methods called the "
"generic function side-c. An equivalent alternative to calling side-c is to "
"use with-accessors. In contrast, any code that uses with-slots has a built-"
"in dependency on the internal representation of the class; that code would "
"need to be rewritten if the class were redefined to delete the slot."
msgstr ""
"Другая причина, по которой большинство методов для внутренних операций"
" остаются действительными, заключается в том, что эти методы зависят от"
" внутреннего протокола, а не от внутренней структуры класса. За исключением"
" средств доступа (которые обязательно зависят от слотов), ни один из методов"
" не использует знание внутренних деталей класса. Например, чтобы получить"
" длину side-c, методы вызывали обобщенную функцию side-c. Эквивалентной"
" альтернативой вызову side-c является использование with-accessors. Напротив,"
" любой код, использующий with-slots, имеет встроенную зависимость от"
" внутреннего представления класса; этот код нужно было бы переписать, если бы"
" класс был переопределен для удаления слота."

#: ./en/ch08.md:325
msgid "## 8.4 CHANGING THE CLASS OF AN INSTANCE "
msgstr "## 8.4 ИЗМЕНЕНИЕ КЛАССА ЭКЗЕМПЛЯРА"

#: ./en/ch08.md:327
msgid ""
"You can change the class of an existing instance by calling change-class. We "
"use the term \"previous class\" to mean the class of the instance before it "
"is changed, and \"target class\" to mean the class of the instance after it "
"is changed. CLOS updates the instance to the structure of the target class, "
"which might involve deleting or adding slots. "
msgstr ""
"Вы можете изменить класс существующего экземпляра, вызвав change-class. Мы"
" используем термин \"предыдущий класс/\"previous class\" для обозначения"
" класса экземпляра до его изменения, а \"целевой класс/target class\" для"
" обозначения класса экземпляра после его изменения. CLOS обновляет экземпляр"
" до структуры целевого класса, что может включать удаление или добавление"
" слотов."

#: ./en/ch08.md:330
msgid "### What Happens to the Slots of the Instance"
msgstr "### Что происходит со слотами экземпляра"

#: ./en/ch08.md:332
msgid ""
"When an instance is changed to a different class, there is no effect on the "
"values of any shared slots. The instance, however, will lose access to any "
"shared slots of the previous class. If the target class defines another slot "
"of the same name (whether shared or local), the instance will access that "
"slot instead. (If the previous and target classes access the same shared "
"slot because one of the classes inherits it from the other, the instance "
"will continue to access that slot.)"
msgstr ""
"Когда экземпляр изменяется на другой класс, это никак не влияет на значения"
" каких-либо общих(shared) слотов. Экземпляр, однако, потеряет доступ к любым"
" общим слотам предыдущего класса. Если целевой класс определяет другой слот с"
" тем же именем (будь то общий или локальный), экземпляр получит доступ к"
" этому слоту вместо старого. (Если предыдущий и целевой классы получают"
" доступ к одному и тому же общему слоту, потому что один из классов наследует"
" его от другого, экземпляр продолжит получать доступ к этому слоту.)"

#: ./en/ch08.md:334
msgid ""
"Table 8.2 indicates what happens to the values of slots. \"Preserved,\" "
"\"initialized,\" and \"discarded\" have the meanings described in "
"\"Redefining Classes,\" page 140. We introduce two more terms:"
msgstr ""
"В таблице 8.2 показано, что происходит со значениями слотов."
" \"Сохраненный/\"Preserved\", \"инициализированный/initialized\" и"
" \"отброшенный/discarded\" имеют значения, описанные в разделе"
" \"Переопределение классов\", стр. 140. Мы вводим еще два термина:"

#: ./en/ch08.md:338
msgid ""
"\t     > inaccessible      The shared slot of the previous class is not "
"accessi- \n"
"\t     >                   ble to the instance after its class has been "
"changed \n"
"\t     >                   to the target class. "
msgstr ""
"\t     > inaccessible(недоступно)     Общий слот предыдущего класса"
" недоступен для экземпляра\n"
"\t     >                                           после того, как его класс"
" был изменен на целевой класс."

#: ./en/ch08.md:346
msgid ""
"\t     > replaced          For any shared slot of the target class, the "
"instance \n"
"\t     >                   is updated to access that shared slot. If the "
"previ- \n"
"\t     >                   ous class defined a slot of the same name, "
"whether \n"
"\t     >                   local or shared, the updated instance no longer "
"ac- \n"
"\t     >                   cesses that slot. Thus, we say the value of the "
"slot \n"
"\t     >                   is \"replaced\" by the value of a shared slot of "
"the \n"
"\t     >                   target class."
msgstr ""
"\t     > replaced(заменено)    Для любого общего слота целевого класса"
" экземпляр обновляется для доступа \n"
"\t     >                                 к этому общему слоту. Если"
" предыдущий класс определил слот с тем же именем,\n"
"\t     >                                 будь то локальный или общий,"
" обновленный экземпляр больше не обращается к\n"
"\t     >                                 этому слоту. Таким образом, мы"
" говорим, что значение слота \"заменяется\"\n"
"\t     >                                значением общего слота целевого"
" класса."

#: ./en/ch08.md:352
msgid ""
"|                  | Shared (Target) |  Local (Target)  |  None (Target) |\n"
"|------------------|-----------------|------------------|----------------|\n"
"| shared (previous)| replaced        | preserved        | inaccessible   |\n"
"| local (previous) | replaced        | preserved        | discarded      |\n"
"| none (previous)  | replaced        | initialized      | no action      |"
msgstr ""
"|                     | Общий (Целевой) | Локальный (Целевой) | Нет (Целевой)"
"   |\n"
"|---------------------|-----------------|---------------------|---------------"
"--|\n"
"| общий (предыдущий)  | замененный      | сохраненный         | недоступный  "
"   |\n"
"|локальный(предыдущий)| замененный      | сохраненный         | отброшенный  "
"   |\n"
"| нет (предыдущий)    | замененный      | инициализирован     | никаких"
" действий|"

#: ./en/ch08.md:354
msgid "Table 8.2 Effects on slots when the class of an instance is changed. "
msgstr "Таблица 8.2 Влияние на слоты при изменении класса экземпляра."

#: ./en/ch08.md:356
msgctxt "./en/ch08.md:356"
msgid "### Customizing the Updating "
msgstr "### Настройка обновления"

#: ./en/ch08.md:358
msgid ""
"CLOS enables you to specify other actions to be taken when an instance is "
"updated to conform to the definition of a different class. You can provide "
"methods for update-instance-for-different-class to do further work in "
"updating the instance."
msgstr ""
"CLOS позволяет указать другие действия, которые необходимо предпринять, когда"
" экземпляр обновляется в соответствии с определением другого класса. Вы"
" можете предоставить методы для update-instance-for-different-class для"
" выполнения дальнейшей работы по обновлению экземпляра."

#: ./en/ch08.md:360
msgid ""
"When you call change-class, CLOS updates the structure of the instance and "
"then calls the generic function update-instance-for-different-class. The "
"default primary method initializes any new local slots, according to the :"
"initform of the target class. "
msgstr ""
"Когда вы вызываете change-class, CLOS обновляет структуру экземпляра, а затем"
" вызывает обобщенную функцию update-instance-for-different-class. Основной"
" метод по умолчанию инициализирует любые новые локальные слоты в соответствии"
" с формой :init целевого класса."

#: ./en/ch08.md:362
msgid ""
"Note that, if you define a primary method for update-instance-for-different-"
"class, it will override the default method, which initializes new local "
"slots. In most cases, it is preferable to let that behavior occur and to "
"specialize update-instance-for-different-class by writing before- or after-"
"methods. If you initialize a slot in a before-method, the default primary "
"method does not fill the slot with its initform."
msgstr ""
"Обратите внимание, что, если вы определите основной метод для"
" update-instance-for-different-class, он переопределит метод по умолчанию,"
" который инициализирует новые локальные слоты. В большинстве случаев"
" предпочтительнее допустить такое поведение и специализировать"
" update-instance-for-different-class путем написания методов before или"
" after. Если вы инициализируете слот в методе before, основной метод по"
" умолчанию не заполняет слот своей initform."

#: ./en/ch08.md:363
msgid ""
"When CLOS calls update-instance-for-different-class, the first argument, "
"previous, is a copy of the instance before it was updated. The second "
"argument, target, is the updated instance. The target and previous arguments "
"are not eq. You can access the values of all slots in the previous instance "
"by using accessors or slot-value on the previous argument; you can also use "
"other functions or generic functions on the previous argument. "
msgstr ""
"Когда CLOS вызывает update-instance-for-different-class, первый аргумент,"
" предыдущий, является копией экземпляра до того, как он был обновлен. Второй"
" аргумент, target, - это обновленный экземпляр. Целевой и предыдущие"
" аргументы не являются  eq. Вы можете получить доступ к значениям всех слотов"
" в предыдущем экземпляре, используя средства доступа или значение слота в"
" предыдущем аргументе; вы также можете использовать другие функции или"
" обобщенные функции в предыдущем аргументе."
