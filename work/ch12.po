#. extracted from ./en/ch12.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 10:07+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch12.md:2
msgid "# Highlights of CLOS "
msgstr "# Основные моменты CLOS"

#: ./en/ch12.md:4
msgid ""
"In this chapter, we discuss the original design goals for CLOS, and how they "
"were achieved. We address three important design goals of CLOS and one "
"nongoal: "
msgstr ""
"В этой главе мы обсудим первоначальные цели проектирования CLOS и то, как они"
" были достигнуты. Мы решаем три важные цели проектирования CLOS и одну"
" нецелевую:"

#: ./en/ch12.md:10
msgid ""
"*  CLOS should be a standard language extension that includes the most "
"useful aspects of the existing object-oriented paradigms \n"
"*  The CLOS programmer interface should be powerful and flexible enough for "
"developing most application programs \n"
"*   CLOS itself should be designed as an extensible protocol, to allow for "
"customization of its behavior and to encourage further research in object-"
"oriented programming \n"
"*   CLOS should not provide automatic support for specifying and enforcing "
"protocols \n"
"The third goal leads to an advanced topic of CLOS—the metaobject protocol. "
"We introduce the motivation for the metaobject protocol and discuss it "
"briefly. "
msgstr ""
"* CLOS должен быть стандартным расширением языка, включающим наиболее"
" полезные аспекты существующих объектно-ориентированных парадигм.\n"
"* Интерфейс CLOS программиста должен быть достаточно мощным и гибким для"
" разработки большинства прикладных программ\n"
"* Сам CLOS должен быть разработан как расширяемый протокол, позволяющий"
" настраивать его поведение и стимулировать дальнейшие исследования в области"
" объектно-ориентированного программирования.\n"
"* CLOS не должны обеспечивать автоматическую поддержку для определения и"
" применения протоколов "

#: ./en/ch12.md:13
msgid "## 12.1 DESIGNING A STANDARD OBJECT-ORIENTED PARADIGM"
msgstr "12.1 РАЗРАБОТКА СТАНДАРТНОЙ ОБЪЕКТНО-ОРИЕНТИРОВАННОЙ ПАРАДИГМЫ"

#: ./en/ch12.md:15
msgid ""
"When CLOS was designed (starting in 1986), a number of object-oriented "
"paradigms had been available in various Lisp implementations for several "
"years. The goal of designing CLOS was to define a standard language "
"extension to Common Lisp. The immediate benefit of this standard would be to "
"enable Lisp programmers to write portable code in an object-oriented style."
msgstr ""
"Когда CLOS был разработан (начиная с 1986 года), ряд объектно-ориентированных"
" парадигм был доступен в различных реализациях Lisp в течение нескольких лет."
" Целью разработки CLOS было определение стандартного языкового расширения для"
" Common Lisp. Непосредственным преимуществом этого стандарта было бы"
" предоставление программистам Lisp возможности писать переносимый код в"
" объектно-ориентированном стиле."

#: ./en/ch12.md:17
msgid ""
"Many of the existing object-oriented paradigms had important similarities. "
"The CLOS Working Group wanted to gather the most useful aspects of these "
"paradigms into a single, unified language extension. From the beginning, the "
"Working Group agreed that a primary goal in defining a language standard was "
"to be conservative — to include in the CLOS standard only those features and "
"techniques that were well understood. The Working Group tried to define a "
"consistent model based on the strengths of existing paradigms, while "
"excluding unnecessary features."
msgstr ""
"Многие из существующих объектно-ориентированных парадигм имели важные"
" сходства. Рабочая группа CLOS хотела собрать наиболее полезные аспекты этих"
" парадигм в единое, унифицированное языковое расширение. С самого начала"
" Рабочая группа согласилась с тем, что основной целью при определении"
" языкового стандарта было быть консервативным — включить в стандарт CLOS"
" только те функции и методы, которые были хорошо поняты. Рабочая группа"
" попыталась определить согласованную модель, основанную на сильных сторонах"
" существующих парадигм, исключив при этом ненужные функции."

#: ./en/ch12.md:19
msgid "## 12.2 SUMMARY OF THE PROGRAMMER INTERFACE"
msgstr "12.2 КРАТКОЕ ОПИСАНИЕ ИНТЕРФЕЙСА ПРОГРАММИСТА"

#: ./en/ch12.md:21
msgid ""
"Here we summarize the major techniques supported by the CLOS programmer "
"interface:"
msgstr ""
"Здесь мы обобщаем основные методы, поддерживаемые интерфейсом CLOS programmer:"

#: ./en/ch12.md:23
msgid ""
"*  Defining organizations of classes. You can conveniently define "
"organizations of classes. A class inherits structure and behavior from its "
"direct superclasses, which are listed in the defclass form. CLOS "
"automatically computes a class precedence list based on the constraints "
"specified locally in the defclass forms."
msgstr ""
"* Определение организации классов. Вы можете удобно определять организацию"
" классов. Класс наследует структуру и поведение от своих прямых суперклассов,"
" которые перечислены в форме defclass. CLOS автоматически вычисляет список"
" приоритетов классов на основе ограничений, указанных локально в формах"
" defclass."

#: ./en/ch12.md:25
msgid ""
"*  Creating and initializing instances. You can create instances with make-"
"instance. CLOS provides you with a good measure of control over how the "
"instances are initialized. You can specify that a slot should be filled by "
"an initarg and provide default initial values for slots and initargs. You "
"can perform further initialization by specializing initialize-instance."
msgstr ""
"* Создание и инициализация экземпляров. Вы можете создавать экземпляры с"
" помощью make-instance. CLOS предоставляет вам хороший контроль над тем, как"
" инициализируются экземпляры. Вы можете указать, что слот должен быть"
" заполнен инициализацией, и указать начальные значения по умолчанию для"
" слотов и инициализаций. Вы можете выполнить дальнейшую инициализацию,"
" специализировавшись на initialize-instance."

#: ./en/ch12.md:31
msgid ""
"\t*  Defining different kinds of methods. You can define methods for many "
"different purposes, including: \n"
"\t*  Specializing the behavior of a reader or writer \n"
"\t*  Specializing on a Common Lisp type \n"
"\t*  Specializing on more than one argument (multi-methods) \n"
"\t*  Specializing on an individual Lisp object "
msgstr ""
"\t* Определение различных видов методов. Вы можете определять методы для"
" самых разных целей, включая:\n"
"\t* Специализация поведения читателя или писателя\n"
"\t* Специализирующийся на типе Common Lisp\n"
"\t* Специализация на более чем одном аргументе (мультиметоды)\n"
"\t* Специализируясь на отдельном объекте Lisp"

#: ./en/ch12.md:33
msgid ""
"*  Defining methods that work together. The default behavior of the generic "
"dispatch (the standard method combination type) allows for methods of "
"different roles, including primary methods, before-methods, after-methods, "
"and around-methods. This is an extremely flexible framework thak-together "
"with the class inheritance mechanism—enables you to define code in modules. "
"Each module comes into play when it is appropriate, according to the "
"arguments to the generic function and the method's role."
msgstr ""
"*     Определение методов, которые работают вместе. Поведение универсальной"
" отправки(generic dispatch) по умолчанию (тип комбинации стандартных методов)"
" допускает использование методов с различными ролями, включая первичные"
" методы, методы до(before-), методы после(after-) и окружающие(around-)"
" методы. Это чрезвычайно гибкая платформа, которая — вместе с механизмом"
" наследования классов - позволяет вам определять код в модулях. Каждый модуль"
" вступает в игру, когда это уместно, в соответствии с аргументами обобщенной"
" функции и ролью метода."

#: ./en/ch12.md:35
msgid ""
"*  Using a different framework for generic dispatch. You can easily use one "
"of the built-in method combination types or define a new one based on a Lisp "
"function, macro, or special form. The freedom to use other method "
"combination types allows you to control how the methods are called and what "
"is done with their values."
msgstr ""
"*  Использование отличающейся рабочей среды для общей отправки(generic"
" dispatch). Вы можете легко использовать один из встроенных типов комбинации"
" методов или определить новый на основе функции Lisp, макроса или специальной"
" формы. Свобода использования других типов комбинаций методов позволяет вам"
" контролировать, как вызываются методы и что делается с их значениями."

#: ./en/ch12.md:37
msgid ""
"*  Redefining elements dynamically. You can redefine generic functions, "
"methods, and classes on the fly. You can redefine a class even after "
"instances of the class exist. CLOS ensures that everything that is affected "
"by the redefinition is automatically updated, including instances, "
"subclasses, and instances of subclasses. When instances are updated, the "
"default method adds or deletes slots according to the new definition, and "
"preserves the values of slots that have not changed. You can perform further "
"action during the redefinition by specializing update-instance-structure."
msgstr ""
"* Динамическое переопределение элементов. Вы можете переопределять обобщенные"
" функции, методы и классы \"на лету\". Вы можете переопределить класс даже"
" после того, как экземпляры класса существуют. CLOS гарантирует, что все, на"
" что влияет переопределение, автоматически обновляется, включая экземпляры,"
" подклассы и экземпляры подклассов. Когда экземпляры обновляются, метод по"
" умолчанию добавляет или удаляет слоты в соответствии с новым определением и"
" сохраняет значения слотов, которые не изменились. Вы можете выполнить"
" дальнейшие действия во время переопределения, специализировав"
" update-instance-structure."

#: ./en/ch12.md:39
msgid ""
"These features add up to a great deal of expressive power. However, the goal "
"of \"satisfying most applications\" has a tradeoff. To satisfy most "
"applications, the programmer interface is very flexible. The disadvantage of "
"this flexibility is that CLOS users might be overwhelmed by the wide "
"assortment of techniques and features to be learned. Also, CLOS often "
"supports more than one way of doing a single thing, and there is not always "
"a clear guideline as to which way is preferable."
msgstr ""
"Эти особенности(функциональности) в совокупности придают ему большую"
" выразительную силу. Однако цель \"удовлетворения большинства приложений\""
" имеет компромисс. Чтобы удовлетворить большинство приложений, интерфейс"
" программиста очень гибкий. Недостатком такой гибкости является то, что"
" пользователи CLOS могут быть ошеломлены широким спектром методов и функций,"
" которые необходимо изучить. Кроме того, CLOS часто поддерживает более одного"
" способа выполнения одной и той же задачи, и не всегда существует четкое"
" указание на то, какой способ предпочтительнее."

#: ./en/ch12.md:41
msgid ""
"Certainly, it is not necessary to understand all these techniques to write a "
"good-sized application program. Any single program will require only a "
"subset of these techniques. We encourage new users to concentrate on "
"learning the central themes of how CLOS works, especially the generic "
"dispatch. If you understand what happens when a generic function is called, "
"you are well on your way. The next step is to start writing CLOS programs. "
"In the course of development, you might find problems that cannot be "
"conveniently solved with the most basic CLOS features (such as primary "
"methods, before-methods, and after-methods), and you can then investigate "
"the more advanced features (such as around-methods, or other types of method "
"combination). "
msgstr ""
"Конечно, нет необходимости разбираться во всех этих методах, чтобы написать"
" прикладную программу хорошего размера. Любая отдельная программа потребует"
" только подмножества этих методов. Мы рекомендуем новым пользователям"
" сосредоточиться на изучении основных тем работы CLOS, особенно общей"
" отправки. Если вы понимаете, что происходит при вызове обобщенной функции,"
" вы на верном пути. Следующий шаг - начать писать программы CLOS. В процессе"
" разработки вы можете обнаружить проблемы, которые не могут быть удобно"
" решены с помощью самых базовых функций CLOS (таких как первичные методы,"
" методы до(before-) и после(after-)), и затем вы можете исследовать более"
" продвинутые функции (такие как around-методы или другие типы комбинации"
" методов)."

#: ./en/ch12.md:43
msgid "## 12.3 EXPLORING ALTERNATIVE PARADIGMS"
msgstr "12.3 ИЗУЧЕНИЕ АЛЬТЕРНАТИВНЫХ ПАРАДИГМ"

#: ./en/ch12.md:45
msgid ""
"With all the expressive power mentioned so far, what more is needed? The "
"CLOS programmer interface supports one model of object-oriented programming, "
"but there are alternative paradigms."
msgstr ""
"При всей упомянутой до сих пор выразительной силе, что еще нужно? Интерфейс"
" CLOS программиста поддерживает одну модель объектно-ориентированного"
" программирования, но существуют альтернативные парадигмы."

#: ./en/ch12.md:47
msgid ""
"For example, in CLOS, a class inherits nearly every aspect of its su- "
"perclasses: slots, some slot and class options, and methods. We can call "
"this \"open sharing\"; a class inherits nearly everything by default, but "
"can choose to override some of the inherited behavior or characteristics, if "
"desired. An alternative paradigm might support \"closed sharing,\" where a "
"class inherits nothing from its superclasses by default, but can explicitly "
"specify which aspects of its superclasses it wants to inherit."
msgstr ""
"Например, в CLOS класс наследует почти все аспекты своих суперклассов: слоты,"
" некоторые параметры слотов и классов, а также методы. Мы можем назвать это"
" \"открытым общим доступом\"; класс наследует почти все по умолчанию, но при"
" желании может переопределить некоторые унаследованные поведения или"
" характеристики. Альтернативная парадигма может поддерживать \"закрытый общий"
" доступ\", когда класс по умолчанию ничего не наследует от своих"
" суперклассов, но может явно указать, какие аспекты своих суперклассов он"
" хочет унаследовать."

#: ./en/ch12.md:49
msgid ""
"Two other key aspects of any object-oriented paradigm are how the "
"organization of classes is specified, and how the precedence among those "
"classes is controlled. In CLOS, the programmer specifies an organization of "
"classes in the defclass forms; each class has a list of superclasses. The "
"order of these superclasses sets up local constraints on the precedence of "
"the classes. CLOS uses an algorithm to compute a class precedence list for "
"each class, which is always consistent with the set of local constraints. "
"This is just one of many possible ways to control inheritance."
msgstr ""
"Два других ключевых аспекта любой объектно-ориентированной парадигмы - это"
" то, как определяется организация классов и как контролируется приоритет"
" среди этих классов. В CLOS программист определяет организацию классов в"
" формах defclass; у каждого класса есть список суперклассов. Порядок этих"
" суперклассов устанавливает локальные ограничения на приоритет классов. CLOS"
" использует алгоритм для вычисления списка приоритетов(предшествования)"
" классов для каждого класса, который всегда согласуется с набором локальных"
" ограничений. Это всего лишь один из многих возможных способов управления"
" наследованием."

#: ./en/ch12.md:51
msgid ""
"When CLOS was being defined, most developers who had experience with one or "
"more of the existing paradigms agreed that object-oriented programming was "
"essential for designing and implementing large systems. However, even the "
"phrase \"object-oriented programming\" had different meanings for different "
"people. Each individual paradigm invented not just its own syntax, but also "
"its own semantics."
msgstr ""
"Когда определялся CLOS, большинство разработчиков, имевших опыт работы с"
" одной или несколькими существующими парадигмами, согласились с тем, что"
" объектно-ориентированное программирование имеет важное значение для"
" проектирования и внедрения больших систем. Однако даже словосочетание"
" \"объектно-ориентированное программирование\" имело разное значение для"
" разных людей. Каждая отдельная парадигма изобрела не только свой собственный"
" синтаксис, но и свою собственную семантику."

#: ./en/ch12.md:53
msgid ""
"The Working Group had to make certain decisions and choices, in order to "
"define CLOS as a consistent model. The Working Group also believed that it "
"was important to encourage ongoing experimentation with alternative "
"paradigms. The solution was to define and document CLOS itself as an "
"extensible protocol, which is called the Metaobject Protocol. We discuss "
"this in \"The CLOS Metaobject Protocol,\" page 219."
msgstr ""
"Рабочая группа должна была принять определенные решения и сделать выбор,"
" чтобы определить CLOS как последовательную/непротиворечивую модель. Рабочая"
" группа также считала, что важно поощрять постоянное экспериментирование с"
" альтернативными парадигмами. Решение состояло в том, чтобы определить и"
" задокументировать сам CLOS как расширяемый протокол, который называется"
" Metaobject Protocol."
"Мы обсуждаем это в \"Протоколе метаобъектов CLOS\", стр. 219."

#: ./en/ch12.md:55
msgid "## 12.4 A NONGOAL: AUTOMATIC PROTOCOL SUPPORT"
msgstr "12.4 НЕЦЕЛЕВОЕ: АВТОМАТИЧЕСКАЯ ПОДДЕРЖКА ПРОТОКОЛА"

#: ./en/ch12.md:57
msgid ""
"Some object-oriented paradigms actively assist the programmer in specifying "
"protocols. The definition of a class can describe more of the semantics of "
"the class. For example, a class definition can state that the class is "
"intended to be a building block only, and that no instances of it should be "
"made. The requirements of a class can be stated explicitly in the class "
"definition. For example, a mixin class such as ordered-lock-mixin has some "
"implicit requirements: It is intended to be used as a building block along "
"with another lock class (such as simple-lock or null-lock), and that lock "
"class must provide the methods for the lock protocol. Some object-oriented "
"languages provide a means for stating those requirements explicitly, and for "
"enforcing them."
msgstr ""
"Некоторые объектно-ориентированные парадигмы активно помогают программисту в"
" определении протоколов. Определение класса может описывать больше семантики"
" класса. Например, в определении класса может быть указано, что класс"
" предназначен только для использования в качестве строительного блока и что"
" его экземпляры не должны создаваться. Требования к классу могут быть явно"
" указаны в определении класса. Например, класс mixin, такой как"
" ordered-lock-mixin, имеет некоторые неявные требования: он предназначен для"
" использования в качестве строительного блока вместе с другим классом"
" блокировки(lock) (таким как simple-lock или null-lock), и этот класс"
" блокировки должен предоставлять методы для протокола блокировки. Некоторые"
" объектно-ориентированные языки предоставляют средства для явного изложения"
" этих требований и для их применения."

#: ./en/ch12.md:59
msgid ""
"CLOS does not provide automatic support for protocols. This is an area that "
"the Working Group deemed experimental and not yet ready for standardization."
msgstr ""
"CLOS не обеспечивает автоматическую поддержку протоколов. Это область,"
" которую Рабочая группа сочла экспериментальной и еще не готовой к"
" стандартизации."

#: ./en/ch12.md:61
msgid ""
"In this book, we have focused on the theme of protocols as a valuable means "
"of designing programs. Although CLOS does not actively support protocols, it "
"is nevertheless a language conducive for defining them. The aspect of CLOS "
"that makes protocol definition convenient is the fact that generic functions "
"are not called by a special syntax. To the caller, there is no discernible "
"difference between ordinary and generic functions. In other object-oriented "
"paradigms, the caller must know whether a function is ordinary or generic in "
"order to choose the appropriate calling syntax. The difference in calling "
"syntax obscures the essential distinction between interface and "
"implementation."
msgstr ""
"В этой книге мы сосредоточились на теме протоколов как ценного средства"
" разработки программ. Хотя CLOS активно не поддерживает протоколы, тем не"
" менее это язык, способствующий их определению. Аспект CLOS, который делает"
" определение протокола удобным, заключается в том, что обобщенные функции не"
" вызываются с помощью специального синтаксиса. Для вызывающего абонента нет"
" заметной разницы между обычными и обобщенными функциями. В других"
" объектно-ориентированных парадигмах вызывающий должен знать, является ли"
" функция обычной или обобщенной, чтобы выбрать соответствующий синтаксис"
" вызова. Разница в синтаксисе вызова скрывает существенное различие между"
" интерфейсом и реализацией."

#: ./en/ch12.md:64
msgid ""
"Currently, the vehicle for defining protocols is documentation. We recommend "
"documenting the external protocol and advertising it to the clients. For a "
"large application, it is also useful to document the internal \n"
"protocol and advertise it to the developers and maintainers of the program. "
"Sometimes, an internal protocol is implicitly defined as the set of "
"operators that are not advertised in the external protocol."
msgstr ""
"В этой книге мы сосредоточились на теме протоколов как ценного средства"
" разработки программ. Хотя CLOS активно не поддерживает протоколы, тем не"
" менее это язык, способствующий их определению. Аспект CLOS, который делает"
" определение протокола удобным, заключается в том, что обобщенные функции не"
" вызываются с помощью специального синтаксиса. Для вызывающего абонента нет"
" заметной разницы между обычными и обобщенными функциями. В других"
" объектно-ориентированных парадигмах вызывающий должен знать, является ли"
" функция обычной или обобщенной, чтобы выбрать соответствующий синтаксис"
" вызова. Разница в синтаксисе вызова скрывает существенное различие между"
" интерфейсом и реализацией."

#: ./en/ch12.md:66
msgid ""
"Although CLOS itself does not support protocols, the Working Group believes "
"that protocols are valuable and important. CLOS itself is documented as an "
"extensible protocol. The foundation of the CLOS programmer interface lies in "
"the metaobject protocol, which is documented to allow researchers and "
"developers to experiment with other object-oriented paradigms."
msgstr ""
"Хотя CLOS сам по себе не поддерживает протоколы, Рабочая группа считает, что"
" протоколы являются ценными и важными. Сам CLOS задокументирован как"
" расширяемый протокол. Основа интерфейса CLOS программиста лежит в протоколе"
" metaobject, который документирован, чтобы позволить исследователям и"
" разработчикам экспериментировать с другими объектно-ориентированными"
" парадигмами."

#: ./en/ch12.md:68
msgid "## 12.5 THE CLOS METAOBJECT PROTOCOL "
msgstr "12.5 ПРОТОКОЛ МЕТАОБЪЕКТА CLOS"

#: ./en/ch12.md:70
msgid ""
"This section gives a brief overview of the metaobject protocol—just enough "
"to give you an idea of how it is related to the CLOS programmer interface."
msgstr ""
"В этом разделе дается краткий обзор протокола metaobject — этого достаточно,"
" чтобы дать вам представление о том, как он связан с интерфейсом CLOS"
" программиста."

#: ./en/ch12.md:72
msgid "### The Classes of CLOS Elements"
msgstr "Классы элементов CLOS"

#: ./en/ch12.md:75
msgid ""
"An important aspect of CLOS is that every Lisp object is an instance of a "
"class. This means that a class object itself has a class, as do method "
"objects and generic function objects. CLOS uses the term metaclass to \n"
"denote a class that is the class of a class. Here are three predefined "
"metaclasses: "
msgstr ""
"Важным аспектом CLOS является то, что каждый объект Lisp является экземпляром"
" класса. Это означает, что сам объект класса имеет класс, как и объекты"
" метода и объекты обобщенной функции. CLOS использует термин метакласс для"
" обозначения класса, который является классом класса. Вот три"
" предопределенных метакласса:"

#: ./en/ch12.md:78
msgid ""
"       >   standard-class \n"
"       >          The default class of class objects defined by defclass. "
msgstr ""
"       >   standard-class \n"
"       >          Класс объектов класса по умолчанию, определенный defclass."

#: ./en/ch12.md:83
msgid ""
"       >   built-in-class \n"
"       >          The class of class objects that are implemented in a "
"special way (not by defclass). Most class\n"
"       >\t  objects corresponding to Common Lisp type specifiers are "
"implemented as instances of built-in-class,\n"
"       >\t  although others might be implemented as instances of standard-"
"class."
msgstr ""
"       >   built-in-class \n"
"       >          Класс объектов класса, которые реализованы особым образом"
" (не с помощью defclass).\n"
"       >          Большинство объектов класса, соответствующих спецификаторам"
" типов Common Lisp, \n"
"       >          реализованы как экземпляры встроенного класса, хотя другие"
" могут быть реализованы как\n"
"       >          экземпляры стандартного класса."

#: ./en/ch12.md:86
msgid ""
"       >   structure-class \n"
"       >          The class of class objects defined by defstruct, when the :"
"type option is not given."
msgstr ""
"       >   structure-class \n"
"       >              Класс объектов класса, определенный defstruct, когда"
" параметр :type не задан."

#: ./en/ch12.md:88
msgid ""
"We have used the informal term \"user-defined class\" when describing a "
"class whose metaclass is standard-class. Similarly, the term \"built-in "
"class\" denotes a class whose metaclass is built-in-class. The metaclass is "
"important to users, because it determines the behavior of the classes. For "
"example, standard-class supports make-instance, but built-in-class does not. "
"In other words, CLOS provides a method for make-instance attached to the "
"class standard-class, but there is no method for make-instance attached to "
"built-in-class."
msgstr ""
"Мы использовали неофициальный термин \"пользовательский класс/user-defined"
" class\" при описании класса, метакласс которого является"
" standard-class(стандартным классом). Аналогично, термин \"встроенный"
" класс/built-in class\" обозначает класс, метакласс которого является"
" встроенным классом. Метакласс важен для пользователей, поскольку он"
" определяет поведение классов.\n"
"Например, стандартный класс(standard-class) поддерживает make-instance, а"
" встроенный класс - нет. Другими словами, CLOS предоставляет метод для"
" make-instance, прикрепленного к классу standard-class, но нет метода для"
" make-instance, прикрепленного к встроенному классу."

#: ./en/ch12.md:90
msgid ""
"CLOS extends defstruct to enable you to write methods for defstruct "
"structures. If you use defstruct without giving the :type option, the "
"defstruct structure is implemented as a class whose metaclass is structure-"
"class. The advantage of this is that you can write methods for that class. "
"If you want to write methods, however, using defclass is probably better "
"than using defstruct. For one thing, using defclass frees you from the "
"limitation of single inheritance. Also, the flexibility of redefining "
"classes is supported by standard-class, but not by structure-class or built-"
"in-class."
msgstr ""
"CLOS расширяет defstruct, позволяя вам писать методы для структур defstruct."
" Если вы используете defstruct без указания параметра :type, структура"
" defstruct реализуется как класс, метаклассом которого является"
" structure-class. Преимущество этого заключается в том, что вы можете писать"
" методы для этого класса. Однако, если вы хотите писать методы, использование"
" defclass, вероятно, лучше, чем использование defstruct. Во-первых,"
" использование defclass освобождает вас от ограничения одиночного"
" наследования. Кроме того, гибкость переопределения классов поддерживается"
" стандартным классом(standard-class), но не структурным"
" классом(structure-class) или встроенным классом(built-in-class)."

#: ./en/ch12.md:92
msgid ""
"CLOS uses the term metaobject for objects that represent CLOS elements, such "
"as class objects, method objects, and generic function objects. Here are two "
"predefined classes of metaobjects:"
msgstr ""
"CLOS использует термин metaobject для объектов, представляющих элементы CLOS,"
" таких как объекты класса, объекты метода и объекты универсальной функции."
" Вот два предопределенных класса метаобъектов:"

#: ./en/ch12.md:95
msgid ""
"       >    standard-method \n"
"       >           The default class of method objects defined by defmethod"
msgstr ""
"       >    standard-method \n"
"       >           Класс объектов метода по умолчанию, определенный defmethod"

#: ./en/ch12.md:98
msgid ""
"       >    standard-generic-function \n"
"       >           The default class of generic function objects defined by "
"defgeneric"
msgstr ""
"       >    standard-generic-function \n"
"       >           Класс объектов обобщенной функции по умолчанию,"
" определенный defgeneric"

#: ./en/ch12.md:100
msgid ""
"The basic CLOS elements are themselves implemented as CLOS elements, so we "
"see that classes, generic functions, and methods follow the CLOS model. The "
"structure and behavior of a class (or generic function,or method) is defined "
"by its class. The predefined metaobject classes have methods that support "
"the default behavior of CLOS."
msgstr ""
"Базовые элементы CLOS сами по себе реализованы как элементы CLOS, поэтому мы"
" видим, что классы, обобщенные функции и методы следуют модели CLOS."
" Структура и поведение класса (или обобщенной функции, или метода)"
" определяются его классом. Предопределенные классы метаобъектов имеют методы,"
" которые поддерживают поведение CLOS по умолчанию."

#: ./en/ch12.md:102
msgid ""
"For most CLOS application programs, the default behavior of CLOS is "
"sufficiently powerful and flexible that there is no need to know or care "
"that classes, methods, and generic functions are themselves instances of "
"classes. Programmers interested in other object-oriented paradigms can use "
"CLOS as a basis for experimentation. Programmers can define new metaclasses ("
"usually built on the standard metaclasses) that support new and different "
"behavior for classes. Programmers can also define new metaobject classes to "
"be the classes of generic functions or methods. This is an additional level "
"of CLOS, called the metaobject level. It is the foundation of the functional "
"level, which in turn is the foundation of the macro level."
msgstr ""
"Для большинства прикладных программ CLOS поведение CLOS по умолчанию является"
" достаточно мощным и гибким, поэтому нет необходимости знать или заботиться о"
" том, что классы, методы и обобщенные функции сами по себе являются"
" экземплярами классов. Программисты, интересующиеся другими"
" объектно-ориентированными парадигмами, могут использовать CLOS в качестве"
" основы для экспериментов. Программисты могут определять новые метаклассы"
" (обычно построенные на стандартных метаклассах), которые поддерживают новое"
" и отличное поведение классов. Программисты также могут определять новые"
" классы метаобъектов как классы обобщенных функций или методов. Это"
" дополнительный уровень CLOS, называемый уровнем метаобъекта. Это основа"
" функционального уровня, который, в свою очередь, является основой"
" макроуровня."

#: ./en/ch12.md:104
msgid ""
"In addition to fostering research and experimentation, the metaobject level "
"makes it possible to develop tools for browsing or analyzing CLOS programs. "
"The metaobject protocol describes how to obtain information about user-"
"defined CLOS elements: A class object can be queried for its class "
"precedence list, slots, and defclass options; a generic function object can "
"be queried for its set of methods. Information is available; browsers and "
"environmental tools can devise ways to present it usefullyto CLOS "
"programmers."
msgstr ""
"В дополнение к стимулированию исследований и экспериментов, метаобъектный"
" уровень позволяет разрабатывать инструменты для просмотра или анализа"
" программ CLOS. Протокол metaobject описывает, как получить информацию о"
" пользовательских элементах CLOS: объект класса может быть запрошен для"
" получения его списка приоритетов  классов, слотов и параметров defclass;"
" объект обобщенной функции может быть запрошен для его набора методов."
" Информация доступна; браузеры и инструменты среды могут разработать способы"
" ее полезного представления программистам CLOS."

#: ./en/ch12.md:110
msgid ""
"| CLOS Level | Deals with | Context of Use                   |\n"
"|------------|------------|----------------------------------|\n"
"| Macro      | names      | most CLOS applications           |\n"
"| Functional | objects    | programs using anonymous objects |\n"
"| Metaobject | metaobjects| tools, research, experimentation |"
msgstr ""
"| уровень CLOS |имеет дело с| Контекста использования                   |\n"
"|--------------|------------|-------------------------------------------|\n"
"| Macro        | names      | большинство CLOS приложений               |\n"
"| Functional   | objects    | программы, использующие анонимные объекты |\n"
"| Metaobject   | metaobjects| инструменты, исследования, эксперименты   |"

#: ./en/ch12.md:113
msgid "### Classes, Superclasses, and Metaclasses"
msgstr "### Классы, Суперклассы и Метаклассы"

#: ./en/ch12.md:115
msgid ""
"Discussing metaclasses adds a degree of complexity to the CLOS model. Even "
"the terminology is confusing. Here we make some statements that should help "
"clarify the meanings of classes, superclasses, and metaclasses. The "
"following concepts are used in CLOS application programming:"
msgstr ""
"Обсуждение метаклассов добавляет определенную степень сложности модели CLOS."
" Даже терминология сбивает с толку. Здесь мы делаем некоторые утверждения,"
" которые должны помочь прояснить значения классов, суперклассов и"
" метаклассов. В прикладном программировании CLOS используются следующие"
" концепции:"

#: ./en/ch12.md:119
msgid ""
"* Every Lisp object is an instance of a class. You can use (class-of object) "
"to find out the class of an object. \n"
"* The class of an object determines its structure and behavior. All "
"instances of a given class have the same set of slots. Any method that "
"specializes on a given class is applicable to all instances of that class. \n"
"* A class has a set of superclasses. The class inherits structure and "
"behavior from its superclasses. In other words, methods attached to a class "
"are applicable to instances of subclasses of that class."
msgstr ""
"* Каждый объект Lisp является экземпляром класса. Вы можете использовать"
" (class-of object), чтобы узнать класс объекта.\n"
"* Класс объекта определяет его структуру и поведение. Все экземпляры данного"
" класса имеют одинаковый\n набор слотов. Любой метод, который"
" специализируется на данном классе, применим ко всем экземплярам этого"
" класса.\n"
"* Класс имеет набор суперклассов. Класс наследует структуру и поведение от"
" своих суперклассов. Другими словами, методы, присоединенные к классу,"
" применимы к экземплярам подклассов этого класса."

#: ./en/ch12.md:121
msgid ""
"The following are concepts of CLOS metaobject programming. Notice that each "
"of these concepts is a natural extension of a concept used in application "
"programming."
msgstr ""
"Ниже приведены концепции метаобъектного программирования CLOS. Обратите"
" внимание, что каждое из этих понятий является естественным продолжением"
" концепции, используемой в прикладном программировании."

#: ./en/ch12.md:125
msgid ""
"* Since every Lisp object is an instance of a class, a class object itself "
"is an instance of a class. You can use (class-of class-object) to find out "
"the class of a class object. The term for the class of class objects is "
"metaclass. In other words, the instances of a metaclass are class objects. \n"
"*  The class of a class object (which is a metaclass) determines the "
"structure and behavior of that class object. All classes of a given "
"metaclass have the same set of slots. Methods that specialize on a given "
"metaclass are applicable to all class objects of that metaclass.\n"
"*   A class has a set of superclasses. The class inherits structure and "
"behavior from its superclasses. Because a metaclass is a class, it can also "
"have superclasses from which it inherits structure and behavior. In other "
"words, methods attached to a metaclass are applicable to instances of "
"subclasses of that metaclass. "
msgstr ""
"* Поскольку каждый объект Lisp является экземпляром класса, сам объект класса"
" является экземпляром класса. Вы можете использовать (class-of class-object),"
" чтобы узнать класс объекта класса. Термин, обозначающий класс объектов"
" класса, - это метакласс. Другими словами, экземпляры метакласса являются"
" объектами класса.\n"
"* Класс объекта класса (который является метаклассом) определяет структуру и"
" поведение этого объекта класса. Все классы данного метакласса имеют"
" одинаковый набор слотов. Методы, которые специализируются на данном"
" метаклассе, применимы ко всем объектам класса этого метакласса.\n"
"* Класс имеет набор суперклассов. Класс наследует структуру и поведение от"
" своих суперклассов. Поскольку метакласс - это класс, у него также могут быть"
" суперклассы, от которых он наследует структуру и поведение. Другими словами,"
" методы, присоединенные к метаклассу, применимы к экземплярам подклассов"
" этого метакласса."

#: ./en/ch12.md:127
msgid "### Metaobject Programming"
msgstr "### Программирование метаобъектов"

#: ./en/ch12.md:129
msgid ""
"The CLOS specification documents a set of predefined metaobjects and the "
"protocol they follow. Developers can use these metaobjects as a point of "
"departure. To support classes with entirely different behavior, you can "
"define a new metaclass. You can modify the default behavior only slightly by "
"defining a class built on standard-class; in this way, you can override some "
"aspects of behavior while inheriting other aspects. "
msgstr ""
"Спецификация CLOS документирует набор предопределенных метаобъектов и"
" протокол, которому они следуют. Разработчики могут использовать эти"
" метаобъекты в качестве отправной точки. Чтобы поддерживать классы с"
" совершенно другим поведением, вы можете определить новый метакласс. Вы"
" можете лишь слегка изменить поведение по умолчанию, определив класс,"
" построенный на основе standard-class; таким образом, вы можете"
" переопределить некоторые аспекты поведения, наследуя другие аспекты."

#: ./en/ch12.md:130
msgid ""
"We have already stated that CLOS application programs are portable. The "
"portability benefit applies to metaobject programs as well. A developer can "
"invent a new paradigm and applications based on it, and can run them on "
"other CLOS implementations. New paradigms can be shared freely, which "
"facilitates further research. Applications using alternative paradigms are "
"portable, so end users can also benefit from the metaobject protocol. "
msgstr ""
"Мы уже говорили, что CLOS прикладные программы переносимы. Преимущество"
" переносимости распространяется и на метаобъектные программы. Разработчик"
" может изобрести новую парадигму и приложения, основанные на ней, и может"
" запускать их в других реализациях CLOS. Новыми парадигмами можно свободно"
" делиться, что облегчает дальнейшие исследования. Приложения, использующие"
" альтернативные парадигмы, являются переносимыми, поэтому конечные"
" пользователи также могут воспользоваться протоколом metaobject."
