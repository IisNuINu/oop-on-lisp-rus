#. extracted from ./en/ch06.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-10-10 10:49+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch06.md:2
msgid "# Class Inheritance "
msgstr "# Наследование классов"

#: ./en/ch06.md:4
msgid ""
"CLOS uses the class precedence list to determine the precedence, or "
"dominance, of any competing traits. This chapter describes how the class "
"precedence list is determined and how it controls the inheritance of slots "
"and slot options. We also discuss the classes that are implicitly included "
"as superclasses: standard-object and t."
msgstr ""
"CLOS использует список приоритета класса для определения приоритета или"
" доминирования любых конкурирующих признаков. В этой главе описывается, как"
" определяется список приоритетов классов и как он управляет наследованием"
" слотов и опций слотов. Мы также обсуждаем классы, которые неявно включены в"
" качестве суперклассов: standard-object и t."

#: ./en/ch06.md:6
msgid "## 6.1 INHERITANCE FROM DEFAULT CLASSES"
msgstr "## 6.1 НАСЛЕДОВАНИЕ ОТ КЛАССОВ ПО УМОЛЧАНИЮ"

#: ./en/ch06.md:8
msgid ""
"All classes implicitly include t as a superclass. This is true for user-"
"defined classes (those we define with defclass) and built-in classes (such "
"as array and integer). The only exception is the class t itself, which has "
"no superclasses. One effect of inheriting from t is that every Lisp object "
"is of the type t. The type t is the root of the Common Lisp type system, and "
"the class t is the root of the CLOS class system."
msgstr ""
"Все классы неявно включают t в качестве суперкласса. Это верно для"
" пользовательских классов (тех, которые мы определяем с помощью defclass) и"
" встроенных классов (таких как array и integer). Единственным исключением"
" является сам класс t, у которого нет суперклассов. Одним из последствий"
" наследования от t является то, что каждый объект Lisp имеет тип t. Тип t"
" является корнем системы типов Common Lisp, а класс t является корнем системы"
" классов CLOS."

#: ./en/ch06.md:10
msgid ""
"All user-defined classes also implicitly include standard-object as a "
"superclass, but built-in classes do not. The existence of standard-object "
"enables CLOS implementations to define default behavior that is inherited by "
"all user-defined classes. For example, primary methods for the class "
"standard-object implement the print-object and describe generic functions. "
"The classes t and standard-object do not have slots. "
msgstr ""
"Все пользовательские классы также неявно включают стандартный объект в"
" качестве суперкласса, но встроенные классы этого не делают. Существование"
" standard-object позволяет реализациям CLOS определять поведение по"
" умолчанию, которое наследуется всеми пользовательскими классами. Например,"
" первичные методы для класса standard-object реализуют print-object и"
" описывают обобщенные функции. Классы t и standard-object не имеют слотов."

#: ./en/ch06.md:12
msgid ""
"All classes have t as the last (least specific) class in their class "
"precedence lists. All user-defined classes have standard-object as the "
"second-to-last class in their class precedence lists. This is something you "
"can take for granted; it is always true."
msgstr ""
"Все классы имеют t в качестве последнего (наименее специфичного) класса в"
" своих списках приоритетов классов. Все пользовательские классы имеют"
" standard-object в качестве предпоследнего класса в своих списках приоритетов"
" классов. Это то, что вы можете считать само собой разумеющимся; это всегда"
" верно."

#: ./en/ch06.md:14
msgid "## 6.2 THE CLASS PRECEDENCE LIST"
msgstr "## 6.2 СПИСОК ПРИОРИТЕТОВ(предшествования) КЛАССОВ"

#: ./en/ch06.md:16
msgid ""
"CLOS calculates the class precedence list of each class. The class "
"precedence list contains the class itself and all its superclasses; it does "
"not contain any duplicate classes. The order of the classes in the class "
"precedence list is significant; it goes from most specific to least "
"specific. If one class is more specific than a second class, that class has "
"precedence over the second class."
msgstr ""
"CLOS вычисляет список приоритетов классов для каждого класса. Список"
" приоритетов классов содержит сам класс и все его суперклассы; он не содержит"
" никаких повторяющихся классов. Порядок классов в списке приоритета классов"
" имеет большое значение; он идет от наиболее специфичного к наименее"
" специфичному. Если один класс более специфичен, чем второй класс, этот класс"
" имеет приоритет над вторым классом."

#: ./en/ch06.md:18
msgid "The two rules governing the precedence order of classes are: "
msgstr "Двумя правилами, регулирующими порядок приоритета классов, являются:"

#: ./en/ch06.md:22
msgid ""
"|    Rule 1 of class precedence:                          |\n"
"|---------------------------------------------------------|\n"
"| A class always has precedence over its superclasses.    |"
msgstr ""
"| Правило 1 приоритета класса:                            |\n"
"|---------------------------------------------------------|\n"
"| Класс всегда имеет приоритет над своими суперклассами.  |"

#: ./en/ch06.md:24
msgid ""
"Rule 1 allows a class to override or modify aspects of behavior supplied by "
"its superclasses."
msgstr ""
"Правило 1 позволяет классу переопределять или изменять аспекты поведения,"
" предоставляемые его суперклассами."

#: ./en/ch06.md:29
msgid ""
"|     Rule 2 of class precedence:                                  |\n"
"|------------------------------------------------------------------|\n"
"|Each class definition sets the precedence order of its direct su- |\n"
"|perclasses.                                                       |"
msgstr ""
"| Правило 2 приоритета класса:                                     |\n"
"|------------------------------------------------------------------|\n"
"| Каждое определение класса устанавливает порядок приоритета своих |\n"
"| прямых суперклассов.                                             |"

#: ./en/ch06.md:31
msgid ""
"For Rule 2, the ordering constraints on the direct superclasses are obtained "
"by the order of superclasses listed in the defclass form. That is, each "
"class is more specific than the classes that follow it in this list."
msgstr ""
"Для правила 2 ограничения на порядок для прямых суперклассов определяются"
" порядком суперклассов, перечисленных в форме defclass. То есть каждый класс"
" более специфичен, чем классы, которые следуют за ним в этом списке."

#: ./en/ch06.md:33
msgid ""
"By considering Rule 1 alone, we know the most specific class and the least "
"specific class in any class precedence list. The class itself is always the "
"most specific class in its own class precedence list, and the class t the "
"least specific class in any class precedence list. (Since every class has t "
"as a superclass, t cannot precede any class and is therefore always last in "
"all class precedence lists.) For user-defined classes, standard-object is "
"the second-to-last class in the class precedence list. In the examples that "
"follow, we do not explicitly mention the ordering constraints of standard-"
"object or t, because the constraints are always the same."
msgstr ""
"Рассматривая только правило 1, мы знаем наиболее специфичный класс и наименее"
" специфичный класс в любом списке приоритетов классов. Сам класс всегда"
" является наиболее специфичным классом в своем собственном списке приоритетов"
" классов, а класс t - наименее специфичным классом в любом списке приоритетов"
" классов. (Поскольку каждый класс имеет t в качестве суперкласса, t не может"
" предшествовать какому-либо классу и поэтому всегда является последним во"
" всех списках приоритета классов.) Для пользовательских классов"
" standard-object является предпоследним классом в списке приоритетов классов."
" В следующих примерах мы явно не упоминаем ограничения упорядочения"
" standard-object или t, поскольку ограничения всегда одни и те же."

#: ./en/ch06.md:35
msgid ""
"When CLOS determines the class precedence list of a class, it starts with "
"the definition of the class. CLOS applies both rules to the class definition "
"and obtains a set of local ordering constraints. CLOS then applies the rules "
"to the definitions of each of the direct superclasses, each of their direct "
"superclasses, and so on, until all paths end in the root class t. The result "
"is a set of ordering constraints on the classes."
msgstr ""
"Когда CLOS определяет список приоритетов класса для класса, он начинается с"
" определения класса. CLOS применяет оба правила к определению класса и"
" получает набор локальных ограничений упорядочения. Затем CLOS применяет"
" правила к определениям каждого из прямых суперклассов, каждого из их прямых"
" суперклассов и так далее, пока все пути не закончатся в корневом классе t."
" Результатом является набор упорядочивающих ограничений для классов."

#: ./en/ch06.md:37
msgid ""
"The next step is to find a total ordering that satisfies all the ordering "
"constraints. CLOS does this by sorting the set of ordering constraints "
"topologically. In other words, each of the constraints is a partial order, "
"and the class precedence list is achieved by doing a topological sort on the "
"set of partial orders. The result is one of these three possibilities:"
msgstr ""
"Следующий шаг - найти общий порядок, который удовлетворяет всем ограничениям"
" упорядочения. CLOS делает это, сортируя набор ограничений упорядочения"
" топологически. Другими словами, каждое из ограничений является частичным"
" порядком, и список приоритетов классов достигается путем выполнения"
" топологической сортировки по набору частичных порядков. Результатом является"
" одна из этих трех возможностей:"

#: ./en/ch06.md:41
msgid ""
"\t > Case 1. Exactly one total ordering satisfies the constraints \n"
"\t > Case 2. Several total orderings satisfy the constraints \n"
"\t > Case 3. No total ordering satisfies the constraints "
msgstr ""
"\t> Случай 1. Ровно один полный порядок удовлетворяет ограничениям\n"
"\t> Случай 2. Несколько полных упорядочений удовлетворяют ограничениям\n"
"\t> Случай 3. Никакой полный порядок не удовлетворяет ограничениям"

#: ./en/ch06.md:44
msgid ""
"In either of the first two cases, CLOS produces a class precedence list. \n"
"In the third case, it signals an error. "
msgstr ""
"В любом из первых двух случаев CLOS создает список приоритетов классов."
"В третьем случае это сигнализирует об ошибке."

#: ./en/ch06.md:46
msgid ""
"We present examples of each of these cases. The examples show definitions of "
"various stream classes that have superclasses but no slots. We do not intend "
"to describe the semantics of these classes, but rather to focus on the "
"mechanics of class precedence lists. (In \"Developing an Advanced CLOS "
"Program: Streams,\" page 171 we develop a stream example based on an "
"organization of a large number of classes.)"
msgstr ""
"Мы приводим примеры каждого из этих случаев. В примерах показаны определения"
" различных классов потоков, которые имеют суперклассы, но не имеют слотов. Мы"
" не намерены описывать семантику этих классов, а скорее сосредоточимся на"
" механике списков приоритета классов. (В разделе \"Разработка расширенной"
" программы CLOS: Потоки\", стр. 171, мы разрабатываем пример потока,"
" основанный на организации большого количества классов.)"

#: ./en/ch06.md:48
msgid "### Case 1: Exactly One Total Ordering Satisfies the Constraints"
msgstr "### Случай 1: Ровно один Общий порядок Удовлетворяет ограничениям"

#: ./en/ch06.md:50
msgid ""
"In this case, when CLOS applies the two class precedence rules to the class "
"definitions of the class and all its superclasses, the result is only one "
"possible ordering. This becomes the class precedence list."
msgstr ""
"В этом случае, когда CLOS применяет два правила приоритета классов к"
" определениям классов, класса и всех его суперклассов, результатом является"
" только один возможный порядок. Это становится списком приоритетов классов."

#: ./en/ch06.md:52
msgid ""
"Here is an example. Our goal is to determine the class precedence list for "
"the class char-input-stream, given the following class definitions:"
msgstr ""
"Вот пример. Наша цель - определить список приоритетов классов для класса"
" char-input-stream, учитывая следующие определения классов:"

#: ./en/ch06.md:61
msgid ""
"<pre>\n"
"(defclass stream () ()) \n"
"(defclass input-stream (stream) ()) \n"
"(defclass char-stream (stream) ()) \n"
"(defclass char-input-stream \n"
"    (char-stream input-stream) \n"
"  ()) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:63
msgid ""
"The following chart gives the set of ordering constraints for char-input-"
"stream. The symbol >> is shorthand for \"precedes.\" Each constraint is the "
"result of applying one of the class precedence rules to one of the class "
"definitions. Thus, the first entry in the chart means \"The class input-"
"stream precedes the class stream, which is the result of applying Rule 1 to "
"the input-stream class definition.\" Similarly, the last entry means \"The "
"class char-stream precedes the class input-stream, which is the result of "
"applying Rule 2 to the char-input-stream class definition.\""
msgstr ""
"На следующей диаграмме приведен набор ограничений упорядочения для"
" char-input-stream. Символ >> является сокращением для обозначения"
" \"предшествует\". Каждое ограничение является результатом применения одного"
" из правил приоритета класса к одному из определений класса. Таким образом,"
" первая запись на диаграмме означает \"Входной поток класса предшествует"
" потоку класса, который является результатом применения Правила 1 к"
" определению класса входного потока\". Аналогично, последняя запись означает"
" \"Класс char-stream предшествует классу input-stream, что является"
" результатом применения правила 2 к определению класса char-input-stream\"."

#: ./en/ch06.md:71
msgid ""
"|  Constraint                     | Rule | Class             |\n"
"|---------------------------------|------|-------------------|\n"
"| input-stream » stream           |  1   | input-stream      |\n"
"| char-stream » stream            |  1   | char-stream       |\n"
"| char-input-stream » char-stream |  1   | char-input-stream |\n"
"| char-input-stream » input-stream|  1   | char-input-stream |\n"
"| char-stream » input-stream      |  2   | char-input-stream |"
msgstr ""
"| Ограничение                     | Правило | Класс             |\n"
"|---------------------------------|---------|-------------------|\n"
"| input-stream » stream           |  1      | input-stream      |\n"
"| char-stream » stream            |  1      | char-stream       |\n"
"| char-input-stream » char-stream |  1      | char-input-stream |\n"
"| char-input-stream » input-stream|  1      | char-input-stream |\n"
"| char-stream » input-stream      |  2      | char-input-stream |"

#: ./en/ch06.md:73
msgid ""
"Exactly one total ordering satisfies the constraints, so the class "
"precedence list for the class char-input-stream is"
msgstr ""
"Ровно один общий порядок удовлетворяет ограничениям, поэтому список"
" приоритетов классов для класса char-input-stream равен"

#: ./en/ch06.md:78
msgid ""
"<pre>\n"
"(char-input-stream char-stream input-stream stream \n"
"                   standard-object t) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:80
msgid ""
"Although the class stream is included by two different classes (it is a "
"direct superclass of both char-stream and input-stream), there are no "
"duplicate classes in the class precedence list."
msgstr ""
"Хотя класс stream включен двумя разными классами (это прямой суперкласс как"
" char-stream, так и input-stream), в списке приоритетов классов нет"
" повторяющихся классов."

#: ./en/ch06.md:82
msgid "### Case 2: Several Total Orderings Satisfy the Constraints"
msgstr "### Случай 2: Несколько полных порядков Удовлетворяют ограничениям"

#: ./en/ch06.md:84
msgid ""
"For many programs, the two class precedence rules do not yield a single "
"class precedence order. That is, some pairs of classes might not have an "
"ordering constraint based on the rules. This can happen when neither class "
"is a superclass of the other (Rule 1 does not constrain their relative "
"precedence), and no class includes both classes as direct superclasses (Rule "
"2 does not constrain their relative precedence). This does not pose a "
"problem for three reasons:"
msgstr ""
"Для многих программ два правила приоритета классов не приводят к единому"
" порядку приоритета классов. То есть некоторые пары классов могут не иметь"
" ограничения на порядок, основанного на правилах. Это может произойти, когда"
" ни один из классов не является суперклассом другого (правило 1 не"
" ограничивает их относительный приоритет), и ни один класс не включает оба"
" класса в качестве прямых суперклассов (Правило 2 не ограничивает их"
" относительный приоритет). Это не представляет проблемы по трем причинам:"

#: ./en/ch06.md:86
msgid ""
"*   The lack of constraints implies no conflict. When no ordering constraint "
"on two classes is given, this implies that their relative precedence order "
"is not important. If the order of two classes is important, the programmer "
"can and should set an ordering constraint by explicitly including them as "
"direct superclasses of the new class. "
msgstr ""
"* Отсутствие ограничений подразумевает отсутствие конфликта. Когда не задано"
" ограничение на порядок для двух классов, это означает, что их относительный"
" порядок приоритета не важен. Если порядок двух классов важен, программист"
" может и должен установить ограничение на порядок, явно включив их в качестве"
" прямых суперклассов нового класса."

#: ./en/ch06.md:88
msgid ""
"*    CLOS chooses one of the possible orderings. CLOS uses an algorithm that "
"always yields a deterministic ranking of classes. This guarantees that all "
"implementations of CLOS choose the same class precedence list, given the "
"same set of class definitions. The details of the algorithm are not "
"important, but the guarantee that the algorithm is deterministic provides a "
"safety net for situations where a working CLOS program depends on a certain "
"order without explicitly stating the dependency in a class definition. Such "
"a program is portable to another CLOS implementation."
msgstr ""
"* CLOS выбирает один из возможных порядков. CLOS использует алгоритм, который"
" всегда выдает детерминированное ранжирование классов. Это гарантирует, что"
" все реализации CLOS выбирают один и тот же список приоритетов классов,"
" учитывая один и тот же набор определений классов. Детали алгоритма не важны,"
" но гарантия того, что алгоритм является детерминированным, обеспечивает"
" защиту в ситуациях, когда работающая программа CLOS зависит от определенного"
" порядка без явного указания зависимости в определении класса. Такая"
" программа переносима на другую реализацию CLOS."

#: ./en/ch06.md:90
msgid ""
"*    CLOS tries to keep family trees together in the class precedence list. "
"Consider a class and its superclasses to be a \"family tree.\" When applying "
"the algorithm to choose one ordering from the set of possible orderings, "
"CLOS uses this guideline: The entire \"family tree\" of each direct "
"superclass is kept together in the class precedence list, if that would not "
"violate either of the two class precedence rules."
msgstr ""
"* CLOS пытается сохранить генеалогические древа вместе в списке приоритетов"
" классов. Рассматривайте класс и его суперклассы как \"генеалогическое"
" древо\". Применяя алгоритм для выбора одного порядка из множества возможных"
" порядков, CLOS использует это руководство: все \"генеалогическое древо\""
" каждого прямого суперкласса хранится вместе в списке приоритета класса, если"
" это не нарушает ни одно из двух правил приоритета класса."

#: ./en/ch06.md:92
msgid ""
"Consider a class ascii-disk-stream that has two direct superclasses, ascii-"
"stream and disk-stream. The class ascii-stream precedes disk-stream, and (if "
"possible) all the superclasses of ascii-stream precede disk-stream in the "
"class precedence list. The effect is that you can treat ascii-stream as a "
"\"black box\" of behavior; disk-stream cannot override behavior supplied by "
"ascii-stream or any of its superclasses."
msgstr ""
"Рассмотрим класс ascii-disk-stream, который имеет два прямых суперкласса,"
" ascii-stream и disk-stream. Класс ascii-stream предшествует disk-stream, и"
" (если возможно) все суперклассы ascii-stream предшествуют disk-stream в"
" списке приоритетов классов. Эффект заключается в том, что вы можете"
" рассматривать ascii-stream как \"черный ящик\" поведения; disk-stream не"
" может переопределять поведение, предоставляемое ascii-stream или любым из"
" его суперклассов."

#: ./en/ch06.md:94
msgid ""
"In cases where other ordering constraints prevent CLOS from following this "
"guideline (that is, the result would violate one or both of the rules) CLOS "
"chooses an ordering that keeps the members of each family tree as close "
"together as possible."
msgstr ""
"В случаях, когда другие ограничения порядка не позволяют CLOS следовать этому"
" руководству (то есть результат нарушил бы одно или оба правила), CLOS"
" выбирает порядок, при котором члены каждого генеалогического древа"
" располагаются как можно ближе друг к другу."

#: ./en/ch06.md:96
msgid ""
"Here we give an example of the case when several total orderings satisfy the "
"constraints. We determine the class precedence list for the class ascii-disk-"
"stream, given the following class definitions:"
msgstr ""
"Здесь мы приводим пример случая, когда несколько полных упорядочений"
" удовлетворяют ограничениям. Мы определяем список приоритетов классов для"
" класса ascii-disk-stream, учитывая следующие определения классов:"

#: ./en/ch06.md:108
msgid ""
"<pre>\n"
"(defclass stream () ()) \n"
"(defclass buffered-stream (stream) ()) \n"
"(defclass disk-stream (buffered-stream) ()) \n"
"(defclass char-stream (stream) ()) \n"
"(defclass ascii-stream (char-stream) ()) \n"
"(defclass ascii-disk-stream \n"
"    (ascii-stream \n"
"     disk-stream) \n"
"  0) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:110
msgid "The set of ordering constraints for ascii-disk-stream is as follows: "
msgstr ""
"Набор ограничений упорядочения для ascii-disk-stream выглядит следующим"
" образом:"

#: ./en/ch06.md:120
msgid ""
"| Constraint                      | Rule | Class             |\n"
"|---------------------------------|------|-------------------|\n"
"| buffered-stream » stream        | 1    | buffered-stream   |\n"
"| disk-stream » buffered-stream   | 1    | disk-stream       |\n"
"| char-stream » stream            | 1    | char-stream       |\n"
"| ascii-stream » char-stream      | 1    | ascii-stream      |\n"
"| ascii-disk-stream » ascii-stream| 1    | ascii-disk-stream |\n"
"| ascii-disk-stream » disk-stream | 1    | ascii-disk-stream |\n"
"| ascii-stream » disk-stream      | 2    | ascii-disk-stream |"
msgstr ""
"| Ограничение                     | Правило | Класс             | \n"
"|---------------------------------|---------|-------------------|\n"
"| buffered-stream » stream        | 1       | buffered-stream   |\n"
"| disk-stream » buffered-stream   | 1       | disk-stream       |\n"
"| char-stream » stream            | 1       | char-stream       |\n"
"| ascii-stream » char-stream      | 1       | ascii-stream      |\n"
"| ascii-disk-stream » ascii-stream| 1       | ascii-disk-stream |\n"
"| ascii-disk-stream » disk-stream | 1       | ascii-disk-stream |\n"
"| ascii-stream » disk-stream      | 2       | ascii-disk-stream |\n"

#: ./en/ch06.md:122
msgid ""
"There are no constraints on the precedence of char-stream with respect to "
"buffered-stream, or on the precedence of char-stream with respect to disk-"
"stream. Here, we show three total orderings that satisfy the constraints. "
"The middle line of each class precedence list shows where the changes occur:"
msgstr ""
"Нет никаких ограничений на приоритет потока символов по отношению к"
" буферизованному потоку или на приоритет потока символов по отношению к"
" дисковому потоку. Здесь мы показываем три полных порядка, которые"
" удовлетворяют ограничениям. Средняя строка списка приоритетов каждого класса"
" показывает, где происходят изменения:"

#: ./en/ch06.md:134
msgid ""
"<pre>\n"
"(ascii-disk-stream ascii-stream \n"
"                   char-stream disk-stream buffered-stream \n"
"                   stream standard-object t) \n"
"(ascii-disk-stream ascii-stream \n"
"                   disk-stream buffered-stream char-stream \n"
"                   stream standard-object t) \n"
"(ascii-disk-stream ascii-stream \n"
"                   disk-stream char-stream buffered-stream \n"
"                   stream standard-object t)\n"
"</pre>"
msgstr ""

#: ./en/ch06.md:136
msgid ""
"In this case, CLOS chooses the first total ordering. Here, we see an "
"illustration of the guideline that family trees are kept together. The "
"family tree of ascii-stream precedes the family tree of disk-stream, except "
"for the class stream, which is a superclass of both ascii-stream and disk-"
"stream."
msgstr ""
"В этом случае CLOS выбирает первый общий заказ. Здесь мы видим иллюстрацию"
" принципа, согласно которому генеалогические деревья должны храниться вместе."
" Генеалогическое древо ascii-stream предшествует генеалогическому древу"
" disk-stream, за исключением класса stream, который является суперклассом как"
" ascii-stream, так и disk-stream."

#: ./en/ch06.md:138
msgid ""
"Sometimes it is not possible to keep family trees intact, but if two "
"superclasses have a \"common tail,\" it is moved to the end of the class "
"precedence list. Suppose class A has direct superclasses B and C, and the "
"class precedence list of B and C are as follows:"
msgstr ""
"Иногда невозможно сохранить генеалогические древа нетронутыми, но если два"
" суперкласса имеют \"общий хвост\", он перемещается в конец списка"
" приоритетов классов. Предположим, что класс A имеет прямые суперклассы B и"
" C, а список приоритетов классов B и C выглядит следующим образом:"

#: ./en/ch06.md:143
msgid ""
"| Class | Class Precedence List                    |\n"
"|-------|------------------------------------------|\n"
"|  B    | (B Bl B2 B3 B4 D Dl D2 standard-object t)| \n"
"|  C    | (C Cl C2 D Dl D2 standard-object t)      |"
msgstr ""

#: ./en/ch06.md:145
msgid ""
"The classes B and C have a common tail, because starting at D the two class "
"precedence lists are equal. Prior to class D, the class precedence lists are "
"disjoint. In the class precedence list of A, the common tail is moved to the "
"end:"
msgstr ""
"Классы B и C имеют общий хвост, потому что, начиная с D, два списка"
" приоритетов классов равны. До класса D списки приоритетов классов не"
" пересекаются. В списке приоритета класса A общий хвост перемещается в конец:"

#: ./en/ch06.md:149
msgid ""
"<pre>\n"
"(A B Bl B2 B3 B4 C Cl C2 D Dl D2 standard-object t) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:151
msgid ""
"There is no need for concern if several orderings satisfy the constraints "
"unless, in fact, the program does depend on one of the orderings. If so, you "
"should make the ordering dependency explicit, as shown next."
msgstr ""
"Нет необходимости беспокоиться, если несколько порядков удовлетворяют"
" ограничениям, если только на самом деле программа не зависит от одного из"
" порядков. Если это так, вы должны сделать зависимость упорядочения явной,"
" как показано далее."

#: ./en/ch06.md:153
msgid "### How to Add Ordering Constraints "
msgstr "### Как добавить ограничения на порядок"

#: ./en/ch06.md:155
msgid ""
"To continue the previous example, suppose some aspect of the program depends "
"on the class disk-stream preceding the class char-stream, and on the class "
"char-stream preceding buffered-stream. That is, you want the third of the "
"possible total orderings to be chosen. "
msgstr ""
"Чтобы продолжить предыдущий пример, предположим, что какой-то аспект"
" программы зависит от класса disk-stream, предшествующего классу char-stream,"
" и от класса char-stream, предшествующего buffered-stream. То есть вы хотите,"
" чтобы была выбрана треть из возможных общих порядков."

#: ./en/ch06.md:157
msgid ""
"In this example, it is hard to conceive of any semantic reason why the "
"stream program should have the dependencies mentioned, because there should "
"be no interaction between the classes whose order is unconstrained. In other "
"programs, however, there might well be interaction among various classes. "
msgstr ""
"В этом примере трудно представить какую-либо семантическую причину, по"
" которой потоковая программа должна иметь упомянутые зависимости, потому что"
" не должно быть никакого взаимодействия между классами, порядок которых не"
" ограничен. Однако в других программах вполне может быть взаимодействие между"
" различными классами."

#: ./en/ch06.md:159
msgid ""
"You can add the constraints mentioned by defining class ascii-disk-stream in "
"a different way: "
msgstr ""
"Вы можете добавить упомянутые ограничения, определив класс ascii-disk-stream"
" другим способом:"

#: ./en/ch06.md:166
msgid ""
"<pre>\n"
"(defclass ascii-disk-stream \n"
"    (ascii-stream disk-stream \n"
"     char-stream buffered-stream) \n"
"  0) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:168
msgid ""
"The previous constraints mentioned still hold, and there are two new "
"constraints: "
msgstr ""
"Предыдущие упомянутые ограничения все еще действуют, и есть два новых"
" ограничения:"

#: ./en/ch06.md:173
msgid ""
"| Constraint                   | Rule | Class            |\n"
"|------------------------------|------|------------------|\n"
"|disk-stream >> char-stream    | 2    | ascii-disk-stream|\n"
"|char-stream >> buffered-stream| 2    | ascii-disk-stream|"
msgstr ""
"| Ограничение                  | Правило | Класс            |\n"
"|------------------------------|---------|------------------|\n"
"|disk-stream >> char-stream    | 2       | ascii-disk-stream|\n"
"|char-stream >> buffered-stream| 2       | ascii-disk-stream|"

#: ./en/ch06.md:175
msgid ""
"These additional constraints result in exactly one possible total ordering: "
msgstr ""
"Эти дополнительные ограничения приводят ровно к одному возможному полному"
" упорядочению:"

#: ./en/ch06.md:181
msgid ""
"<pre>\n"
"(ascii-disk-stream ascii-stream \n"
"                   disk-stream char-stream buffered-stream \n"
"                   stream standard-object t) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:183
msgid "### Case 3: No Total Ordering Satisfies the Constraints "
msgstr "### Случай 3: Ни один Полный порядок не удовлетворяет ограничениям"

#: ./en/ch06.md:185
msgid ""
"No total ordering satisifies the constraints when a class is included by "
"more than one class definition and the local constraints set by the class "
"definitions are in direct conflict with each other."
msgstr ""
"Никакой полный порядок не удовлетворяет ограничениям, когда класс включен"
" более чем в одно определение класса, а локальные ограничения, установленные"
" определениями классов, находятся в прямом конфликте друг с другом."

#: ./en/ch06.md:187
msgid ""
"CLOS cannot resolve such a conflict, so it signals an error. You can then "
"edit the class definitions to remove some of the conflicting ordering "
"constraints. Here is an example of a class organization in which no total "
"ordering is possible. We try to determine the class precedence list for the "
"class ascii-disk-stream, given the following class definitions:"
msgstr ""
"CLOS не может разрешить такой конфликт, поэтому он сигнализирует об ошибке."
" Затем вы можете отредактировать определения классов, чтобы удалить некоторые"
" из конфликтующих ограничений упорядочения. Вот пример классовой организации,"
" в которой полный порядок невозможен. Мы пытаемся определить список"
" приоритетов классов для класса ascii-disk-stream, учитывая следующие"
" определения классов:"

#: ./en/ch06.md:198
msgid ""
"<pre>\n"
"(defclass stream () ()) \n"
"(defclass buffered-stream (stream) ()) \n"
"(defclass disk-stream (buffered-stream) ()) \n"
"(defclass char-stream (stream) ()) \n"
"(defclass ascii-stream (char-stream) ()) \n"
"(defclass ascii-disk-stream \n"
"    (ascii-stream buffered-stream disk-stream) \n"
"  ()) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:200
msgid ""
"Two of the class definitions result in a conflict. Here we present only the "
"conflicting constraints:"
msgstr ""
"Два определения класса приводят к конфликту. Здесь мы приводим только"
" противоречивые ограничения:"

#: ./en/ch06.md:205
msgid ""
"| Constraint                     | Rule | Class              |\n"
"|--------------------------------|------|--------------------|\n"
"| disk-stream >> buffered-stream | 1    | disk-stream        |\n"
"| buffered-stream >> disk-stream | 2    | ascii-disk-stream  |"
msgstr ""
"| Ограничение                    | Правило | Класс              |\n"
"|--------------------------------|---------|--------------------|\n"
"| disk-stream >> buffered-stream | 1       | disk-stream        |\n"
"| buffered-stream >> disk-stream | 2       | ascii-disk-stream  |"

#: ./en/ch06.md:207
msgid ""
"In this case, CLOS signals an error because it cannot produce a class "
"precedence list consistent with the ordering constraints."
msgstr ""
"В этом случае CLOS сигнализирует об ошибке, поскольку он не может создать"
" список приоритетов классов, соответствующий ограничениям упорядочения."

#: ./en/ch06.md:209
msgid ""
"It is clear that this class organization is flawed. The class ascii-disk-"
"stream depends on buffered-stream preceding disk-stream, but the class disk-"
"stream depends on disk-stream preceding buffered-stream."
msgstr ""
"Ясно, что эта классовая организация порочна. Класс ascii-disk-stream зависит"
" от буферизованного потока, предшествующего disk-stream, но класс disk-stream"
" зависит от disk-stream, предшествующего buffered-stream."

#: ./en/ch06.md:211
msgid ""
"This particular problem might have been caused by a misunderstanding of the "
"class organization. It seems likely that the constraint set by the disk-"
"stream definition is a semantic constraint that is necessary to the correct "
"working of disk streams, but that the constraint set by ascii-disk-stream is "
"simply a programmer error. Probably, there was no need to include buffered-"
"stream as a direct superclass of ascii-disk-stream. "
msgstr ""
"Эта конкретная проблема могла быть вызвана неправильным пониманием классовой"
" организации. Представляется вероятным, что ограничение, установленное"
" определением disk-stream, является семантическим ограничением, необходимым"
" для правильной работы дисковых потоков, но что ограничение, установленное"
" ascii-disk-stream, является просто ошибкой программиста. Вероятно, не было"
" необходимости включать buffered-stream в качестве прямого суперкласса"
" ascii-disk-stream."

#: ./en/ch06.md:213
msgid ""
"If the class ascii-disk-stream really does depend on buffered-stream "
"preceding disk-stream, however, then the problem lies somewhere in the class "
"organization. The solution is to rethink the semantics of the class "
"organization."
msgstr ""
"Однако, если класс ascii-disk-stream действительно зависит от буферизованного"
" потока, предшествующего disk-stream, то проблема кроется где-то в"
" организации класса. Решение состоит в том, чтобы переосмыслить семантику"
" организации классов."

#: ./en/ch06.md:215
msgid "### Opposing Constraints Are Possible"
msgstr "### Возможны Противоположные Ограничения"

#: ./en/ch06.md:217
msgid ""
"It is possible to define two classes that contain opposing ordering "
"constraints, as long as you do not try to define a class that is built on "
"both of them."
msgstr ""
"Можно определить два класса, которые содержат противоположные ограничения"
" упорядочения, до тех пор, пока вы не попытаетесь определить класс,"
" построенный на них обоих."

#: ./en/ch06.md:225
msgid ""
"<pre>\n"
"(defclass stream () ()) \n"
"(defclass input-stream (stream) ()) \n"
"(defclass buffered-stream (stream) ()) \n"
"(defclass disk-stream (buffered-stream input-stream) ()) \n"
"(defclass tape-stream (input-stream buffered-stream) ()) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:227
msgid ""
"Note that class disk-stream requires buffered-stream to precede input-"
"stream, but the class tape-stream requires input-stream to precede buffered-"
"stream."
msgstr ""
"Обратите внимание, что класс disk-stream требует, чтобы буферизованный поток"
" предшествовал входному потоку, но класс tape-stream требует, чтобы входной"
" поток предшествовал буферизованному потоку."

#: ./en/ch06.md:229
msgid ""
"These class definitions do not conflict, because as yet there is no "
"connection between the classes disk-stream and tape-stream. However, CLOS "
"would signal an error if you tried to define a class built on both disk-"
"stream and tape-stream:"
msgstr ""
"Эти определения классов не конфликтуют, поскольку пока нет связи между"
" классами disk-stream и tape-stream. Однако CLOS будет сигнализировать об"
" ошибке, если вы попытаетесь определить класс, построенный как на"
" disk-stream, так и на tape-stream:"

#: ./en/ch06.md:233
msgid ""
"<pre>\n"
"(defclass disk-emulating-tape-stream (disk-stream tape-stream) ()) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:235
msgid "## 6.3 GUIDELINES ON DESIGNING CLASS ORGANIZATIONS "
msgstr "## 6.3 РУКОВОДСТВО ПО ПРОЕКТИРОВАНИЮ ОРГАНИЗАЦИИ КЛАССОВ"

#: ./en/ch06.md:238
msgid ""
"This section discusses how the class precedence rules affect programming "
"practice. An important aspect of the two class precedence rules is that the "
"programmer controls the ordering constraints locally, by deciding which "
"direct superclasses to include and what their order should be. \n"
"If all the local ordering constraints are correct, the resulting class "
"precedence list will be appropriate. When designing a class organization, "
"you should concentrate on the effect of the two rules on each class "
"definition, without being concerned about the final class precedence list."
msgstr ""
"В этом разделе обсуждается, как правила приоритета классов влияют на практику"
" программирования. Важным аспектом двух правил приоритета классов является"
" то, что программист управляет ограничениями порядка локально, решая, какие"
" прямые суперклассы включать и каким должен быть их порядок.\n"
"Если все ограничения локального порядка верны, результирующий список"
" приоритетов классов будет соответствующим. При разработке организации"
" классов вы должны сосредоточиться на влиянии двух правил на каждое"
" определение класса, не заботясь об окончательном списке приоритетов классов."

#: ./en/ch06.md:242
msgid ""
"|  Rule 1 of class precedence:                                |\n"
"|-------------------------------------------------------------|\n"
"| A class always has precedence over its superclasses.        |"
msgstr ""
"| Правило 1 приоритета класса:                                |\n"
"|-------------------------------------------------------------|\n"
"| Класс всегда имеет приоритет над своими суперклассами.      |"

#: ./en/ch06.md:244
msgid ""
"Rule 1 suggests that you should define one or more basic classes and build "
"more specialized classes on them. This style of programming allows the "
"specialized classes to inherit desired behavior and override unwanted "
"behavior."
msgstr ""
"Правило 1 предполагает, что вы должны определить один или несколько базовых"
" классов и создать на их основе более специализированные классы. Этот стиль"
" программирования позволяет специализированным классам наследовать желаемое"
" поведение и переопределять нежелательное."

#: ./en/ch06.md:249
msgid ""
"| Rule 2 of class precedence:                                       |\n"
"|-------------------------------------------------------------------|\n"
"| Each class definition sets the precedence order of its direct su- |\n"
"| perclasses.                                                       |"
msgstr ""
"| Правило 2 приоритета класса:                                      |\n"
"|-------------------------------------------------------------------|\n"
"|Каждое определение класса устанавливает порядок приоритета своих   |\n"
"| прямых суперклассов.                                              |"

#: ./en/ch06.md:251
msgid ""
"Rule 2 has implications for classes built on more than one direct "
"superclass. In some cases, each direct superclass makes a distinct "
"contribution, and there is no conflict between them; then it does not matter "
"how you order them in the list of superclasses. In other cases, however, two "
"superclasses offer competing traits. For example, they both might have a "
"primary method for the same generic function. In this case, you should "
"decide which of the two primary methods is more appropriate for the new "
"class and order the two direct superclasses accordingly."
msgstr ""
"Правило 2 имеет последствия для классов, построенных более чем на одном"
" прямом суперклассе. В некоторых случаях каждый прямой суперкласс вносит свой"
" особый вклад, и между ними нет конфликта; тогда не имеет значения, как вы"
" упорядочиваете их в списке суперклассов. Однако в других случаях два"
" суперкласса обладают конкурирующими чертами. Например, у них обоих может"
" быть основной метод для одной и той же обобщенной функции. В этом случае вам"
" следует решить, какой из двух основных методов более подходит для нового"
" класса, и соответствующим образом упорядочить два прямых суперкласса."

#: ./en/ch06.md:253
msgid ""
"Rule 2 also encourages the style of programming that uses mixin classes. In "
"this style, each mixin class supports a separate, well-defined aspect of "
"behavior. The goals of a mixin are to support that behavior completely and "
"not to collide with other classes. For example, a mixin might provide before-"
"methods and after-methods that modify the behavior of primary methods "
"provided by other classes. When a mixin does not compete with other classes, "
"its precedence order is not important. Usually a mixin has the root class as "
"its only superclass, so its ordering constraints are minimal. This allows a "
"class to be built from a set of many mixins."
msgstr ""
"Правило 2 также поощряет стиль программирования, использующий"
" mixin(смешанные) классы. В этом стиле каждый класс mixin поддерживает"
" отдельный, четко определенный аспект поведения. Цели примесей(mixin) состоят"
" в том, чтобы полностью поддерживать это поведение и не сталкиваться с"
" другими классами. Например, mixin может предоставлять методы (before-)\"до\""
" и (after-)\"после\", которые изменяют поведение первичных методов,"
" предоставляемых другими классами. Когда миксин не конкурирует с другими"
" классами, порядок его приоритета не важен. Обычно миксин имеет корневой"
" класс в качестве своего единственного суперкласса, поэтому его ограничения"
" на порядок минимальны. Это позволяет создавать класс из набора многих"
" миксинов."

#: ./en/ch06.md:255
msgid ""
"Note that the final class precedence list always satisfies the two rules—"
"and, in most cases, it also follows the guideline of keeping nonintersecting "
"family trees together. In most cases, a program can consider each of the "
"direct superclasses as a black box, and can rely on all the superclasses of "
"the first direct superclass preceding the second direct superclass and all "
"its superclasses. In cases where CLOS cannot follow the guideline (due to "
"other ordering constraints), the resulting class precedence list allows a "
"superclass of the second direct superclass to precede a superclass of the "
"first direct superclass."
msgstr ""
"Обратите внимание, что окончательный список приоритетов классов всегда"
" удовлетворяет двум правилам — и, в большинстве случаев, он также следует"
" руководству по сохранению непересекающихся генеалогических деревьев вместе."
" В большинстве случаев программа может рассматривать каждый из прямых"
" суперклассов как черный ящик и может полагаться на все суперклассы первого"
" прямого суперкласса, предшествующего второму прямому суперклассу, и на все"
" его суперклассы. В случаях, когда CLOS не могут следовать руководству (из-за"
" других ограничений упорядочения), результирующий список приоритетов классов"
" позволяет суперклассу второго прямого суперкласса предшествовать суперклассу"
" первого прямого суперкласса."

#: ./en/ch06.md:257
msgid ""
"As mentioned earlier, if a program depends on one class being more specific "
"than another, you should make that ordering constraint explicit. "
msgstr ""
"Как упоминалось ранее, если программа зависит от того, что один класс более"
" специфичен, чем другой, вы должны сделать это ограничение упорядочения явным."

#: ./en/ch06.md:259
msgid "## 6.4 INHERITANCE OF SLOTS AND SLOT OPTIONS "
msgstr "## 6.4 НАСЛЕДОВАНИЕ СЛОТОВ И ОПЦИЙ СЛОТОВ"

#: ./en/ch06.md:261
msgid ""
"A class can define a slot by providing a slot specifier, which includes the "
"name of the slot and possibly some slot options. In addition to the slots "
"that the class defines locally in its defclass form, the class inherits "
"slots and slot options defined by its superclasses."
msgstr ""
"Класс может определить слот, предоставив спецификатор слота, который включает"
" в себя имя слота и, возможно, некоторые параметры слота. В дополнение к"
" слотам, которые класс определяет локально в своей форме defclass, класс"
" наследует слоты и параметры слотов, определенные его суперклассами."

#: ./en/ch06.md:263
msgid "### Modifying Inherited Aspects of a Slot "
msgstr "### Изменение унаследованных аспектов слота"

#: ./en/ch06.md:265
msgid ""
"A class can modify or override aspects of a slot that would otherwise be "
"inherited, by providing a local slot specifier for a slot with the same "
"name. For example:"
msgstr ""
"Класс может изменять или переопределять аспекты слота, которые в противном"
" случае были бы унаследованы, предоставляя локальный спецификатор слота для"
" слота с тем же именем. Например:"

#: ./en/ch06.md:269
msgid ""
"<pre>\n"
"(defclass basic-lock () \n"
"  ((name :initarg :name))) "
msgstr ""

#: ./en/ch06.md:273
msgid ""
"(defclass simple-lock (basic-lock) \n"
"  ((name :initform \"Simple Lock\"))) \n"
"</pre>"
msgstr ""

#: ./en/ch06.md:275
msgid ""
"The class basic-lock provides a slot specifier for a slot named name and the "
":initarg :name slot option."
msgstr ""
"Класс basic-lock предоставляет спецификатор слота для слота с именем name и"
" параметр слота :initarg :name"

#: ./en/ch06.md:277
msgid ""
"The class simple-lock, which is built on basic-lock, inherits the name slot "
"and the :initarg :name slot option. It also provides a local slot specifier "
"for the name slot and the : initform slot option. This does not override any "
"of the inherited traits, but it adds a default initial value form to the "
"slot. It is often useful for a class to supply a default initial value form "
"for a slot that is inherited from a superclass."
msgstr ""
"Класс simple-lock, который построен на basic-lock, наследует слот name и"
" параметр слота :initarg :name. Он также предоставляет локальный спецификатор"
" слота для слота name и опции слота :initform. Это не переопределяет ни один"
" из унаследованных признаков, но добавляет в слот форму начального значения"
" по умолчанию. Для класса часто бывает полезно предоставить форму начального"
" значения по умолчанию для слота, который наследуется от суперкласса."

#: ./en/ch06.md:279
msgid ""
"Each instance of simple-lock has only one slot with the name name. The "
"characteristics of that slot come from all classes in the class precedence "
"list that supply a slot specifier for name. Instances of simple-lock receive "
"the following slot characteristics from these classes:"
msgstr ""
"Каждый экземпляр simple-lock имеет только один слот с именем name."
" Характеристики этого слота берутся из всех классов в списке приоритета"
" классов, которые предоставляют спецификатор слота для name. Экземпляры"
" simple-lock получают следующие характеристики слотов от этих классов:"

#: ./en/ch06.md:285
msgid ""
"| Slot Characteristics    | From Class  |\n"
"|-------------------------|-------------|\n"
"| the name slot itself    | basic-lock  |\n"
"| :initarg :name          | basic-lock  |\n"
"| :initform \"Simple Lock\" | simple-lock |"
msgstr ""
"| Характеристики слота    | Из Класса   |\n"
"|-------------------------|-------------|\n"
"| the name slot itself    | basic-lock  |\n"
"| :initarg :name          | basic-lock  |\n"
"| :initform \"Simple Lock\" | simple-lock |"

#: ./en/ch06.md:287
msgid "### Inheritance Behavior of Each Slot Option"
msgstr "### Поведение наследования каждого параметра слота"

#: ./en/ch06.md:289
msgid ""
"Here we describe how each slot option is inherited. The slot options have "
"different inheritance behavior. It is important to note that each slot "
"option is inherited independently of the other slot options. "
msgstr ""
"Здесь мы опишем, как наследуется каждая опция слота. Параметры слота имеют"
" различное поведение наследования. Важно отметить, что каждая опция слота"
" наследуется независимо от других опций слота."

#: ./en/ch06.md:291
msgid ""
"Each class in the class precedence list can affect the characteristics of a "
"slot by providing a slot specifier for the slot with that name. CLOS gathers "
"together the slot specifiers and ranks them from most specific to least "
"specific, based on the class precedence list. In other words, the precedence "
"of the slot specifier is controlled by the precedence of the class that "
"provides it."
msgstr ""
"Каждый класс в списке приоритетов классов может влиять на характеристики"
" слота, предоставляя спецификатор слота для слота с таким именем. CLOS"
" собирает воедино спецификаторы слотов и ранжирует их от наиболее специфичных"
" до наименее специфичных на основе списка приоритетов классов. Другими"
" словами, приоритет спецификатора слота определяется приоритетом класса,"
" который его предоставляет."

#: ./en/ch06.md:293
msgid "These rules determine the final set of characteristics of the slot: "
msgstr "Эти правила определяют окончательный набор характеристик слота:"

#: ./en/ch06.md:298
msgid ""
"\t    > :accessor, :reader, :writer                             Not "
"inherited \n"
"\t    >         These slot options create methods but do not affect the slot "
"itself. Although these\n"
"\t    >\t      slot options themselves are not inherited, the accessor "
"methods are inherited in the\n"
"\t    >\t      same way that any other method is inherited."
msgstr ""
"\t    > :accessor, :reader, :writer                             Not inherited"
" \n"
"\t    >           Эти параметры слота создают методы, но не влияют на сам"
" слот. \n"
"\t    >           Хотя сами по себе эти параметры слота не наследуются,"
" методы \n"
"\t    >           доступа наследуются таким же образом, как и любой другой"
" метод."

#: ./en/ch06.md:302
msgid ""
"\t    > :allocation                                            Inherited by "
"shadowing \n"
"\t    >         The allocation of a slot is controlled by the most specific "
"class that provides a\n"
"\t    >\t      slot specifier for the slot, whether or not the :allocation "
"slot option is provided."
msgstr ""
"\t       > :allocation                                            Inherited"
" by shadowing \n"
"\t       >              Выделение слота контролируется наиболее специфичным"
" классом, который \n"
"\t       >              предоставляет спецификатор слота для слота,"
" независимо от того, предусмотрена\n"
"\t       >              ли опция :allocation слота."

#: ./en/ch06.md:309
msgid ""
"\t    >         If the most specific slot specifier provides :allocation :"
"instance, or does not\n"
"\t    >\t      provide the :allocation slot option at all, this slot is a "
"local slot. If the most\n"
"\t    >\t      specific slot specifier provides :allocation :class, this is "
"a shared slot. (In this\n"
"\t    >\t      case, a new class slot is created for this class, which is "
"accessible to all its\n"
"\t    >\t      instances and to instances of any subclasses that do not "
"provide or inherit a more\n"
"\t    >\t      specific slot specifier for the slot.)"
msgstr ""
"Если наиболее конкретный спецификатор слота предоставляет :allocation"
" :instance или вообще не предоставляет опцию слота :allocation, этот слот"
" является локальным слотом. Если наиболее конкретный спецификатор слота"
" предоставляет :allocation :class, это общий слот. (В этом случае для этого"
" класса создается новый слот класса, который доступен для всех его"
" экземпляров и для экземпляров любых подклассов, которые не предоставляют или"
" не наследуют более конкретный спецификатор слота для слота.)"

#: ./en/ch06.md:314
msgid ""
"\t    > :documentation                                         Inherited by "
"shadowing \n"
"\t    >         The documentation of a slot is controlled by the most "
"specific slot specifier that\n"
"\t    >\t      provides the : documentation slot option for this slot. Any "
"less specific slot\n"
"\t    >\t      specifiers that provide the :documentation slot option are "
"ignored. "
msgstr ""
"\t     > :documentation                                         Inherited by"
" shadowing \n"
"\t     >            Документация слота контролируется наиболее специфичным"
" спецификатором слота, \n"
"\t     >            который предоставляет опцию :documentation slot для этого"
" слота. Любые менее \n"
"\t     >            специфические спецификаторы слотов, которые предоставляют"
" параметр слота \n"
"\t     >            :documentation, игнорируются."

#: ./en/ch06.md:319
msgid ""
"\t    > :initarg                                               Inherited by "
"union \n"
"\t    >         A slot can have more than one initarg. If several classes in "
"the class precedence\n"
"\t    >         list provide the :initarg slot option for the same slot, the "
"slot can be initialized\n"
"\t    >         by using any of the initargs."
msgstr ""
"\t     > :initarg                                               Inherited by"
" union \n"
"\t     >         Слот может иметь более одного инициализирующего параметра"
" :initarg. Если несколько классов\n"
"\t     >         в списке приоритета классов предоставляют параметр слота"
" :initarg для одного и того же слота,\n"
"\t     >         слот может быть инициализирован с помощью любого из initarg."

#: ./en/ch06.md:324
msgid ""
"\t    > :initform                                              Inherited by "
"shadowing \n"
"\t    >         The initform of a slot is controlled by the most specific "
"slot specifier that\n"
"\t    >         provides the :initform slot option for this slot. Any less "
"specific slot specifiers\n"
"\t    >         that provide an :initform are ignored."
msgstr ""
"\t    > :initform                                              Inherited by"
" shadowing \n"
"\t    >        Начальная форма(initform) слота управляется наиболее"
" специфичным спецификатором слота,\n"
"\t    >        который предоставляет опцию слота :initform для этого слота."
" Любые менее специфические\n"
"\t    >        спецификаторы слотов, которые предоставляют :initform,"
" игнорируются."

#: ./en/ch06.md:330
msgid ""
"\t    > :type                                                  Inherited by "
"\"and\" \n"
"\t    >         The type of a slot is controlled by all slot specifiers that "
"provide the :type slot\n"
"\t    >         option. The value of the slot must satisfy all the type "
"constraints provided. For\n"
"\t    >         example, if three classes in the class precedence list "
"specify the type as being\n"
"\t    >         number, rational, and integer, then the value of the slot "
"must satisfy"
msgstr ""
"\t    > :type                                                  Inherited by "
"\"and\" \n"
"\t    >       Тип слота определяется всеми спецификаторами слота, которые"
" предоставляют опцию слота\n"
"\t    >       :type. Значение слота должно удовлетворять всем предусмотренным"
" ограничениям типа. \n"
"\t    >       Например, если три класса в списке приоритета классов"
" определяют тип как number, rational и\n"
"\t    >       integer, то значение слота должно удовлетворять\n"
"\t    >      (typep value ' (and number rational integer)) \n"
"\t    >       Это подразумевает, что класс не может ослабить какие-либо"
" унаследованные ограничения типа\n"
"\t    >       для слота, но это может сделать ограничение типа более строгим."

#: ./en/ch06.md:332
msgid "\t    >              (typep value ' (and number rational integer))"
msgstr ""

#: ./en/ch06.md:335
msgid ""
"\t    >         This implies that a class cannot relax any inherited type "
"constraints on a slot,\n"
"\t    >         but it can make the type constraint more stringent."
msgstr ""
"\t    >        Это подразумевает, что класс не может ослабить какие-либо"
" унаследованные ограничения типа \n"
"\t    >        для слота, но это может сделать ограничение типа более строгим."

#: ./en/ch06.md:337
msgid "## 6.5 GUIDELINES ON USING INHERITANCE OF SLOT OPTIONS"
msgstr "## 6.5 РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ НАСЛЕДОВАНИЯ ПАРАМЕТРОВ СЛОТОВ"

#: ./en/ch06.md:339
msgid ""
"The inheritance behavior of slots and slot options probably sounds "
"complicated. Each slot option is inherited independently and by different "
"rules. The inheritance behavior of each slot option offers a feature that "
"can be useful in some contexts, but most programs do not need all these "
"features."
msgstr ""
"Поведение наследования слотов и опций слотов, вероятно, звучит сложно. Каждый"
" вариант слота наследуется независимо и по разным правилам. Поведение"
" наследования каждого параметра слота предлагает функцию, которая может быть"
" полезна в некоторых контекстах, но большинству программ не нужны все эти"
" функции."

#: ./en/ch06.md:341
msgid ""
"Almost all CLOS programs make use of the fact that slots are inherited. The "
"basic class provides a small number of slots that are appropriate for all "
"classes built on it, and the more specialized classes can include additional "
"slots. "
msgstr ""
"Почти все программы CLOS используют тот факт, что слоты наследуются. Базовый"
" класс предоставляет небольшое количество слотов, подходящих для всех"
" классов, построенных на его основе, а более специализированные классы могут"
" включать дополнительные слоты."

#: ./en/ch06.md:343
msgid ""
"Many CLOS programs take advantage of the inheritance of the :initform slot "
"option. In some cases it is appropriate to inherit a default initial value "
"from a superclass. In other cases, it is useful to override an inherited "
"default initial value."
msgstr ""
"Многие программы CLOS используют преимущества наследования опции слота"
" :initform. В некоторых случаях целесообразно наследовать начальное значение"
" по умолчанию от суперкласса. В других случаях полезно переопределить"
" унаследованное начальное значение по умолчанию."

#: ./en/ch06.md:345
msgid ""
"Many CLOS programs also take advantage of the inheritance of the :initarg "
"slot option. Usually, the class that provides the slot also provides the "
"initarg, if the slot is intended to be initialized. Occasionally it is "
"useful for a subclass to provide the : initarg slot option to give the slot "
"another initarg."
msgstr ""
"Многие программы CLOS также используют преимущества наследования опции слота"
" :initarg. Обычно класс, предоставляющий слот, также предоставляет initarg,"
" если слот предназначен для инициализации. Иногда подклассу полезно"
" предоставить опцию слота :initarg, чтобы предоставить слоту другой"
" инициализирующий параметр."

#: ./en/ch06.md:347
msgid ""
"When :type is used, typically the class that provides the slot also "
"specifies the slot's type. Subclasses generally inherit the type without a "
"need for constraining it further."
msgstr ""
"Когда используется :type, обычно класс, предоставляющий слот, также"
" определяет тип слота. Подклассы обычно наследуют тип без необходимости его"
" дальнейшего ограничения."

#: ./en/ch06.md:349
msgid ""
"Generally, subclasses do not choose to override the allocation of a slot. It "
"is unusual for a class to change the allocation of a slot from :class to :"
"instance or vice versa, because the semantics of a shared slot versus a "
"local slot are so different. The most common example of overriding the "
"allocation occurs when one class specifies a :class slot, and its subclass "
"chooses not to share that particular slot, but rather to create a new :class "
"slot to be shared among the instances of the subclass (and instances of its "
"subclasses, unless they also create a new :class slot). "
msgstr ""
"Как правило, подклассы не выбирают переопределение выделения слота. Для"
" класса необычно изменять распределение слота с :class на :instance или"
" наоборот, потому что семантика общего слота по сравнению с локальным слотом"
" сильно отличается. Наиболее распространенный пример переопределения"
" распределения возникает, когда один класс указывает слот :class, а его"
" подкласс выбирает не использовать этот конкретный слот, а скорее создать"
" новый слот :class, который будет использоваться совместно экземплярами"
" подкласса (и экземплярами его подклассов, если они также не создают новый"
" слот :class)."
