#. extracted from ./en/ch02.md
# bear <NuINu>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-24 17:39+0300\n"
"PO-Revision-Date: 2022-09-24 21:46+0300\n"
"Last-Translator: bear <NuINu>\n"
"Language-Team: English <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 21.12.1\n"
"Language: en_US\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ./en/ch02.md:2
msgid "# Elements of CLOS Programs"
msgstr "# Элементы программ CLOS"

#: ./en/ch02.md:5
msgid ""
"The elements of CLOS programs are classes, instances, generic functions, and "
"methods. None of these elements can be considered in isolation, because each "
"one's purpose is to interact with the others in useful and predictable ways. "
"We begin by presenting the most important aspects of these elements and "
"examining the relationships among them. \n"
"We then describe how CLOS is integrated with Common Lisp, focusing on the "
"common ground between classes and types. "
msgstr ""
"Элементами программ CLOS являются классы, экземпляры,"
" универсальные/обобщенные функции и методы. Ни один из этих элементов нельзя"
" рассматривать изолированно, поскольку цель каждого из них -"
" взаимодействовать с другими элементами полезными и предсказуемыми способами."
" Мы начнем с представления наиболее важных аспектов этих элементов и изучения"
" взаимосвязей между ними."
"Затем мы опишем, как CLOS интегрируется с Common Lisp, сосредоточив внимание"
" на общих чертах между классами и типами."

#: ./en/ch02.md:7
msgid "## 2.1 CLASSES AND INSTANCES "
msgstr "## 2.1 КЛАССЫ(CLASSES) И ЭКЗЕМПЛЯРЫ(INSTANCES)"

#: ./en/ch02.md:9
msgid ""
"The first step in writing a CLOS program is to define a new type of data "
"structure called a class. A class is a Common Lisp type. Each individual "
"object of that type is an instance of the class. Each instance of a given "
"class has the same structure, behavior, and type as do the other instances "
"of the class."
msgstr ""
"Первым шагом в написании программы CLOS является определение нового типа"
" структуры данных, называемой классом. Класс(class) - это тип Common Lisp."
" Каждый отдельный объект этого типа является экземпляром(instance) класса."
" Каждый экземпляр данного класса имеет ту же структуру, поведение и тип, что"
" и другие экземпляры класса."

#: ./en/ch02.md:11
msgid ""
"We might define a class named month, which would have instances representing "
"January, February, March, and so on. Or we could define a class named window "
"to represent windows that appear on the screen of a display terminal. When "
"we need to create a new window, we make another instance of that class. "
"Figure 2.1 shows a class with three instances."
msgstr ""
"Мы могли бы определить класс с именем month, который будет иметь экземпляры,"
" представляющие январь, февраль, март и так далее. Или мы могли бы определить"
" класс с именем window для представления окон, которые появляются на экране"
" дисплейного терминала. Когда нам нужно создать новое окно, мы создаем еще"
" один экземпляр этого класса. На рисунке 2.1 показан класс с тремя"
" экземплярами."

#: ./en/ch02.md:14
msgid ""
"![Figure 2.1: Instances of a class.](images/f02-01.jpg)\n"
"**Figure 2.1: Instances of a class.**"
msgstr ""
"![Figure 2.1: Экземпляры классов.](images/f02-01.jpg)\n"
"**Figure 2.1: Экземпляры классов.**"

#: ./en/ch02.md:16
msgid ""
"We can query an instance for its type with the usual Common Lisp type "
"functions. Although all instances are recognizably of the same type, each "
"one has a separate identity. This is compatible with the Common Lisp model, "
"in which two objects can have the same type and the same structure (such as "
"two arrays with the same contents), yet be two different objects, each with "
"its own identity."
msgstr ""
"Мы можем спросить экземпляр о его типе с помощью обычных функций type Common"
" Lisp. Хотя все экземпляры, по-видимому, относятся к одному и тому же типу,"
" каждый из них имеет отдельный идентификатор. Это совместимо с моделью Common"
" Lisp, в которой два объекта могут иметь один и тот же тип и одну и ту же"
" структуру (например, два массива с одинаковым содержимым), но при этом быть"
" двумя разными объектами, каждый со своим собственным идентификатором."

#: ./en/ch02.md:18
msgid "## 2.2 SLOTS "
msgstr "## 2.2 СЛОТЫ(SLOTS)"

#: ./en/ch02.md:20
msgid ""
"We have said that all instances of a class have the same structure. That "
"structure is in the form of slots. A slot has a name and a value. A slot's "
"name describes the characteristic it is modeling, and the value describes "
"the slot's state at a given time. This state information can be read and "
"written by *accessors*."
msgstr ""
"Мы уже говорили, что все экземпляры класса имеют одинаковую структуру. Эта"
" структура выполнена в виде слотов. Слот имеет имя и значение. Имя слота"
" описывает характеристику, которую он моделирует, а значение описывает"
" состояние слота в данный момент времени. Эта информация о состоянии может"
" быть считана и записана с помощью методов доступа(*accessors*)."

#: ./en/ch02.md:22
msgid ""
"CLOS offers two kinds of slots: *local slots* and *shared slots*. For local "
"slots, each instance holds its own value for the slot. For shared slots, the "
"instances share a single value for the slot. Since local slots are used more "
"frequently, we concentrate on them here; we discuss shared slots in \"Local "
"and Shared Slots,\" page 66."
msgstr ""
"CLOS предлагает два вида слотов: *локальные слоты*( *local slots*) и"
" *общие/разделяемые слоты*(*shared slots*). Для локальных слотов каждый"
" экземпляр содержит свое собственное значение для слота. Для общих слотов все"
" экземпляры совместно используют одно значение для слота. Поскольку локальные"
" слоты используются чаще, здесь мы сосредоточимся на них; мы обсуждаем общие"
" слоты в разделе \"Локальные и Общие(совместно используемые) слоты\", стр. 66."

#: ./en/ch02.md:24
msgid ""
"The class named window might have local slots named x-position, y-position, "
"width, and height. This state information describes, for any given window, "
"that window's size and its position. Figure 2.2 shows the names and values "
"of the slots of two instances of the window class."
msgstr ""
"Класс с именем window может иметь локальные слоты с именами x-position,"
" y-position, width и height. Эта информация о состоянии описывает для любого"
" данного окна размер этого окна и его положение. На рис. 2.2 показаны имена и"
" значения слотов двух экземпляров класса window."

#: ./en/ch02.md:27
msgid ""
"![Figure 2.2: State information stored in local slots.](images/f02-02.jpg)\n"
"**Figure 2.2: State information stored in local slots.**"
msgstr ""
"![Рисунок 2.2: Информация о состоянии, хранящаяся в локальных"
" слотах.](images/f02-02.jpg)"
"**Рисунок 2.2: Информация о состоянии, хранящаяся в локальных слотах.**"

#: ./en/ch02.md:29
msgid ""
"Notice that two instances of the same class have the same set of named "
"slots. In other words, they have the same structure. Each instance, however, "
"maintains its own values for its local slots; that is, each instance has its "
"own state."
msgstr ""
"Обратите внимание, что два экземпляра одного и того же класса имеют один и"
" тот же набор именованных слотов. Другими словами, они имеют одинаковую"
" структуру. Однако каждый экземпляр поддерживает свои собственные значения"
" для своих локальных слотов; то есть каждый экземпляр имеет свое собственное"
" состояние."

#: ./en/ch02.md:31
msgid "## 2.3 SUPERCLASSES "
msgstr "## 2.3 СУПЕРКЛАССЫ( SUPERCLASSES)"

#: ./en/ch02.md:33
msgid ""
"CLOS enables you to build a class from other classes; the component classes "
"are called the new class's superclasses. The new class inherits both "
"structure (slots) and behavior from its superclasses."
msgstr ""
"CLOS позволяет создавать класс из других классов; классы компонентов"
" называются суперклассами нового класса. Новый класс наследует как структуру"
" (слоты), так и поведение от своих суперклассов."

#: ./en/ch02.md:35
msgid ""
"This style of programming is well suited to the task of modeling several "
"kinds of objects that are related to one another. For example, we might want "
"to have different kinds of windows. In addition to plain windows, we might "
"need windows with labels and windows with borders.(1) The new kinds of "
"windows are similar to the existing window class, but they have extra "
"features. Figure 2.3 shows two new classes, window-with-label and window-"
"with-border, which are built on the existing class, window. "
msgstr ""
"Этот стиль программирования хорошо подходит для задачи моделирования"
" нескольких видов объектов, связанных друг с другом. Например, мы могли бы"
" захотеть иметь разные типы окон. В дополнение к обычным окнам нам могут"
" понадобиться окна с надписями и окна с рамками.(1) Новые типы окон"
" аналогичны существующему классу окон, но у них есть дополнительные функции."
" На рисунке 2.3 показаны два новых класса, window-with-label и"
" window-with-border, которые построены на основе существующего класса window."

#: ./en/ch02.md:38
msgid ""
"![Figure 2.3: Two new classes built on the window class.](images/f02-03.jpg)"
"\n"
"**Figure 2.3: Two new classes built on the window class.**"
msgstr ""
"![Рисунок 2.3: Два новых класса, построенных на основе класса"
" window.](images/f02-03.jpg)"
"**Figure 2.3: Рисунок 2.3: Два новых класса, построенных на основе класса"
" window.**"

#: ./en/ch02.md:40
msgid ""
"To build a class from components, you include a list of classes in the "
"definition of the class. These are called the direct superclasses of the new "
"class. In Fig. 2.3, each arrow points from a class to a direct superclass of "
"the class. In fact, a class is built not only from its direct superclasses, "
"but from each of their direct superclasses, and so on. The superclasses of a "
"class are all its component classes. The term subclass is the inverse of "
"superclass. Here we apply this terminology to the window classes: "
msgstr ""
"Чтобы создать класс из компонентов(других классов), вы включаете список"
" классов в определение класса. Они называются прямыми суперклассами нового"
" класса. На рис. 2.3 каждая стрелка указывает от класса к прямому суперклассу"
" этого класса. На самом деле класс строится не только из его прямых"
" суперклассов, но и из прямых суперклассов из каждого их компонента и так"
" далее. Суперклассы класса - это все его составные классы. Термин"
" \"подкласс\" является обратным термину \"суперкласс\". Здесь мы применяем"
" эту терминологию к оконным классам:"

#: ./en/ch02.md:43
msgid ""
"> (1) example of windows, windows with labels, and windows with borders, is "
"adapted from the paper \"Flavors: A non-hierarchical approach to object-"
"oriented programming,\" Symbolics, Inc., 1982, with permission from the "
"author, Howard I. Cannon. "
msgstr ""
"\t\t (1) пример окон, окон с метками(label) и окон с границами(border),"
" адаптирован из статьи \"Вкусы: неиерархический подход к"
" объектно-ориентированному программированию\", Symbolics, Inc., 1982, с"
" разрешения автора, Говарда И. Кэннона."

#: ./en/ch02.md:49
msgid ""
"\t> window is a direct superclass of window-with-border. \n"
"\t> window is a direct superclass of window-with-label. \n"
"\t> window-with-border is a direct subclass of window, \n"
"\t> window-with-label is a direct subclass of window. "
msgstr ""
"\t\t window - это прямой суперкласс window-with-border.\n"
"\t\t window - это прямой суперкласс window-with-label.\n"
"\n"
"\t\t window-with-border является прямым подклассом window,\n"
"\t\t window-with-label является прямым подклассом window.\n"

#: ./en/ch02.md:51
msgid ""
"Figure 2.4 shows an instance of window-with-label and an instance of window-"
"with-border. The class window-with-label inherits the four slots of its "
"superclass window and also has a slot named label. Similarly, the class "
"window-with-border inherits the slots of window and also has a slot named "
"border-width. Thus, the basic structure of a window is defined only once (by "
"the class window) and is inherited by many kinds of windows. "
msgstr ""
"На рисунке 2.4 показан экземпляр window-with-label и экземпляр"
" window-with-border. Класс window-with-label наследует четыре слота своего"
" суперкласса window, а также имеет слот с именем label. Аналогично, класс"
" window-with-border наследует слоты window, а также имеет слот с именем"
" border-width. Таким образом, базовая структура окна определяется только один"
" раз (классом window) и наследуется многими типами окон."

#: ./en/ch02.md:54
msgid ""
"![Figure 2.4: Slots inherited from superclasses.](images/f02-04.jpg)\n"
"**Figure 2.4: Slots inherited from superclasses.**"
msgstr ""
"![Рисунок 2.4: Слоты, унаследованные от суперклассов.](images/f02-04.jpg )"
"**Рисунок 2.4: Слоты, унаследованные от суперклассов.**"

#: ./en/ch02.md:56
msgid ""
"The order in which slots are stored in memory is implementation dependent, "
"and is not normally visible to the programmer."
msgstr ""
"Порядок, в котором слоты хранятся в памяти, зависит от реализации и обычно не"
" виден программисту."

#: ./en/ch02.md:58
msgid "## 2.4 GENERIC FUNCTIONS "
msgstr "## 2.4 ОБОБЩЕННЫЕ(GENERIC) ФУНКЦИИ"

#: ./en/ch02.md:60
msgid ""
"Programs and users operate on instances by using generic functions. To the "
"caller, a generic function appears exactly like an ordinary Lisp function; "
"the function-calling syntax is identical. When you call a function, you do "
"not need to know whether the function is defined as an ordinary function or "
"as a generic function. "
msgstr ""
"Программы и пользователи работают с экземплярами, используя обобщенные"
" функции. Для вызывающей стороны обобщенная(универсальная) функция выглядит"
" точно так же, как обычная функция Lisp; синтаксис вызова функции идентичен."
" Когда вы вызываете функцию, вам не нужно знать, определена ли функция как"
" обычная функция или как обобщенная функция."

#: ./en/ch02.md:62
msgid ""
"Conceptually, a generic function performs a high-level operation, such as "
"\"refresh a window.\" For different kinds of windows, this operation might "
"require different work; whereas a plain window is simply cleared, a window "
"with a border must be cleared and then have its border redrawn. The high-"
"level goal \"refresh a window\" must be implemented differently for "
"different kinds of windows. In other words, each kind of window needs an "
"implementation that is appropriate to it. "
msgstr ""
"Концептуально обобщенная функция выполняет высокоуровневую операцию, такую"
" как \"обновить(refresh) окно\". Для разных типов окон эта операция может"
" потребовать разной работы; в то время как обычное окно просто очищается,"
" окно с границей должно быть очищено, а затем его граница(border)"
" перерисована. Цель высокого уровня \"обновить(refresh) окно\" должна быть"
" реализована по-разному для разных типов окон. Другими словами, каждый тип"
" окна нуждается в соответствующей ему реализации."

#: ./en/ch02.md:64
msgid ""
"When we compare the workings of ordinary functions and generic functions, we "
"find semantic differences. An ordinary Lisp function definition specifies "
"both the interface and the implementation of the operation it performs. As "
"shown in Fig. 2.5, when an ordinary Lisp function is called, the Lisp system "
"locates and executes the single body of code that implements that function."
msgstr ""
"Когда мы сравниваем работу обычных функций и обобщенных функций, мы"
" обнаруживаем семантические различия. Обычное определение функции Lisp"
" определяет как интерфейс, так и реализацию операции, которую она выполняет."
" Как показано на рис. 2.5, когда вызывается обычная функция Lisp, система"
" Lisp находит и выполняет единственный фрагмент кода, который реализует эту"
" функцию."

#: ./en/ch02.md:67
msgid ""
"![Figure 2.5: Ordinary Lisp function.](images/f02-05.jpg)\n"
"**Figure 2.5: Ordinary Lisp function.**"
msgstr ""
"![Рисунок 2.5: Обычная функция Lisp.](images/f02-05.jpg )"
"**Рисунок 2.5: Обычная функция Lisp.**"

#: ./en/ch02.md:69
msgid ""
"A generic function specifies only the interface. The implementation of a "
"generic function does not exist in one place; it is distributed across a set "
"of methods. Whereas the implementation of an ordinary function does not vary "
"from call to call, the implementation of a generic function does vary, "
"depending on the classes of its arguments."
msgstr ""
"Обобщенная функция определяет только интерфейс. Реализация обобщенной функции"
" не существует в одном месте; она распределена по набору методов. В то время"
" как реализация обычной функции не меняется от вызова к вызову, реализация"
" обобщенной функции действительно меняется в зависимости от классов ее"
" аргументов."

#: ./en/ch02.md:71
msgid ""
"Consider the task of refreshing the three kinds of windows. We can define a "
"generic function called refresh, which can be used to refresh any kind of "
"window. The interface is the same, regardless of the class of window. "
"However, each of the three classes of window requires a slightly different "
"implementation of refresh. Instances of window are simply cleared; the "
"region of the screen covered by the window is made empty. For an instance of "
"window-with-border, the window is cleared and the border is redrawn. "
"Similarly, for an instance of window-with-label, the window is cleared and "
"the label is redrawn. Figure 2.6 shows that a generic function can have "
"several separate implementations."
msgstr ""
"Рассмотрим задачу обновления трех типов окон. Мы можем определить обобщенную"
" функцию под названием refresh, которую можно использовать для обновления"
" любого типа окна. Интерфейс один и тот же, независимо от класса окна. Однако"
" для каждого из трех классов window требуется несколько иная реализация"
" refresh(обновления). Экземпляры window просто очищаются; область экрана,"
" покрытая окном, становится пустой. Для экземпляра window-with-border окно"
" очищается, а граница(border) перерисовывается. Аналогично, для экземпляра"
" window-with-label окно очищается, а метка(label) перерисовывается. На рис."
" 2.6 показано, что обобщенная функция может иметь несколько отдельных"
" реализаций."

#: ./en/ch02.md:74
msgid ""
"![Figure 2.6: Generic function.](images/f02-06.jpg)\n"
"**Figure 2.6: Generic function.**"
msgstr ""
"![Рисунок 2.6: Обобщенная функция.](images/f02-06.jpg )"
"**Рисунок 2.6: Обобщенная функция.**"

#: ./en/ch02.md:76
msgid ""
"When refresh is called, CLOS determines the class of the argument and "
"chooses the appropriate implementation for that class. Each implementation "
"might consist of one method or several methods. The procedure for "
"determining which methods to call and then calling them is called generic "
"dispatch. It happens automatically whenever a generic  function is called."
msgstr ""
"Когда вызывается refresh, CLOS определяет класс аргумента и выбирает"
" соответствующую реализацию для этого класса. Каждая реализация может"
" состоять из одного метода или нескольких методов. Процедура определения"
" того, какие методы следует вызывать, а затем их вызова называется generic"
" dispatch. Это происходит автоматически всякий раз, когда вызывается"
" обобщенная функция."

#: ./en/ch02.md:78
msgid ""
"In the refresh example, the generic dispatch uses only one argument (the "
"window) to choose the implementation. In \"Multi-Methods,\" page 75, we "
"shall show that the CLOS generic dispatch can use more than  one argument to "
"choose the implementation."
msgstr ""
"В примере refresh(обновления) generic dispatch(обобщенная рассылка)"
" использует только один аргумент (окно/window) для выбора реализации. В"
" разделе \"Мультиметоды\", стр. 75, мы покажем, что generic"
" dispatch(универсальная отправка) CLOS может использовать более одного"
" аргумента для выбора реализации."

#: ./en/ch02.md:80
msgid "## 2.5 METHODS "
msgstr "## 2.5 МЕТОДЫ(METHODS)"

#: ./en/ch02.md:82
msgid ""
"Methods are the underlying implementation of generic functions. Like "
"ordinary Lisp functions, methods take arguments, perform computation, "
"perhaps create side effects such as producing output, and return values. "
"Unlike ordinary Lisp functions, methods are not called directly; they are "
"called only by the generic dispatch procedure."
msgstr ""
"Методы являются основой реализации обобщенных функций. Подобно обычным"
" функциям Лиспа, методы принимают аргументы, выполняют вычисления и,"
" возможно, создают побочные эффекты, такие как вывод и возвращают значения. В"
" отличие от обычных функций Лиспа, методы не вызываются напрямую; они"
" вызываются только процедурой generic dispatch(обобщённой отправки)."

#: ./en/ch02.md:84
msgid ""
"A programmer attaches a method to the generic function the method "
"implements, and to one or more classes by stating in the method's lambda-"
"list the classes of arguments the method handles. The method is called only "
"if the arguments to the generic function are of the appropriate classes."
msgstr ""
"Программист прикрепляет метод к обобщенной функции, которую реализует метод,"
" к одному или нескольким классам, указывая в лямбда-списке метода классы"
" аргументов, которые обрабатывает данный метод. Метод вызывается только в том"
" случае, если аргументы обобщенной функции относятся к соответствующим"
" классам."

#: ./en/ch02.md:86
msgid ""
"For example, Fig. 2.7 shows that the refresh generic function might have "
"three methods attached to it, one for the class window, one for window-with-"
"label, and one for window-with-border."
msgstr ""
"Например, на рис. 2.7 показано, что к обобщенной функции refresh могут быть"
" присоединены три метода: один для класса window, один для "
" window-with-label(окна-с-меткой) и один для "
" window-with-border(окна-с-границей)."

#: ./en/ch02.md:89
msgid ""
"![Figure 2.7: Methods for refresh.](images/f02-07.jpg)\n"
"**Figure 2.7: Methods for refresh.**"
msgstr ""
"![Рисунок 2.7: Методы для refresh.](images/f02-07.jpg)"
"**Рисунок 2.7: Методы для refresh.**"

#: ./en/ch02.md:91
msgid ""
"We have said that all instances of a class have the same behavior. Methods "
"implement the behavior of instances. A class inherits methods from its "
"superclasses. For example, the classes window-with-border and window-with-"
"label inherit methods from the class window. "
msgstr ""
"Мы сказали, что все экземпляры класса ведут себя одинаково. Методы реализуют"
" поведение экземпляров. Класс наследует методы своих суперклассов. Например,"
" классы window-with-border и window-with-label наследуют методы класса window."

#: ./en/ch02.md:93
msgid ""
"There is not necessarily a one-to-one correspondence between an "
"implementation for a set of arguments and a single method. When a generic "
"function is called, the arguments may select an implementation consisting of "
"more than one method."
msgstr ""
"Не обязательно однозначное соответствие между реализацией набора аргументов и"
" одним методом. Когда вызывается обобщенная функция, аргументы могут выбирать"
" реализацию, состоящую из более чем одного метода."

#: ./en/ch02.md:95
msgid "## 2.6 METHOD ROLES "
msgstr "## 2.6 РОЛИ МЕТОДОВ"

#: ./en/ch02.md:97
msgid ""
"CLOS makes it possible to split up the work of a generic function (for some "
"given arguments) into several methods. This capability stems from the facts "
"that methods are inherited, and that methods can have different roles. The "
"role of a method states what part it plays in the implementation of the "
"generic function."
msgstr ""
"CLOS позволяет разделить работу обобщенной функции (для некоторых заданных"
" аргументов) на несколько методов. Эта возможность связана с тем фактом, что"
" методы наследуются и что методы могут иметь разные роли. Роль метода"
" указывает, какую роль он играет в реализации обобщенной функции."

#: ./en/ch02.md:99
msgid ""
"A primary method performs the bulk of the work of a generic function. "
"Sometimes, one primary method does all the work of the generic function for "
"a particular set of arguments. In other cases, the primary method can be "
"assisted by auxiliary methods, such as before-methods and after-methods. "
"Before-methods are called before the primary method; they can do set-up work "
"in advance of the other methods. After-methods are called after the primary "
"method; they can do clean-up work or any other computation. (CLOS also "
"supports around-methods, which we discuss in \"Around-Methods,\" page 102.)"
msgstr ""
"Основной(primary) метод выполняет основную часть работы обобщенной функции."
" Иногда один основной метод выполняет всю работу обобщеннойй функции для"
" определенного набора аргументов. В других случаях основному методу могут"
" помогать вспомогательные методы, такие как before-(до-) методы и"
" after-(после-) методы. Before-методы вызываются перед основным методом; они"
" могут выполнить настройку раньше других методов. After- методы вызываются"
" после основного метода; они могут выполнять очистку или любые другие"
" вычисления. (CLOS также поддерживает  around-методы, которые мы обсуждаем в"
" разделе «Around-Методы», стр. 102.)"

#: ./en/ch02.md:101
msgid ""
"The primary method returns the values of the generic function. Before-"
"methods and after-methods are intended for side effects only; they are not "
"called for value."
msgstr ""
"Основной метод возвращает значения обобщенной функции. Методы «до»(before) и"
" «после»(after) предназначены только для получения узких побочных эффектов;"
" они не вызываются для полученя значений."

#: ./en/ch02.md:103
msgid ""
"Given that classes inherit methods, this scheme allows for a division of "
"labor among a class and its superclasses. For example, one class might "
"provide the primary method that performs the bulk of the work, while other "
"classes provide auxiliary methods that do additional work."
msgstr ""
"Учитывая, что классы наследуют методы, эта схема позволяет разделить работу"
" между классом и его суперклассами. Например, один класс может предоставлять"
" основной метод, выполняющий основную часть работы, в то время как другие"
" классы предоставляют вспомогательные методы, выполняющие дополнительную"
" работу."

#: ./en/ch02.md:105
msgid ""
"The implementation of refresh can take good advantage of this model. All "
"three kinds of windows must be cleared. Thus, we can define a primary method "
"for window that performs the clearing. For instances of window, this method "
"is sufficient."
msgstr ""
"Реализация refresh(обновления) может извлечь выгоду из этой модели. Все три"
" вида окон должны быть очищены. Таким образом, мы можем определить первичный"
" метод для окна, выполняющего очистку. Для экземпляров window этого метода"
" достаточно."

#: ./en/ch02.md:107
msgid ""
"That primary method for refresh is inherited by the classes window-with-"
"border and window-with-label. This is desirable, because windows of both "
"classes need to be cleared before anything else is done. An instance of "
"window-with-border must then have its border redrawn; this can be done with "
"an after-method attached to the class window-with-border. Thus, the window-"
"with-border class provides an auxiliary method to perform its specialized "
"behavior, but it inherits the primary method from its superclass. Similarly, "
"we need to define an after-method attached to the class window-with-label to "
"redraw the label. "
msgstr ""
"Этот основной метод для refresh наследуется классами window-with-border и"
" window-with-label. Это желательно, потому что окна обоих классов должны быть"
" очищены, прежде чем делать что-либо еще. Граница экземпляра"
" window-with-border должна быть перерисована; это можно сделать с помощью"
" метода after, присоединенного к классу window-with-border. Таким образом,"
" класс window-with-border(окна с границей) предоставляет вспомогательный"
" метод для выполнения своего специализированного поведения, но наследует"
" основной метод от своего суперкласса. Точно так же нам нужно определить"
" метод after, прикрепленный к классу window-with-label, чтобы перерисовывать"
" метку."

#: ./en/ch02.md:110
msgid ""
"Figure 2.8 shows that each method contains Lisp code to perform some task, "
"and that each method has a role. The implementation of refresh is "
"distributed among three different methods. The primary method attached to "
"the window class does the shared part of the work, \n"
"and that method is inherited by the two classes built on window. When an "
"instance of window is refreshed, CLOS calls only one method—the primary "
"method attached to the window class."
msgstr ""
"На рис. 2.8 показано, что каждый метод содержит код Лиспа для выполнения"
" некоторой задачи и что у каждого метода есть роль. Реализация обновления"
" распределена между тремя различными методами. Основной метод, прикрепленный"
" к классу окна, выполняет общую часть работы, и этот метод наследуется двумя"
" классами, созданными на основе окна. Когда экземпляр окна обновляется, CLOS"
" вызывает только один метод — основной метод, прикрепленный к классу окна."

#: ./en/ch02.md:114
msgid ""
"![Figure 2.8: Roles of the refresh methods.](images/f02-08.jpg)\n"
"**Figure 2.8: Roles of the refresh methods.**"
msgstr ""
"![Рисунок 2.8: Роли методов refresh.](images/f02-08.jpg)"
"**Рисунок 2.8: Роли методов refresh.**"

#: ./en/ch02.md:116
msgid ""
"Figure 2.9 shows an inside view of the implementation chosen when the "
"argument to refresh is an instance of window-with-label."
msgstr ""
"На рис. 2.9 показан внутренний вид реализации, выбранной, когда аргументом"
" для refresh является экземпляр window-with-label."

#: ./en/ch02.md:119
msgid ""
"![Figure 2.9: Sample generic dispatch of refresh.](images/f02-09.jpg)\n"
"**Figure 2.9: Sample generic dispatch of refresh.**"
msgstr ""
"![Рисунок 2.9: Пример общей отправки(generic dispatch)"
" refresh.](images/f02-09.jpg )"
"**Рисунок 2.9: Пример общей отправки(generic dispatch) refresh.**"

#: ./en/ch02.md:121
msgid ""
"In Fig. 2.9, CLOS chooses an implementation consisting of two methods: the "
"primary method attached to the window class, and the after-method attached "
"to the window-with-label class. "
msgstr ""
"На рис. 2.9 CLOS выбирает реализацию, состоящую из двух методов: основного"
" метода, присоединенного к классу window, и after- метода, присоединенного к"
" классу window-with-label."

#: ./en/ch02.md:123
msgid "## 2.7 THE CONTROLLER OF INHERITANCE "
msgstr "## 2.7 КОНТРОЛЕР НАСЛЕДОВАНИЯ(THE CONTROLLER OF INHERITANCE)"

#: ./en/ch02.md:125
msgid ""
"Inheritance is the sharing of characteristics and behavior among a set of "
"classes. Slots are one example of inherited characteristics. Class "
"definitions can specify other characteristics, such as default values for "
"slots; these are inherited as well. Behavior is represented by methods, "
"which are inherited. A class inherits from all its superclasses."
msgstr ""
"Наследование - это совместное использование характеристик и поведения между"
" набором(множеством) классов. Слоты - это один из примеров унаследованных"
" характеристик. Определения классов могут указывать другие характеристики,"
" такие как значения по умолчанию для слотов; они также наследуются. Поведение"
" представленое методами, которые наследуются. Класс наследуется от всех своих"
" суперклассов."

#: ./en/ch02.md:127
msgid ""
"When you put together a program from a set of classes, it is essential that "
"the inheritance occur in an orderly and predictable way. For example, "
"consider what happens if two superclasses offer competing characteristics, "
"such as methods for the same generic function. How is such a conflict "
"handled?"
msgstr ""
"Когда вы собираете программу из набора классов, важно, чтобы наследование"
" происходило упорядоченным и предсказуемым образом. Например, рассмотрим, что"
" произойдет, если два суперкласса предлагают конкурирующие характеристики,"
" такие как методы для одной и той же обобщенной функции. Как решается такой"
" конфликт?"

#: ./en/ch02.md:129
msgid ""
"This concept has an analogy in human genetics: A baby might have a gene for "
"brown eyes and a gene for blue eyes. The baby's eye color is determined by "
"the dominance of the brown-eye gene over the blue-eyegene. When two classes "
"offer competing traits, CLOS resolves the conflict by checking which class "
"has precedence over the other class."
msgstr ""
"Эта концепция имеет аналогию в генетике человека: у ребенка может быть ген"
" карих глаз и ген голубых глаз. Цвет глаз ребенка определяется доминированием"
" гена карих глаз над геном голубых глаз. Когда два класса предлагают"
" конкурирующие черты, CLOS разрешает конфликт, проверяя, какой класс имеет"
" приоритет над другим классом."

#: ./en/ch02.md:131
msgid ""
"When you design an organization of classes, you are specifying the "
"precedence relationships among the classes. CLOS computes a class precedence "
"list based on your organization. The class precedence list governs how "
"methods, slots, and other characteristics are inherited."
msgstr ""
"Когда вы разрабатываете организацию классов, вы определяете отношения"
" приоритета между классами. CLOS вычисляет список приоритетов классов на"
" основе вашей организации. Список приоритетов классов определяет, как"
" наследуются методы, слоты и другие характеристики."

#: ./en/ch02.md:133
msgid ""
"Each class has a class precedence list, which includes the class itself and "
"all its superclasses. The classes in a class precedence list are ordered "
"from most specific to least specific. When one class is more specific than "
"another in this list, it has precedence (or dominance) over the other class. "
"Thus, if the two classes offer competing traits, the more specific class "
"takes precedence over the less specific class. The class precedence list is "
"discussed in detail later on, in \"The Class Precedence List,\" page 118."
msgstr ""
"Каждый класс имеет список приоритетов классов(class precedence list), который"
" включает в себя сам класс и все его суперклассы. Классы в списке приоритета"
" классов упорядочены от наиболее специфичных к наименее специфичным. Когда"
" один класс более специфичен, чем другой в этом списке, он имеет приоритет"
" (или доминирование) над другим классом. Таким образом, если два класса"
" обладают конкурирующими признаками, более специфичный класс имеет приоритет"
" над менее специфичным классом. Список приоритетов классов подробно"
" обсуждается позже, в разделе \"Список приоритетов классов\", стр. 118."

#: ./en/ch02.md:135
msgid "## 2.8 SUMMARY OF THE CLOS MODEL"
msgstr "## 2.8 КРАТКОЕ ОПИСАНИЕ МОДЕЛИ CLOS"

#: ./en/ch02.md:137
msgid ""
"Real-world objects are modeled by Lisp objects, which are called instances. "
"You manipulate these objects using generic functions. When generic functions "
"are called, the generic dispatch automatically arranges for the appropriate "
"implementation to be invoked, based on the classes of the arguments. "
msgstr ""
"Объекты реального мира моделируются объектами Lisp, которые называются"
" экземплярами. Вы управляете этими объектами с помощью обобщенных функций."
" Когда вызываются обобщенные функции, универсальная отправка(generic"
" dispatch) автоматически организует вызов соответствующей реализации на"
" основе классов аргументов."

#: ./en/ch02.md:139
msgid ""
"The structure of an instance is dictated by its class. Each instance "
"maintains a set of named slots, in which it stores state information. All "
"instances of a given class have the same structure and the same behavior. "
"The implementation of a generic function on an instance consists of one or "
"more methods, which are selected according to the class."
msgstr ""
"Структура экземпляра определяется его классом. Каждый экземпляр поддерживает"
" набор именованных слотов, в которых он хранит информацию о состоянии. Все"
" экземпляры данного класса имеют одинаковую структуру и одинаковое поведение."
" Реализация обобщенной функции в экземпляре состоит из одного или нескольких"
" методов, которые выбираются в соответствии с классом."

#: ./en/ch02.md:141
msgid ""
"You can build classes on other classes in order to inherit structure and "
"behavior; this is the key aspect of modular design. A class inherits both "
"slots and methods from its superclasses."
msgstr ""
"Вы можете создавать классы на основе других классов, чтобы наследовать"
" структуру и поведение; это ключевой аспект модульного проектирования. Класс"
" наследует как слоты, так и методы от своих суперклассов."

#: ./en/ch02.md:143
msgid "## 2.9 HOW CLOS EXTENDS COMMON LISP"
msgstr "## 2.9 КАК CLOS РАСШИРЯЕТ COMMON LISP"

#: ./en/ch02.md:145
msgid ""
"CLOS is a compatible extension to Common Lisp. This section draws parallels "
"between Common Lisp types and CLOS classes, compares defstruct structures "
"and classes, and focuses on the new power that CLOS offers."
msgstr ""
"CLOS - это совместимое расширение для Common Lisp. В этом разделе проводятся"
" параллели между типами Common Lisp и классами CLOS, сравниваются структуры и"
" классы defstruct и основное внимание уделяется новым возможностям, которые"
" предлагает CLOS."

#: ./en/ch02.md:147
msgid ""
"We begin by discussing the similarities between types and classes. In Common "
"Lisp, every Lisp object has a type. In CLOS, every Lisp object has a class "
"as well as a type. CLOS is based on the existing Common Lisp type system; it "
"does not invent a whole new type system."
msgstr ""
"Мы начнем с обсуждения сходства между типами и классами. В Common Lisp каждый"
" объект Lisp имеет тип. В CLOS каждый объект Lisp имеет не только тип, но и"
" класс. CLOS основан на существующей системе типов Common Lisp; он не"
" изобретает совершенно новую систему типов."

#: ./en/ch02.md:149
msgid ""
"A class is a Common Lisp type, which means you can use a class as the second "
"argument to typep. Recall that typep tests whether an object is of a given "
"type, where \"of a given type\" includes the type itself or less specific "
"types. Since CLOS class names are type specifiers, the form (typep instance "
"class-name) returns t if class-name names the class or a superclass of "
"instance."
msgstr ""
"Класс - это тип Common Lisp, что означает, что вы можете использовать класс в"
" качестве второго аргумента для typep. Напомним, что typep проверяет,"
" относится ли объект к заданному типу, где \"заданный тип\" включает в себя"
" сам тип или менее конкретные типы. Поскольку имена классов CLOS являются"
" спецификаторами типов, форма (typep instance class-name) возвращает t, если"
" class-name именует класс или суперкласс экземпляра(instance)."

#: ./en/ch02.md:152
msgid ""
"Common Lisp enables you to select an operation based on the type of an "
"object by using typecase. CLOS provides automatic support for selecting an "
"operation based on the class of an object. You write methods that are "
"attached to classes; when the generic function is called, CLOS automatically "
"chooses the appropriate methods, based on the classes of \n"
"the arguments."
msgstr ""
"Common Lisp позволяет выбирать операцию на основе типа объекта с помощью"
" typecase. CLOS обеспечивает автоматическую поддержку выбора операции на"
" основе класса объекта. Вы пишете методы, которые привязаны к классам; при"
" вызове обобщенной функции CLOS автоматически выбирает соответствующие методы"
" на основе классов аргументов."

#: ./en/ch02.md:154
msgid ""
"The Common Lisp defstruct facility enables you to define a new data type "
"with internal structure that is customized for your program. This new data "
"type can inherit from a type previously defined using defstruct. Similarly, "
"the CLOS defclass facility enables you to define a new class with internal "
"structure that is customized for your program. The new class can inherit "
"from existing classes."
msgstr ""
"Средство Common Lisp defstruct позволяет вам определить новый тип данных с"
" внутренней структурой, настроенной для вашей программы. Этот новый тип"
" данных может наследоваться от типа, ранее определенного с помощью defstruct."
" Аналогично, средство CLOS defclass позволяет вам определить новый класс с"
" внутренней структурой, настроенной для вашей программы. Новый класс может"
" наследовать от существующих классов."

#: ./en/ch02.md:156
msgid ""
"The similarities between types and classes raise one important question. Why "
"are classes needed at all? The following comparison, although not "
"exhaustive, points out the most important advantages of CLOS classes. "
msgstr ""
"Сходство между типами и классами поднимает один важный вопрос. Зачем вообще"
" нужны классы? Следующее сравнение, хотя и не является исчерпывающим,"
" указывает на наиболее важные преимущества классов CLOS."

#: ./en/ch02.md:159
msgid ""
"*  CLOS supports automatic association between code and a type of object. "
"The Common Lisp typecase mechanism offers a way to associate a body of code "
"with a type of object. However, this association is localized; it is "
"necessary to use typecase explicitly in every place where the operation "
"depends on the type of object. To upgrade a program to support additional "
"types of objects, you would need to edit each typecase form to create the "
"link between the new types and the operations appropriate to those types."
msgstr ""
"* CLOS поддерживает автоматическую ассоциацию между кодом и типом объекта."
" Механизм типизации Common Lisp также предлагает способ связать тело кода с"
" типом объекта. Однако эта ассоциация локализована; необходимо явно"
" использовать typecase в каждом месте, где операция зависит от типа объекта."
" Чтобы обновить программу для поддержки дополнительных типов объектов, вам"
" потребуется отредактировать каждую форму typecase, чтобы создать связь между"
" новыми типами и операциями, соответствующими этим типам."

#: ./en/ch02.md:161
msgid ""
"*  CLOS helps you abstract the operations appropriate to different types. "
"Callers can use operations on objects without being aware of how those "
"operations are implemented for different types of objects."
msgstr ""
"* CLOS помогает вам абстрагировать операции, соответствующие различным типам."
" Вызывающие могут использовать операции над объектами, не зная о том, как эти"
" операции реализуются для различных типов объектов."

#: ./en/ch02.md:163
msgid ""
"*  CLOS enables you to define methods, which are intrinsically linked to a "
"class of object. The process of choosing the operation appropriate to the "
"type of object (the generic dispatch) is entirely automatic. CLOS provides a "
"convenient way to link code permanently to the type of an object, and "
"removes the burden of maintaining links within typecase forms."
msgstr ""
"* CLOS позволяет вам определять методы, которые внутренне связаны с классом"
" объекта. Процесс выбора операции, соответствующей типу объекта (общая"
" отправка/generic dispatch), полностью автоматизирован. CLOS предоставляет"
" удобный способ постоянной привязки кода к типу объекта и снимает бремя"
" поддержания ссылок в формах typecase."

#: ./en/ch02.md:165
msgid ""
"*  CLOS provides multiple inheritance. With defstruct, you can build a new "
"type from one component type by using the : include option. In contrast, "
"defclass allows you to build a new class from any number of component "
"classes. The CLOS multiple inheritance offers a great deal more flexibility "
"and power than does the single inheritance of defstruct."
msgstr ""
"* CLOS обеспечивает множественное наследование. С помощью defstruct вы можете"
" создать новый тип из одного типа компонента, используя опцию :include. В"
" отличие от этого, defclass позволяет вам создавать новый класс из любого"
" количества классов компонентов. Множественное наследование CLOS обеспечивает"
" гораздо большую гибкость и мощь, чем одиночное наследование defstruct."

#: ./en/ch02.md:167
msgid ""
"*  CLOS offers flexible inheritance of behavior. CLOS supports the "
"inheritance of structure in much the same way that Common Lisp defstruct "
"does. Although both defstruct structures and classes inherit slots from "
"their components, the CLOS mechanisms for inheriting behavior are much more "
"powerful than the limited mechanisms of Common Lisp defstruct."
msgstr ""
"* CLOS предлагает гибкое наследование поведения. CLOS поддерживает"
" наследование структуры во многом так же, как это делает Common Lisp"
" defstruct. Хотя и структуры defstruct, и классы наследуют слоты от своих"
" компонентов, механизмы CLOS для наследования поведения гораздо более мощные,"
" чем ограниченные механизмы Common Lisp defstruct."

#: ./en/ch02.md:170
msgid ""
"A Common Lisp defstruct structure can use any accessors for reading or "
"writing slots provided by its component; this is the extent of inheritance "
"of behavior. In contrast, CLOS supports a much more transparent and flexible "
"means of inheriting behavior: Classes inherit \n"
"methods from their superclasses. A class can override inherited behavior by "
"providing a primary method that shadows the inherited method. A class can "
"modify inherited behavior by adding a before-method or after-method to "
"customize the work done by the inherited  primary method. In addition, CLOS "
"offers several advanced techniques that give you further control over the "
"inheritance of behavior. "
msgstr ""
"Структура Common Lisp defstruct может использовать любые средства доступа для"
" чтения или записи слотов, предоставляемых ее компонентом; это степень"
" наследования поведения. В отличие от этого, CLOS поддерживает гораздо более"
" прозрачные и гибкие средства наследования поведения: классы наследуют методы"
" от своих суперклассов. Класс может переопределять унаследованное поведение,"
" предоставляя первичный метод, который затеняет унаследованный метод. Класс"
" может изменять унаследованное поведение, добавляя метод до(before-) или"
" после( after-), чтобы настроить работу, выполняемую унаследованным основным"
" методом. Кроме того, CLOS предлагает несколько продвинутых методов, которые"
" дают вам дополнительный контроль над наследованием поведения."
