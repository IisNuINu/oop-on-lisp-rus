# Переопределение элементов CLOS

Переопределение элемента CLOS означает вычисление/оценку новой определяющей формы (например, формы defmethod), когда этот элемент (метод) уже существует. В общем, CLOS заменяет старое определение новым.

Возможность переопределения классов и методов имеет решающее значение для разработки программного обеспечения. Это позволяет вам продолжать совершенствовать дизайн запущенной программы даже после создания экземпляров; когда класс переопределяется, все существующие экземпляры обновляются до нового определения. Часто самой сложной частью проектирования объектно-ориентированной программы является выбор правильной модульности. Иногда, когда вы начинаете писать методы, вы думаете о лучшей организации классов, которая дала бы более модульный код. CLOS поддерживает гибкие средства переопределения классов и методов, поэтому у вас есть свобода изменять свой первоначальный дизайн, включая организацию классов.

В этой главе мы приводим пример переопределения класса, обновления экземпляров в соответствии с новым определением класса и переопределения затронутых методов. Первая цель этого примера - проиллюстрировать механику переопределения элементов CLOS. Вторая цель состоит в том, чтобы дать некоторые рекомендации по разработке программы, в которой большинство элементов независимы друг от друга; в такой программе вы можете переопределить один элемент, не затрагивая большинство других элементов.

## 8.1 ПЕРЕОПРЕДЕЛЕНИЕ КЛАССОВ

Если вы оцениваете форму defclass и класс с таким именем уже существует, новое определение класса заменяет старое. Вы можете переопределить класс, чтобы изменить любой его аспект, включая его слоты, суперклассы, методы доступа и любые параметры defclass.

### На что влияет переопределение

Обратите внимание, что изменение определения класса влияет на все подклассы класса, поскольку они наследуют структуру от класса. Поскольку класс управляет структурой своих экземпляров, это также влияет на все экземпляры класса и подклассов. Кроме того, поскольку параметры defclass определяют методы для чтения и записи, переопределение класса также может повлиять на эти методы. Когда вы переопределяете класс, CLOS автоматически распространяет изменения на все, что затронуто, включая подклассы, экземпляры класса и подклассов, а также методы для средств доступа.

### Что происходит с методами доступа

Любой метод доступа, который был создан в соответствии со старым определением класса (с помощью параметров слота :accessor, :reader или :writer), но не запрашивается новым определением класса, удаляется из обобщенной функции.

### Автоматическое обновление экземпляров

Когда вы переопределяете класс таким образом, что структура экземпляров изменяется (что происходит, например, при добавлении или удалении слотов), все экземпляры класса и его подклассы должны быть обновлены до новой структуры. CLOS автоматически обновляет экземпляры.

CLOS указывает, что обновление каждого экземпляра происходит за некоторое время до того, как какой-либо слот этого экземпляра будет доступен для чтения или записи. Хотя вы не можете предположить, что обновление экземпляров происходит сразу после оценки нового определения класса, семантически эффект тот же; вы защищены от любого доступа к устаревшему экземпляру.

CLOS обновляет экземпляры по мере необходимости, а не все сразу. Таким образом, CLOS не нужно отслеживать все экземпляры класса, и любые экземпляры без ссылок могут быть убраны сборщиком мусора.

### Что происходит со слотами существующих экземпляров

Когда вы переопределяете класс таким образом, что структура экземпляров изменяется (что происходит, например, при добавлении или удалении слотов), все экземпляры класса и его подклассы должны быть обновлены до новой структуры. CLOS автоматически обновляет экземпляры.

* Если в обоих определениях указан один и тот же слот, значение слота сохраняется.
* Когда слот указан в новом определении, но не был указан в старом, слот добавляется в экземпляры и инициализируется в соответствии с параметром :initform.
* Когда слот, указанный в старом определении, не указан в новом, слот удаляется из экземпляра и любое значение отбрасывается. Однако значения удаленных слотов не удаляются сразу; вы можете получить к ним доступ, написав метод для настройки обновления.

Мы обобщаем эту информацию в таблице 8.1, в которой также показано, что происходит, когда тип распределения слота изменяется с локального на общий или с общего на локальный. Записи в таблице 8.1 имеют следующие значения:

	     > preserved(сохранено)       Значение слота остается одинаковым до и после обновления экземпляра. 
	     >                                        Если слот ранее был не привязан, он все еще не привязан после обновления.

	     > initialized(инициализирован)    Слот получает значение :initform слота, если он указан классом или
	     >                                               унаследован от суперклассов. Если нет :initform, значение слота не
	     >                                               привязано.

	     > discarded(отброшен)            Слот удаляется из экземпляров, и его значение теряется.

|             | Shared (New) | Local (New) | None (New) |
|-------------|--------------|-------------|------------|
| shared (old)| preserved    | preserved   | discarded  |
| local (old) | initialized  | preserved   | discarded  |
| none (old)  | initialized  | initialized | no action  |

Таблица 8.1 Влияет на слоты при переопределении класса.

### Настройка обновления

CLOS позволяет указать другие действия, которые необходимо предпринять при обновлении экземпляра в соответствии с новым определением класса. Для этого вы можете предоставить метод update-instance-for-redefined-class для выполнения дальнейшей работы по обновлению экземпляров. Тело метода может получить доступ к значениям отброшенных слотов, которые вы можете использовать для инициализации других слотов.

Когда вы переопределяете класс, CLOS обновляет структуру класса и подклассов (при необходимости) и удаляет или добавляет методы доступа (при необходимости). CLOS обновляет структуру каждого экземпляра (в зависящее от реализации время до следующего доступа к слоту экземпляра), добавляя новые слоты и удаляя устаревшие слоты. Наконец, CLOS вызывает обобщенную функцию update-instance-for-redefined-class. Основной метод по умолчанию для update-instance-for-redefined-class инициализирует слоты способом, описанным ранее.

В большинстве случаев пользователи должны предоставлять методы before-(до) или after-(после) для update-instance-for-redefined-class, а не первичные методы. Основной метод переопределил бы метод по умолчанию, который инициализирует новые слоты, и предотвратил бы обычную инициализацию. Если вы инициализируете слот в методе before, основной метод по умолчанию не заполняет слот своей initform.

Вы можете настроить update-instance-for-redefined-class для сохранения значений в новых слотах на основе значений отбрасываемых слотов. В качестве простого примера, чтобы переименовать слот, вы можете написать метод для сохранения значения отброшенного слота в новый слот.

Обобщенная функция update-instance-for-redefined-class имеет четыре обязательных аргумента и один аргумент &rest:

	     > instance(экземпляр)       Экземпляр, который был обновлен до новой структуры

	     > added-slots(добавленные слоты)      Список названий добавленных слотов

	     > discarded-slots(отброшенные слоты)  Список названий отброшенных слотов

	     > property-list(свойство-список)      Список, содержащий чередующиеся имена и значения отброшенных
	     >                                                   слотов (не включая любые отброшенные слоты, которые были
 	     >                                                   несвязаны), и любые слоты, указанные как локальные в старом
	     >                                                   определении и совместно используемые в новом определении

	    > &rest initargs           Аргумент &rest используется редко; мы обсуждаем его в разделе "Выполнение
	    >                               инициализации с помощью Initargs", стр. 168

Наиболее полезным аргументом является список свойств, который дает вам возможность получить доступ к значениям отброшенных слотов. Пример переопределения класса и определения метода для обновления экземпляра для переопределенного класса см. в разделе "Пример переопределения элементов CLOS", стр. 144.

## 8.2 ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ И ОБОБЩЕННЫХ ФУНКЦИЙ

### Методы

Если вы вычисляете форму defmethod, и метод уже существует для той же обобщенной функции с тем же специализирующим параметром и теми же квалификаторами, новое определение метода заменяет старое.

Любые будущие вызовы обобщенной функции будут видеть новое определение метода. Если метод переопределяется во время выполнения самой обобщенной функции, последствия непредсказуемы. Многие реализации CLOS оптимизируют части общей отправки, поэтому возможно, что новое определение метода не будет использоваться для этого вызова обобщенной  функции.

### Обобщенные функции

Если вы вычисляете defgeneric форму и обобщенная функция с таким именем уже существует, defgeneric переопределяет существующую обобщенную функцию. Выдается сообщение об ошибке, если какие-либо методы для обобщенной функции не соответствуют лямбда-списку, указанному defgeneric. Когда вы переопределяете обобщенную функцию, новое определение обобщенной функции заменяет старое определение.

Форма defgeneric может определять методы, включая параметр :method. Параметр :method для defgeneric имеет тот же эффект, что и использование defmethod для определения метода для этой обобщенной функции. Иногда полезно определять методы в самой форме defgeneric, особенно для методов по умолчанию. Это способ выделить поведение по умолчанию. Примеры использования этого синтаксиса см. в разделе "Определение направленных потоков", стр. 180.

Если вы переопределяете обобщенные функцию, а новая форма defgeneric использует параметр :method, могут произойти две вещи. Если этот метод уже существует (метод для той же обобщенной функции с теми же спецификаторами параметров и теми же квалификаторами), он заменяется методом, определенным в опции :method. Если этот метод еще не существует, он создается. Переопределение обобщенной функции может добавить методы к обобщенной функции и может заменить методы, но оно никогда не удаляет методы: если предыдущий defgeneric определил метод с параметром :method, но текущий defgeneric не определяет этот метод, объект метода продолжает существовать в Lisp.

Вы не можете использовать defgeneric для переопределения обычной функции Lisp, макроса или специальной формы. Сообщение об ошибке выдается, если вы вычисляете defgeneric форму, а первым аргументом является имя обычной функции, макроса или специальной формы. Напротив, вы можете использовать defun для переопределения обобщенной функции. Если вы определяете обычную функцию Lisp, макрос или специальную форму с тем же именем, что и существующая обобщенная функция, это имя больше не связано с обобщенной функцией.

## 8.3 ПРИМЕР ПЕРЕОПРЕДЕЛЕНИЯ ЭЛЕМЕНТОВ CLOS

Цель этого примера - показать, как легко вы можете переопределить части программы CLOS, даже после того, как экземпляры были созданы и клиенты используют программу.

Сначала мы определяем два протокола для работы с треугольниками, один внешний (предназначенный для клиентов) и один внутренний (который будет использоваться в рамках реализации этой программы). Затем мы определяем реализацию обоих протоколов, включая класс для представления треугольников и набор методов.

Позже мы решаем изменить внутреннее представление треугольников. Мы можем сделать это вообще без изменения внешнего протокола. Однако изменение требует только того, чтобы мы переопределили некоторые методы для внутреннего протокола и предоставили метод для обновления любых существующих треугольников до нового представления.

### Внешний Протокол треугольника

Интерфейс, который мы рекламируем(предоставляем) клиентам, состоит из следующих операций:

	     >  make-triangle side-a side-b side-c
	     >           Возвращает новый треугольник; каждый аргумент - это длина одной стороны треугольника

	     >  area triangle 
	     >           Возвращает площадь треугольника

	     >  dimensions triangle 
	     >           Возвращает список длин трех сторон треугольника 
	     >  angles triangle 
	     >           Возвращает список трех углов треугольника

### Внутренний Протокол треугольника

Следующие шесть операций полезны в рамках реализации, поскольку все они необходимы для поддержки внешнего протокола. Ожидается, что клиенты не будут использовать эти операции.

	     >        side-a triangle                    angle-A triangle 
	     >        side-b triangle                    angle-B triangle 
	     >        side-c triangle                    angle-C triangle 

Каждая из этих операций возвращает один аспект треугольника: либо длину одной стороны, либо измерение одного угла. Обратите внимание, что angle-A - это угол, противоположной стороне side-a. На рисунке 8.1 показано, как углы и стороны связаны друг с другом.

![Рисунок 8.1: Углы и стороны треугольника.](images/f07-01.jpg )**Рисунок 8.1: Углы и стороны треугольника.**

### Первоначальная Реализация

Во-первых, мы реализуем класс triangle. Внутреннее представление треугольников простое; мы сохраняем длину каждой стороны в ячейке. Используя опцию :reader, мы можем удобно предоставить методы для side-a, side-b и side-c.

<pre>
(defclass shape () () 
  (:documentation "The foundation of all shapes.")) 

(defclass triangle (shape) 
  ((a :reader side-a :initarg :side-a) 
   (b :reader side-b :initarg :side-b) 
   (c :reader side-c :initarg :side-c))) 
</pre>
Далее мы предоставляем конструктор make-triangle. Этот конструктор приводит длину каждой стороны к типу float перед созданием экземпляра, чтобы гарантировать, что все математические операции со сторонами используют арифметику с плавающей запятой.

<pre>
(defun make-triangle (a b c) 
   ;; All sides should be represented as floats 
   (make-instance 'triangle :side-a (coerce a 'float) 
                            :side-b (coerce b 'float) 
                            :side-c (coerce c 'float))) 
</pre>

Функция three-sides-to-angle будет полезна в телах методов, которые возвращают углы треугольника.

<pre>
;;; Return the angle A between adjacent sides b and c 
;;; and opposite side a, given all sides of a triangle 
;;; Law of Cosines: aA2 - bA2 + cA2 - 2bc(cos A) 
(defun three-sides-to-angle (a b c) 
   (acos (/ (- (+ (expt b 2) 
                  (expt c 2)) 
               (expt a 2)) 
            (* 2 b c)))) 
</pre>

Далее мы определяем методы для возврата отдельных углов треугольника:

<pre>
(defmethod angle-A ((tri triangle)) 
   (three-sides-to-angle 
    (side-a tri) (side-b tri) (side-c tri))) 

(defmethod angle-B ((tri triangle)) 
   (three-sides-to-angle 
    (side-b tri) (side-c tri) (side-a tri))) 

(defmethod angle-C ((tri triangle)) 
   (three-sides-to-angle 
    (side-c tri) (side-a tri) (side-b tri))) 
</pre>

Мы решили явно определить общие функции для операций, которые являются частью внешнего протокола. Defgeneric формы указывают, что эти три операции предназначены для работы с любой формой:

<pre>
(defgeneric dimensions (shape) 
   (:documentation "Returns list of side lengths.")) 

(defgeneric angles (shape) 
   (:documentation "Returns list of angles.")) 

(defgeneric area (shape) 
   (:documentation "Returns area of the shape.")) 
</pre>

Три внешние операции, которые имеют дело с существующими треугольниками, могут быть определены в терминах внутренних операций, не зависящих от каких-либо знаний о том, как реализуются эти внутренние операции.

<pre>
(defmethod dimensions ((tri triangle)) 
   (list (side-a tri) 
         (side-b tri) 
         (side-c tri))) 

(defmethod angles ((tri triangle)) 
   (list (angle-A tri) 
         (angle-B tri) 
         (angle-C tri)))

;;; Return the area of a triangle 
;;; Algorithm is: area = ab(sin C)/2 
(defmethod area ((tri triangle)) 
   (* (side-a tri) (side-b tri) 
      (sin         (angle-C tri)) 
      .5)) 
</pre>

### Изменение представления треугольников

Теперь мы решаем изменить внутреннее представление треугольников. Мы хотим переопределить класс triangle, чтобы хранить две стороны и угол между ними, вместо того, чтобы хранить три стороны.

Для реальной программы одной из возможных мотиваций для изменения внутреннего представления было бы повышение эффективности операции. В этом случае операция angle-C, вероятно, будет быстрее, когда метод просто считывает значение слота вместо выполнения несколько дорогостоящего вычисления угла с трех сторон. С другой стороны, side-c будет медленнее. Это компромисс, основанный на том, как используется программа.

Следующее определение класса может заменить предыдущее определение класса. На этом этапе мы пишем форму defclass, но не вычисляем ее сразу. Прежде чем переопределять класс, мы должны убедиться, что все существующие экземпляры будут обновлены должным образом.

<pre>
(defclass triangle (shape) 
  ((a :reader side-a :initarg :side-a) 
   (b :reader side-b :initarg :side-b) 
   (angle-C :reader angle-C :initarg :angle-C))) 
</pre>

Обратите внимание, что это определение класса создает метод для обобщенной функции чтения(reader), angle-C. Фактически, этот метод заменит существующий метод для обобщенной функции angle-C. (Мы также должны удалить предыдущее определение метода angle-C из источника.) Это именно то, что мы хотим; при вычислении нового определения класса обобщенной функция angle-C вернет значение слота angle-C вместо вычисления угла с трех сторон треугольника.

Чтобы обновить экземпляры, мы предоставляем метод для update-instance-for-redefined-class. Мы выбираем использовать метод after-method, чтобы не переопределять системный метод по умолчанию. Это безопасная практика, даже несмотря на то, что в этом случае ни один из слотов не использует опцию слота :initform и, следовательно, не нуждается в инициализации таким образом. Возможно, у класса triangle есть подкласс со слотами, которые необходимо инициализировать из их initforms. Если у нас нет явной причины для предотвращения запуска системного метода, лучше всего разрешить ему запуск.

Значения слотов a и b сохраняются, поскольку это локальные слоты, которые определены как в предыдущем, так и в новом классах. Перед вызовом этого метода слот c будет удален из экземпляра и будет добавлен слот angle-C. Этот метод будет использовать значение отброшенного слота c для вычисления значения нового угла angle-C и сохранит значение в слоте.

Имейте в виду, что класс может быть переопределен более одного раза. Позже мы могли бы решить, что предпочтительнее еще одно представление треугольников. Поскольку экземпляры не обязательно обновляются сразу после переопределения, некоторые существующие экземпляры могут отличаться от текущего формата на несколько форматов. Этот метод пытается быть безопасным перед лицом множественных переопределений классов. Прежде чем делать что-либо еще, этот метод проверяет, что экземпляр обновляется ожидаемым образом; то есть, что слот c отбрасывается и добавляется слот angle-C. Если оба эти условия выполнены, метод вычисляет соответствующее значение для слота  angle-C и сохраняет его в слоте.

<pre>
;;; Here we delete slot c and add angle-C 
;;; We need to initialize the new slot angle-C 
(defmethod update-instance-for-redefined-class :after 
    ((instance triangle) 
     added-slots discarded-slots 
     plist &rest initargs) 
   (declare (ignore initargs)) 
   ;; Identify this particular redefinition 
   (if (and (member 'c discarded-slots) 
            (member 'angle-C added-slots)) 
       (setf (slot-value instance 'angle-C) 
             (three-sides-to-angle 
              (getf plist 'c) 
              (side-a instance) 
              (side-b instance))))) 
</pre>

Крайне важно оценить метод для update-instance-for-redefined-class, прежде чем оценивать новое определение класса. В противном случае, в промежутке после переопределения класса и перед оценкой метода для обновления экземпляра для переопределенного класса, экземпляры могут быть обновлены до нового определения. Экземпляр обновляется за некоторое время до того, как будет получен доступ к любому из его слотов. Если экземпляр обновляется до определения метода, только слоты a и b будут иметь значения. Не будет никакого способа вычислить слот angle-C, потому что значение удаленного слота c будет отброшено.

Методы для side-a и side-b не изменились; они продолжают работать по-прежнему. Однако метод для side-c (который был методом чтения, сгенерированным предыдущим определением класса) будет удален из Lisp при вычислении/оценке нового определения класса. Следовательно, нам нужно написать новый метод для side-c. Метод вычисляет третью сторону треугольника, основываясь на двух сторонах и угле между ними.

<pre>
(defmethod side-c ((tri triangle)) 
   (third-side (side-a tri) 
               (side-b tri) 
               (angle-C tri)))

;;; Algorithm is: c^2 = a^2 + b^2 - 2ab(cos C) 
(defun third-side (a b angle-C) 
   (sqrt (- (+ (expt a 2) 
               (expt b 2)) 
            (* 2 a b (cos angle-C))))) 
</pre>

Нам также необходимо пересмотреть нашу функцию конструктора, потому что она вызывает make-instance с помощью initarg :side-c, который больше не является допустимым initarg. Легко написать новый конструктор, который принимает те же аргументы, но заполняет разные слоты, используя эту информацию. Этот конструктор использует аргумент c для вычисления соответствующего значения для слота angle-C.

<pre>
(defun make-triangle (a b c) 
   (let* ((float-a (coerce a 'float)) 
          (float-b (coerce b 'float)) 
          (float-c (coerce c 'float)) 
          (angle-C (three-sides-to-angle 
                    float-c float-a float-b))) 
      (make-instance 'triangle :side-a float-a 
                               :side-b float-b 
                               :angle-C angle-C))) 
</pre>

Часто конструктор нуждается в переопределении, когда переопределяется сам класс. Конструкторы тесно связаны со структурой класса, потому что они обычно принимают аргументы и используют их для заполнения слотов.

### Что изменилось, а Что Осталось прежним

Важно, чтобы, независимо от того, какие изменения происходят во внутренних компонентах программы, документированный внешний протокол оставался неизменным. Это позволяет любому клиентскому коду продолжать работать. Здесь мы также постарались сохранить задокументированный внутренний протокол неизменным, что минимизировало объем внутреннего кода, который необходимо было изменить.

| Что Изменилось                      |   Что Осталось прежним                 |
|-------------------------------------|----------------------------------------|
| Определение класса треугольников    | Восприятие треугольников пользователем |
| Реализация side-c,                  | Документированный внешний протокол     |
| agle-C и make-triangle              | Документированный внутренний протокол  |
|                                     | Реализация side-a,                     |
|                                     | side-b, angle-A, angle-B, area,        |
|                                     | dimensions и angles                    |

Поскольку конструктор принимает три стороны в качестве аргументов, мы призываем пользователей думать о треугольниках как о представленных тремя сторонами. Новое внутреннее представление треугольников не соответствует этому восприятию, но поскольку внешний протокол остается прежним, мы не требуем от пользователей менять свою ментальную модель треугольников. Аналогичным образом, в нашей документации по внешнему протоколу намеренно не указано, что side-c ранее был реализован как средство чтения. Документация внешнего протокола никогда не должна раскрывать внутренние компоненты, например, упоминать, что обобщенная функция реализована как средство доступа.

Нам "повезло", что большая часть реализации программы продолжала работать, когда изменилось представление треугольников. На самом деле, это вовсе не удача, а скорее прямой результат документирования и соблюдения внутреннего протокола.

Во-первых, рассмотрите опарации area, dimensions и angles. Все эти внешние операции реализованы в терминах внутреннего протокола, который мы продолжали поддерживать после переопределения класса. Внутренний протокол гарантирует, что эти три операции остаются действительными.

Далее рассмотрим сами внутренние операции. Каждый из них выполняет определенную задачу, возвращая один угол или сторону. Эта модульность проектирования подразумевает, что метод необходимо переписывать только в том случае, если он зависит от какого-либо аспекта определения класса, который был изменен. Например, поскольку слоты a и b остаются неизменными, методы для side-a и side-b остаются действительными.

Другая причина, по которой большинство методов для внутренних операций остаются действительными, заключается в том, что эти методы зависят от внутреннего протокола, а не от внутренней структуры класса. За исключением средств доступа (которые обязательно зависят от слотов), ни один из методов не использует знание внутренних деталей класса. Например, чтобы получить длину side-c, методы вызывали обобщенную функцию side-c. Эквивалентной альтернативой вызову side-c является использование with-accessors. Напротив, любой код, использующий with-slots, имеет встроенную зависимость от внутреннего представления класса; этот код нужно было бы переписать, если бы класс был переопределен для удаления слота.

## 8.4 ИЗМЕНЕНИЕ КЛАССА ЭКЗЕМПЛЯРА

Вы можете изменить класс существующего экземпляра, вызвав change-class. Мы используем термин "предыдущий класс/"previous class" для обозначения класса экземпляра до его изменения, а "целевой класс/target class" для обозначения класса экземпляра после его изменения. CLOS обновляет экземпляр до структуры целевого класса, что может включать удаление или добавление слотов.

### Что происходит со слотами экземпляра

Когда экземпляр изменяется на другой класс, это никак не влияет на значения каких-либо общих(shared) слотов. Экземпляр, однако, потеряет доступ к любым общим слотам предыдущего класса. Если целевой класс определяет другой слот с тем же именем (будь то общий или локальный), экземпляр получит доступ к этому слоту вместо старого. (Если предыдущий и целевой классы получают доступ к одному и тому же общему слоту, потому что один из классов наследует его от другого, экземпляр продолжит получать доступ к этому слоту.)

В таблице 8.2 показано, что происходит со значениями слотов. "Сохраненный/"Preserved", "инициализированный/initialized" и "отброшенный/discarded" имеют значения, описанные в разделе "Переопределение классов", стр. 140. Мы вводим еще два термина:

	     > inaccessible(недоступно)     Общий слот предыдущего класса недоступен для экземпляра
	     >                                           после того, как его класс был изменен на целевой класс.

	     > replaced(заменено)    Для любого общего слота целевого класса экземпляр обновляется для доступа 
	     >                                 к этому общему слоту. Если предыдущий класс определил слот с тем же именем,
	     >                                 будь то локальный или общий, обновленный экземпляр больше не обращается к
	     >                                 этому слоту. Таким образом, мы говорим, что значение слота "заменяется"
	     >                                значением общего слота целевого класса.

|                     | Общий (Целевой) | Локальный (Целевой) | Нет (Целевой)   |
|---------------------|-----------------|---------------------|-----------------|
| общий (предыдущий)  | замененный      | сохраненный         | недоступный     |
|локальный(предыдущий)| замененный      | сохраненный         | отброшенный     |
| нет (предыдущий)    | замененный      | инициализирован     | никаких действий|

Таблица 8.2 Влияние на слоты при изменении класса экземпляра.

### Настройка обновления

CLOS позволяет указать другие действия, которые необходимо предпринять, когда экземпляр обновляется в соответствии с определением другого класса. Вы можете предоставить методы для update-instance-for-different-class для выполнения дальнейшей работы по обновлению экземпляра.

Когда вы вызываете change-class, CLOS обновляет структуру экземпляра, а затем вызывает обобщенную функцию update-instance-for-different-class. Основной метод по умолчанию инициализирует любые новые локальные слоты в соответствии с формой :init целевого класса.

Обратите внимание, что, если вы определите основной метод для update-instance-for-different-class, он переопределит метод по умолчанию, который инициализирует новые локальные слоты. В большинстве случаев предпочтительнее допустить такое поведение и специализировать update-instance-for-different-class путем написания методов before или after. Если вы инициализируете слот в методе before, основной метод по умолчанию не заполняет слот своей initform.

Когда CLOS вызывает update-instance-for-different-class, первый аргумент, предыдущий, является копией экземпляра до того, как он был обновлен. Второй аргумент, target, - это обновленный экземпляр. Целевой и предыдущие аргументы не являются  eq. Вы можете получить доступ к значениям всех слотов в предыдущем экземпляре, используя средства доступа или значение слота в предыдущем аргументе; вы также можете использовать другие функции или обобщенные функции в предыдущем аргументе.