# Процедурное определение: Инициализация

В этой главе мы обсуждаем технику разработки "процедурного определения" задачи высокого уровня; это влечет за собой разбиение задачи на отдельные обобщенные функции, каждая из которых отвечает за четко определенную часть задачи. Обычно для обобщенных функций существует поведение по умолчанию. Программисты используют эти обобщенные функции в качестве точек входа; они могут управлять частями задачи, специализируя одну или несколько обобщенных функций.

Некоторые программы имеют несколько связанных задач. Процедурные определения задач могут накладываться друг на друга, чтобы совместно использовать код. Две или три задачи могут быть определены для вызова одной обобщенной функции. Этот метод(техника) может привести к созданию модульных программ; он требует тщательного проектирования, при котором общая работа может быть разделена, в то время как отдельная работа может храниться отдельно. Мы подробно рассмотрим один пример: процедурное определение инициализации CLOS.

## 10.1 ПРИМЕРЫ ПРОЦЕДУРНЫХ ОПРЕДЕЛЕНИЙ

Мы использовали метод процедурного определения в разделе "Реализация установки/инсталяции", стр. 80. Как показано на рис. 10.1, задача установки разделена на четыре обобщенные функции, каждая из которых выполняет отдельный аспект установки.

![Рисунок 10.1: Процедурное определение задачи установки.](images/f10-01.jpg )**Рисунок 10.1: Процедурное определение задачи установки.**

Позже, в разделе "Процедурное определение для создания потоков", стр. 207, мы разработаем процедурное определение для выбора правильного класса потока для создания и для создания потока путем предоставления соответствующих аргументов make-instance.

Сам CLOS использует технику процедурных определений. Мы уже видели, что make-instance имеет процедурное определение: она всегда вызывает initialize-instance. Переопределение класса - еще один пример; оно всегда вызывает update-instance-for-redefined-class. Аналогично, change-class всегда вызывает update-instance-for-different-class. Обобщенные функции initialize-instance, update-instance-for-redefined-class и update-instance-for-different-class намеренно определены как точки входа — обобщенные функции, которые могут быть специализированы с помощью методов.

Некоторые ситуации с ошибками также имеют процедурные определения: обобщенные функции, которые вызываются при возникновении ошибок. Метод по умолчанию сигнализирует об ошибке, но вы можете специализировать обобщенную функцию, чтобы сделать что-то другое. Обобщенные функции включают в себя следующее:

	>   slot-unbound 
	>            Вызывается при попытке прочитать несвязанный слот

	>   slot-missing 
	>            Вызывается, когда предпринимается попытка получить доступ к слоту экземпляра, но нет слота
	>            с таким именем, доступного экземпляру

	>   no-applicable-method 
	>            Вызывается, когда вызывается обобщенная функция и для нее нет применимого метода

	>   no-next-method 
	>             Вызывается, когда используется call-next-method и нет "следующего метода"

## 10.2 ИЗОЛЯЦИЯ РАБОТЫ, РАЗДЕЛЯЕМОЙ МЕЖДУ ПРОЦЕДУРАМИ

CLOS инициализирует экземпляры в нескольких контекстах: когда экземпляр впервые создается с помощью make-instance, когда экземпляр обновляется, поскольку его класс был переопределен, и когда вы используете change-class для изменения класса экземпляра. Кроме того, функция reinitialize-instance (редко используемая в прикладных программах, но используемая в рамках реализации самого CLOS, в протоколе metaobject) выполняет инициализацию экземпляра на основе initargs.

В каждой из этих задач работа по инициализации аналогична, но не идентична. В объектно-ориентированном проектировании цель состоит в том, чтобы изолировать работу, которой можно поделиться, определить ее один раз и использовать везде, где это необходимо. В этом разделе мы опишем, как CLOS определяет эти связанные процедуры объектно-ориентированным способом. Вы можете использовать этот подход при разработке своих собственных программ. Четыре связанные процедуры инициализации несколько сложны, и большинство прикладных программ не требуют такой большой сложности; тем не менее, этот пример дает хорошую иллюстрацию процедурных определений.

Первый шаг - определить, что общего у этих процедур. Здесь мы сосредоточимся на работе по инициализации, выполняемой в каждой задаче:

	>   initialize-instance 
	>           Выполняет инициализацию в соответствии с initargs; затем для любых слотов, которые все еще 
	>           не привязаны, заполняет эти слоты значениями их initforms

	>   reinitialize-instance 
	>           Выполняет инициализацию в соответствии с initargs

	>   update-instance-for-redefined-class 
	>           Выполняет инициализацию в соответствии с initargs; затем для любых добавленных локальных
	>           слотов, которые все еще не привязаны, заполняет эти слоты значениями их initforms

	>   update-instance-for-different-class 
	>           Выполняет инициализацию в соответствии с initargs; затем для любых добавленных локальных
	>           слотов, которые все еще не привязаны, заполняет эти слоты значениями их initforms

Мы определили две фазы инициализации: выполнение инициализации в соответствии с initargs, а затем заполнение некоторых несвязанных слотов значениями их initforms. CLOS организует выполнение обеих фаз одной обобщенной функцией shared-initialize, которая вызывается всеми четырьмя упомянутыми обобобщенными функциями. Четыре функции имеют несколько разные требования; эти различия устраняются путем предоставления аргументов для shared-initialize(общей инициализации). Синтаксис shared-initialize таков

## 10.3 ЗАПОЛНЕНИЕ НЕСВЯЗАННЫХ СЛОТОВ INITFORMS(ФОРМАМИ ИНИЦИАЛИЗАЦИИ)

Для двух функций обновления фаза заполнения несвязанных слотов с помощью initforms выполняется для добавленных локальных слотов. Для initialize-instance этот этап выполняется для всех слотов; для reinitialize-instance он не выполняется ни для каких слотов.

Обобщенная функция shared-initialize принимает обязательный аргумент, называемый slots-for-initform, указывающий, какие слоты следует заполнить их initforms. Этот аргумент представляет собой список имен слотов, или t для обозначения всех слотов, или nil для обозначения отсутствия слотов. В следующей таблице показано, как вызывающие  (методы по умолчанию для четырех обобщенных функций) предоставляют аргумент slots-for-initform:

| Вызывающий shared-initialize   | Значение для  slots-for-initform      |
|------------------------------------------------|-------------------------------|
| initialize-instance                           | t                           |
| reinitialize-instance                        | nil                         |
| update-instance-for-redefined-class | added  local slots   |
| update-instance-for-different-class  | added  local slots   |

## 10.4 ВЫПОЛНЕНИЕ ИНИЦИАЛИЗАЦИИ С ПОМОЩЬЮ INITARGS

Как описано в разделе "Управление инициализацией с помощью методов", стр. 159, initialize-instance выполняет инициализацию в соответствии с initargs. Если initarg заполняющий слот, задан в вызове initialize-instance, слот заполняется этим значением, даже если слот уже имеет значение. Initargs также могут использоваться определяемыми пользователем методами инициализации, которые выполняют дополнительную работу, требуемую прикладной программой.

В большинстве случаев нет необходимости в обновлении функций для использования аргументов инициализации. Иногда, однако, прикладной программе требуется метод для специальной цели, и этому методу нужны некоторые аргументы в качестве входных данных. Например, методу update-instance-for-redefined-class(обновления экземпляра для переопределенного класса) может потребоваться аргумент в дополнение к четырем требуемым аргументам; то же самое может быть верно для метода update-instance-for-different-class(обновления экземпляра для другого класса).

Initargs могут быть полезны во всех задачах инициализации, так что это еще одна часть работы, которой можно поделиться. Таким образом, shared-initialize принимает аргумент &rest, состоящий из initargs. Каждый вызывающий shared-initialize выбирает, предоставлять ли initargs или нет.

Пользователь может предоставить initargs(инициализации) непосредственно make-instance; эти initargs передаются initialize-instance, а затем передаются shared-initialize. Однако при переопределении класса или изменении класса экземпляра пользователь не может предоставить initargs. Так как initargs могут быть полезны в этих процедурах обновления? Вы можете определить (окружающий)around-метод дляupdate-instance-for-redefined-class или update-instance-for-different-class. Метод around вычисляет initargs и передает их в вызове call-next-method; метод по умолчанию вызывается с этими initargs, и он передает их в shared-initialize. Таким образом, around-методы являются точкой входа, которая позволяет функциям обновления использовать initargs.

## 10.5 СПЕЦИАЛИЗАЦИЯ ЧАСТИ ПРОЦЕДУРЫ

Процедурное определение позволяет пользователям специализировать один или несколько аспектов процедуры в целом. Схема инициализации признает, что некоторая работа подходит только для одной задачи (например, переопределение класса), тогда как другая работа подходит для всех задач инициализации. Процедурное определение как отделяет четыре задачи инициализации друг от друга, так и объединяет их с помощью вызова shared-initialize.

| Специализация этой обобщенной функции | Влияние                     |
|---------------------------------------|-----------------------------|
| initialize-instance                   | создание экземпляра         |
| reinitialize-instance                 | переинициализация экземпляра| 
| update-instance-for-redefined-class   | переопределение классса     |
| update-instance-for-different-class   | изменение класса            |
| shared-initialize                     | создание экземпляра,        |
|                                       | переинициализация экземпляра| 
|                                       | переопределение классса,    |
|                                       | и  изменение класса         |

Каждая из пяти функций инициализации имеет основной метод по умолчанию. Например, метод по умолчанию для update-instance-for-different-class вызывает initialize-instance с соответствующими аргументами. В свою очередь, метод по умолчанию для initialize-instance выполняет инициализацию в соответствии с initargs и initforms на основе своих аргументов. Как правило, программисты специализируют эти обобощенные функции, предоставляя after-методы, а не первичные методы.

## 10.6 ОБЪЯВЛЕНИЕ ИМЕН INITARG КАК ДОПУСТИМЫХ

Все пять функций инициализации принимают initargs. Как упоминалось в разделе "Аргументы инициализации", стр. 160, имена initarg должны быть объявлены как допустимые. Если обобщенная функция вызывается с нераспознанным именем initarg, выдается сообщение об ошибке.

Параметр слота :initarg объявляет имена initarg допустимыми для всех пяти функций инициализации. Определение методов инициализации, которые используют параметры &key, объявляет имена параметров как допустимые имена initarg. Для каждого вызова обобщенной функции инициализации набор допустимых имен initarg зависит от соответствующих применимых методов инициализации:

| Выполняемая Задача          | Методы инициализации, которые объявляют имена Initarg допустимыми        |
|--------------------------------------------|------------------------------------------------------------|
| Создание экземпляра          | make-instance,                                    |
|                                            | initialize-instance,                                |
|                                            | shared-initialize                                   |
|Переинициализация экземпл| reinitialize-instance,                             |
|                                            | shared-initialize                                   |
|Изменение класса                |update-instance-for-different-class,        |
|                                            | shared-initialize                                   |
| Переопределение класса    |update-instance-for-redefined-class,       |
|                                            | shared-initialize                                   |