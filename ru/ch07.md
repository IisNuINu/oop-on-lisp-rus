## Определение элементов CLOS

В этой главе мы опишем, что происходит, когда вы определяете классы, методы и обобщенные функции. Мы обсуждаем следующие темы: порядок, в котором вы должны определять элементы CLOS, правила соответствия для лямбда-списков обобщенной функции и ее методов, объекты Lisp, которые представляют элементы CLOS, и отношения между этими объектами и их именами.

## 7.1 ПОРЯДОК ОПРЕДЕЛЕНИЯ ЭЛЕМЕНТОВ CLOS

CLOS достаточно гибок, позволяя вам определять элементы CLOS в различных порядках:

* При проектировании организации классов вы можете определять классы в любом порядке; вы можете определить класс до определения его суперклассов.
* Вы можете определять методы и обобщенные функции в любом порядке. Если вы определяете метод до определения обобщенной функции, CLOS автоматически создает обобщенную функцию. Лямбда-список обобщенной функции является производным от лямбда-списка метода; все остальные аспекты обобщенной функции по умолчанию. Если вы используете defgeneric позже, существующая обобщенная функция будет изменена.

Однако существуют некоторые зависимости от порядка:

* Прежде чем вы создадите экземпляр класса, этот класс и все его суперклассы должны быть определены* Прежде чем вы определите метод, который специализируется на классе, сам этот класс должен быть определен

## 7.2 КОНГРУЭНТНЫЕ ЛЯМБДА-СПИСКИ

Когда вычисляется defgeneric форма и не существует методов для обобщенной функции, defgeneric форма устанавливает шаблон параметров, которому должны следовать все методы. Если метод определен до того, как была вычислена defgeneric форма, этот метод устанавливает шаблон. Шаблон параметра является производным от лямбда-списка формы defmethod или defgeneric. В нем указывается количество обязательных параметров, количество необязательных параметров и то, используются ли &rest, &key или оба.

Как только шаблон установлен, если вычисляется какая-либо форма defmethod или форма defgeneric, которая не соответствует шаблону, CLOS сигнализирует об ошибке. Чтобы соответствовать шаблону, необходимо соблюдать следующие правила соответствия CLOS:

* Количество требуемых параметров должно быть таким же, как в установленном шаблоне.
* Количество необязательных параметров должно быть таким же, как в установленном шаблоне. Методы могут предоставлять значения по умолчанию для необязательных параметров, но defgeneric форма не может.
* Если установленный шаблон использует &rest или &key, все методы и форма defgeneric должны использовать &rest, или &key, или оба.

Параметры ключевых слов обрабатываются особым образом. Форма defgeneric может указывать требование относительно параметров &key, независимо от того, был ли шаблон параметров установлен до того, как была оценена форма defgeneric. Здесь мы излагаем правила для параметров ключевых слов, а затем объясняем их далее.

* Если в форме defgeneric указан &key, его набор параметров ключевого слова должен быть принят каждым из методов. Другими словами, в форме defgeneric указывается минимальный набор ключевых слов, которые должны быть приняты всеми методами. Методы могут принимать ключевые слова, явно называя их &key, используя &rest, а не &key, или указывая &allow-other-keys.
* Каждый метод может называть параметры &key в дополнение к набору, указанному в форме defgeneric; единственное требование состоит в том, что все методы должны принимать минимальный набор, указанный в defgeneric.

Для обобщенной функций, использующих параметры &key, аргументы ключевого слова проверяются на достоверность при вызове обобщенной функции. Набор принятых ключевых слов контролируется формой defgeneric и применимыми методами. Аргумент ключевого слова принимается вызовом обобщенной функции, если он принят формой defgeneric или одним или несколькими применимыми методами.

В общем случае обобщенная функция передает все свои аргументы каждому вызываемому ею методу. Тем не менее, ошибка не выдается, если обобщенная функция вызывает метод с аргументом ключевого слова, который явно не принимается методом. Обобщенная функция проверяет достоверность аргументов ключевого слова; эта проверка не выполняется отдельными методами.

Если defgeneric форма или любой метод для обобщенной функции использует &allow-other-keys, все аргументы ключевого слова принимаются при вызове обобщенной функции.

Как правило, CLOS сигнализирует об ошибке, если определен метод или универсальная функция, которые не соответствуют этим правилам соответствия. Это может произойти в следующих ситуациях:

* Оценивается(вычисляется) defmethod или defgeneric форма, которая не соответствует установленному шаблону
* Вычисляется форма defmethod, которая не принимает минимальный набор аргументов ключевого слова, указанный формой defgeneric
* Вычисляется форма defgeneric, и существующий метод не принимает минимальный набор аргументов ключевого слова, указанный defgeneric формой


## 7.3 ОБЪЕКТЫ LISP, ПРЕДСТАВЛЯЮЩИЕ ЭЛЕМЕНТЫ CLOS

Когда вы используете defclass, возвращаемое значение является объектом класса. Аналогично, defgeneric возвращает объект обобщенной функции, а defmethod возвращает объект метода. Эти объекты Lisp являются внутренним представлением классов CLOS, обобщенных функций и методов.

При написании прикладных программ вам обычно не нужно иметь дело непосредственно с объектами Lisp, представляющими элементы CLOS. Вместо этого вы ссылаетесь на эти объекты по их именам. Например, когда вы используете defclass, вы создаете объект класса и даете ему имя. Позже вы будете ссылаться на класс по его имени — например, при использовании make-instance. Аналогично, вы ссылаетесь на обобщенную функцию по ее имени при ее определении (используя defgeneric), создании методов для нее (используя defmethod) и вызове ее.

Интерфейс программатора CLOS можно разделить на два отдельных уровня. Макросы defclass, defmethod и defgeneric находятся на "Макроуровень/уровне макросов", который имеет удобный синтаксис и позволяет вам работать с именами объектов. Макроуровень реализован в терминах "функционального уровня", который имеет дело с объектами, а не с именами. Большинство прикладных программ могут быть написаны полностью в терминах макроуровня. Функциональный уровень обеспечивает большую гибкость, такую как поддержка анонимных классов и обобщенных функций.

## 7.4 СОПОСТАВЛЕНИЕ МЕЖДУ ИМЕНАМИ И ОБЪЕКТАМИ

В этом разделе описываются взаимосвязи между именами элементов CLOS и объектами Lisp, которые их представляют.

### Классы

Когда вы используете defclass, возвращаемое значение является объектом класса. У этого объекта класса есть имя, которое является символом. На самом деле, есть две ассоциации между именем класса и объектом класса. Макрос defclass автоматически устанавливает обе эти ассоциации.

Одна ассоциация поддерживается самим объектом класса. Вы можете запросить у объекта класса его имя с помощью class-name и использовать (setf class-name) для изменения этой ассоциации:

<pre>
(class-name class-object) 
(setf (class-name class-object) symbol) 
</pre>

Когда вы используете defclass, возвращаемое значение является объектом класса. У этого объекта класса есть имя, которое является символом. На самом деле, есть две ассоциации между именем класса и объектом класса. Макрос defclass автоматически устанавливает обе эти ассоциации.

<pre>
(find-class symbol) 
(setf (find-class symbol) class-object) 
</pre>

Вы используете class-name, чтобы спросить "Как называется этот объект класса?", и вы используете find-class, чтобы спросить "Что это за объект класса с таким именем?"

![Рисунок 7.1: Связи между классом и его именем.](images/f07-01.jpg )**Рисунок 7.1: Связи между классом и его именем.**

На рисунке 7.1 показано, что эти две ассоциации независимы. Изменение класса, связанного с именем (поддерживаемым символом), не влияет на имя, связанное с классом (поддерживаемое объектом класса). Таким образом, две ассоциации могут стать несинхронизированными друг с другом.

### Обобщенные функции

Обобщенные функции именуются точно так же, как именуются обычные функции. Объект обобщенной функции хранится в функциональной ячейке символа; этот символ является именем обобщенной функции. Вы можете запросить символ для обобщенной функции, связанной с ним, используя symbol-function, и использовать (setf symbol-function), чтобы изменить эту ассоциацию.

Поскольку обобщенные и обычные функции называются одинаково, технология Common Lisp, заключающаяся в использовании пакетов для объединения связанных функций и символов, так же полезна для обобщенных функций, как и для обычных функций. Кроме того, один символ не может называть как обычную, так и обобщенную функцию.

В Lisp функции не обязательно должны иметь имена; вы можете использовать lambda для определения анонимной функции. CLOS не требует, чтобы обобщенные функции имели имена. Чтобы создать анонимную обобщенную функцию, вы можете использовать макрос generic-function. Он имеет тот же синтаксис, что и defgeneric, за исключением того, что в нем нет аргумента для имени обобщенной функции.

### Методы

Методы не имеют имен. Метод идентифицируется по обобщенной функции, которую он реализует, специализации его параметров и его квалификаторам. Редко вам понадобится прямой доступ к методу. Обычно вы просто определяете методы, и они автоматически вызываются generic dispatch procedure(процедурой общей  отправки). Одна ситуация, в которой вам необходимо получить доступ к методу, возникает, когда вы хотите использовать remove-method, чтобы разорвать связь между обобщенной функцией и методом. Мы приводим пример этого в разделе "Удаление Обобщенных функций и методов", стр. 136.

### Специализаторы параметров

CLOS различает имена специализаторов параметров и объекты, которые их представляют. В лямбда-списке defmethod отображаются только имена специализаторов параметров, тогда как операторы на функциональном уровне используют объекты специализатора параметров.

| Имя          | Соответствующий объект                 |
|--------------|----------------------------------------|
| имя класса   | объект класса с таким именем,          |
|              | который получается с помощью find-class|
| (форма eql)  |(объект eql), где объект - это          |
|              | результат оценки формы                 |

## 7.5 УДАЛЕНИЕ ОБОБЩЕННЫХ ФУНКЦИЙ И МЕТОДОВ

В этом разделе описывается, как "удалить(remove)" определение обобщенной функции или метода в смысле обеспечения того, чтобы она никогда не вызывалась.

### Обобщенные функции

Вы можете удалить метод, разорвав связь между объектом метода и обобщенной функцией. Хотя CLOS не предоставляет удобного макроса для этого, вы можете использовать remove-method и find-method, два оператора на функциональном уровне CLOS. Как упоминалось ранее, функциональный уровень имеет дело с объектами, а не с именами. Чтобы использовать эти операторы, мы должны получить доступ к объекту обобщенной  функции, объекту метода и объектам специализатора параметров. Синтаксис remove-method таков

### Методы

Вы можете удалить метод, разорвав связь между объектом метода и обобщенной функцией. Хотя CLOS не предоставляет удобного макроса для этого, вы можете использовать remove-method и find-method, два оператора на функциональном уровне CLOS. Как упоминалось ранее, функциональный уровень имеет дело с объектами, а не с именами. Чтобы использовать эти операторы, мы должны получить доступ к объекту обобщенной  функции, объекту метода и объектам специализатора параметров. Синтаксис remove-method таков

<pre>
(remove-method generic-function-object method-object) 
</pre>

Чтобы получить доступ к объекту обобщенной функции, используйте символ-функцию имени обобщенной функции. Чтобы получить доступ к объекту метода, используйте обобщенную функцию find-method. Синтаксис find-method таков

<pre>
(find-method generic-function-object 
             ({method-qualifier} *) 
             ({parameter-specializer-objects} *)) 
</pre>

Список объектов специализатора параметров должен содержать столько элементов, сколько имеется требуемых параметров. Неспециализированный требуемый параметр имеет класс с именем t в качестве специализатора параметров.

Здесь мы покажем пример удаления метода. Имена специализатора параметров - это имена классов, поэтому мы получаем доступ к объектам специализатора параметров с помощью findclass.

<pre>
;;; The method to remove 
(defmethod restore-product :before (sw (os genera)) 
   body) 

;;; Removing the method 
(let* ((generic-function (symbol-function 'restore-product)) 
       (method (find-method generic-function 
                            '(:before) 
                            (list (find-class 't) 
                                  (find-class 'genera))))) 
   (remove-method generic-function method)) 
</pre>