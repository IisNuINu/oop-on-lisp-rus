# Разработка простой Программы CLOS: Блокировки(Locks)

В этой главе демонстрируются возможности программирования с помощью CLOS, следуя примеру разработки прикладной программы. Мы начинаем с определения классов и настройки организации, отражающей, как классы связаны друг с другом. Затем мы определяем интерфейс, который определяет, как клиенты могут создавать объекты этих классов и манипулировать ими. Наконец, мы определяем реализацию; это код Lisp, лежащий в основе интерфейса. Интерфейс представляет собой набор обобщеных функций, а реализация состоит из методов для этих обобщенных функций. В интерфейсе указано, какие операции вы можете выполнять с этими объектами, а в реализации указано, как эти операции работают внутри.

В этой главе мы рассматриваем программу с разных точек зрения: мы проектируем и разрабатываем ее так, как это делает программист; мы используем ее так, как это делает клиент; и, наконец, мы анализируем, как взаимодействуют ее части, как это делает сам CLOS.

## 3.1 ОБЗОР БЛОКИРОВОК(LOCKING)

Целью этого примера приложения является реализация объектов-блокировок( locks—objects), которые используются для управления параллельным доступом к некоторому общему ресурсу. Например, на собрании желательно, чтобы в любой момент времени выступал только один человек. Выражение "Слово предоставляется мистеру Смиту" ясно дает понять, что "слово" (общий ресурс) защищено от одновременного использования другими людьми. Во всем этом примере мы используем термин "захват/seize" для описания акта закрепления(securing) или получения блокировки(lock), а "освобождение/release" означает отказ от блокировки.

Блокировки имеют смысл только в среде, где более одного процесса могут претендовать на ресурс в данный момент времени. Здесь процессы определяются как несколько независимых потоков управления в рамках одной среды Lisp. Блокировки используются для обеспечения согласованного доступа к общему ресурсу. Прежде чем получить доступ к ресурсу, процесс должен захватить(seize) связанную с ним блокировку(lock). По завершении процесса блокировка должна быть снята(release).

Мы признаем, что процессы не являются частью Common Lisp, и что этот пример программы не имел бы смысла в реализации Common Lisp, в которой нет нескольких процессов. Однако наша цель состоит не в том, чтобы разработать программу, которая работает во всех средах; скорее, мы хотим показать простой пример объектно-ориентированного стиля. Итак, даже если блокировки не будут полезны в вашей среде Common Lisp, пожалуйста, читайте дальше.

Мы называем блокировку "занятой/busy", если она была захвачена(seized), но еще не освобождена(released), и "свободной/free", если она доступна для захвата. Когда блокировка занята, процесс, который ее захватил, называется ее "владельцем/owner".

Мы будем реализовывать блокировки как объекты Lisp. Интерфейс к блокировкам должен включать в себя следующие операции:

	>  Create(Создать)         Создает новую блокировку.

	> Seize(Захватите)        Захватывает блокировку. В случае успешного выполнения возвращаемым значением является объект блокировки.

	> Release(Снять)          Снимает блокировку, если она принадлежит тому же процессу, который сейчас пытается 
	>                                  ее снять.

Существует много возможных типов блокировок, и мы хотим, чтобы наша программа блокировки была расширяемой, поскольку позже мы планируем поддерживать более сложные типы блокировок. Например, в конечном итоге нам может понадобиться блокировка, которая позволит избежать взаимоблокировок(deadlock situations). (Тупиковая ситуация(deadlock) возникает, когда один человек берет кусок масла  и тянется к ножу для масла в то же время, когда другой человек взял нож для масла и тянется к куску масла. Ни один человек не может получить масло и намазать его на хлеб, пока другой не закончит.)

Мы начнем с определения двух элементарных типов блокировок, которые позже мы можем использовать в качестве строительных блоков для других типов блокировок.

	> Simple lock(Простая блокировка)   У этого вида блокировки есть название. Блокировка либо занята, либо свободна.
 	>                                      Если блокировка занята, она отслеживает своего владельца, котороый является процессом.

	> Null lock(Нулевая блокировка)     У этого вида блокировки также есть имя, 
	> но она не отслеживает, занята она или свободна. По сути, нулевая блокировка 
	> всегда свободна. Нулевая блокировка поддерживает обычные операции блокировки, 
	> фактически не защищая себя от захвата другими владельцами. Этот вид блокировки 
	> позволяет программам последовательно работать с ресурсами, которые иногда нуждаются 
	> в защите от одновременного доступа, а иногда и нет. Программа выполняет все действия 
	> по захвату и снятию блокировки, и тип блокировки (будь то нулевой или другой вид) определяет, 
	> защищен ли ресурс.

## 3.2 ОПРЕДЕЛЕНИЕ ТИПОВ ОБЪЕКТОВ-КЛАССОВ

Теперь мы должны перевести описание нулевых блокировок и простых блокировок на язык CLOS. Перевод иллюстрирует

* Разработку программы, использующей наследование* Использование слотов для хранения информации о состоянии* Определение классов с помощью макроса defclass* Методы запросов для чтения и записи слотов* Присвоение слоту начального значения по умолчанию

### Выбор классов для представления блокировок

Хотя на первый взгляд кажется, что мы должны определить два класса (один для представления простых блокировок, а другой для представления нулевых блокировок), мы можем лучше использовать наследование, определив три класса в организации, показанной на рис. 3.1.

![Рисунок 3.1: Организация классов блокировок.](images/f03-01.jpg )**Рисунок 3.1: Организация классов блокировок.**

Классы simple-lock и null-lock включают lock в свое определение; мы говорим, что они построены на классе lock. Они оба наследуются от класса lock(блокировки). Вот напоминание о терминологии:

	> lock - это прямой суперкласс null-lock,
	> lock - это прямой суперкласс simple-lock.

	> null-lock - это прямой подкласс lock, 
	> simple-lock - это прямой подкласс lock.

Мы называем lock базовым классом. Термин "базовый класс" не имеет какого-либо конкретного технического значения (класс lock(блокировка) действует так же, как и любой другой класс), но он описывает назначение класса. Класс lock предназначен для того, чтобы быть основой всех блокировок; его цель - привнести характеристики, которые являются общими для всех блокировок. Основной характеристикой, общей для всех блокировок, является тот факт, что они являются блокировками. Создавая все классы блокировок для класса с именем lock, мы можем использовать (typep object 'lock), чтобы выяснить, является ли объект блокировкой.

Кроме того, как простые блокировки, так и нулевые блокировки имеют имена, поэтому "характеристика имени" предоставляется классом lock и наследуется всеми видами блокировок. Еще одна причина предоставления базового класса заключается в том, чтобы было удобно определять методы по умолчанию. Метод, присоединенный к базовому классу, является методом по умолчанию. Любой класс, который наследуется от базового класса, может выбрать использование метода по умолчанию, предоставить метод для переопределения метода по умолчанию или поддерживать дополнительное поведение, предоставляя метод before или after для работы с методом по умолчанию. Таким образом, мы определяем класс lock по трем причинам:

* Он позволяет нам использовать (typep object 'lock), чтобы проверить, является ли объект блокировкой
* Он добавляет характеристику имени ко всем блокировкам
* Он поддерживает поведение всех блокировок по умолчанию

Мы не предполагаем, что этот класс будет работать самостоятельно, поскольку мы не ожидаем создания его экземпляров. Класс lock не будет иметь полного набора методов для поддержки протокола блокировки.

### Использование defclass

Мы определяем класс lock следующим образом:

<pre>
(defclass lock () 
  ((name :initarg :name
         :reader  lock-name)) 
  (:documentation "The foundation of all locks."))
</pre>

Вычисление этой формы создает новый класс с именем lock с одним слотом с именем name. Он также создает обобщенную функцию lock-name и метод для lock-name, который позволяет вам считывать значение слота name(имени) любого объекта, тип которого lock. Здесь мы рассмотрим каждую часть определения класса и посмотрим, что она делает: 
	>  defclass            Макрос для определения нового класса,

	>  lock                имя нового класса.

	>  ()                  Список прямых суперклассов. Список здесь пуст, 
	>                      потому что мы не указали никаких суперклассов для lock(блокировки).

	> ((name :initarg :name :reader lock-name)) 
	>                      Список спецификаторов слотов. Каждый спецификатор слота может быть задан в виде символа
	>                      (название слота) или списка (название слота, за которым следуют параметры слота). Здесь у нас
	>                      есть один слот с именем name, с этими двумя опциями слота:

	>                      :initarg :name 
	>                          Эта опция позволяет инициализировать значение этого слота при создании экземпляров. 
	>                          Чтобы инициализировать слот name, мы можем задать ключевое слово :name аргумент 
	>                          при создания экземпляра. (Обратите внимание, что make-instance - это функция CLOS 
	>                          для создания новых экземпляров; мы обсуждаем ее в разделе "Использование make-instance
	>                          или конструкторов", стр. 24.)
	>                      :reader lock-name 
	>                          Эта опция позволяет считывать значение этого слота с помощью обобщенной функции lock-name.
	>                          Этот параметр слота заставляет систему CLOS генерировать метод для lock-name, lock-name 
	>                          называется обобщенной функцией чтения.

	> (:documentation "The foundation of all locks.") - "Основа всех блокировок" 
	>                       Это параметр класса; он относится к классу в целом. Параметр :documentation  предоставляет строку
	>                       документации, описывающую назначение класса. Вы можете получить строку документации класса, 
	>                       вызвав функцию документации.

### Наследование от суперкласса

Определение нулевой блокировки(null-lock) иллюстрирует, как определить класс, построенный на суперклассе. Здесь класс null-lock построен на одном суперклассе, классе lock.

<pre>
(defclass null-lock (lock)
  () 
  (:documentation "A lock that is always free.")) 
</pre>

Класс null-lock наследует следующее от своей блокировки суперкласса:

	> name slot               Каждый экземпляр null-lock имеет слот с именем name.

	> :initarg :name slot option 
	>                        Вы можете инициализировать слот имени при создании экземпляра null-lock.

	> lock-name method 
	>                        Вы можете использовать читатель lock-name в экземплярах null-lock для считывания
	>                        значения слота name.. 

### Accessors(Методы доступа)

Теперь мы определяем класс simple-lock. Простая блокировка отслеживает, занята она или свободна. Определение simple-lock предоставляет владельца слота, который указывает, занята ли простая блокировка или свободна, запоминая, какому процессу в данный момент принадлежит блокировка. Для свободной блокировки в ее собственном слоте установлено значение nil, а для занятой блокировки в слоте владельца установлен процесс, которому в данный момент принадлежит блокировка.

<pre>
(defclass simple-lock (lock) 
  ((owner :initform nil :accessor lock-owner)) 
  (:documentation "A lock that is either free or busy.")) 
</pre>

Класс simple-lock наследует от lock точно такие же характеристики и поведение, как и null-lock. Обратите внимание, что класс simple-lock наследует имя слота от своего суперкласса и что он добавляет свой собственный слот, слот owner(владельца). Определение simple-lock также включает в себя два новых варианта слотов:

	> :initform nil

	>                    Этот параметр слота позволяет задать начальное значение по умолчанию для слота.
	>                    Здесь начальное значение по умолчанию для слота владельца равно nil. Это означает, 
	>                    что при создании простой блокировки она является свободной(free).

	> :accessor lock-owner 
	>                    Эта опция слота позволяет вам получить доступ к слоту owner для считывания или записи значения 
	>                    слота.  CLOS генерирует две обобщенные функции: обобщенную функцию чтения, называемую 
	>                    lock-owner, и соответствующую обобщенную функцию записи. CLOS также определяет методы для 
	>                    каждой из этих обобщенных функций. Таким образом, вы можете прочитать значение слота owner с 
	>                    помощью обобщенной функции чтения lock-owner, и вы можете записать значение слота с помощью 
	>                    setf с lock-owner.

Имя этой обобщенной функции чтения - символ lock-owner. Чтобы вызвать средство чтения, используйте обычный синтаксис вызова функций, например: 
<pre>
(lock-owner lock-object) 
</pre>

Имя обобщенной функции записи - это список (set flock-owner).
Этот список не является формой, подлежащей оценке/вычислению; это имя функции — другими словами, это "спецификатор функции". Чтобы вызвать средство записи, используйте синтаксис setf следующим образом::
<pre>
(setf (lock-owner lock-object) new-value) 
</pre>
Параметры слота :reader и :accessor аналогичны. Параметр слота  :reader  генерирует метод только для обобщенной функции считывателя. Опция слота :accessor  генерирует два метода: один для чтения и один для записи. Термин "обобщенная функция доступа(accessor generic function)" является обобщающим термином, который включает в себя как средства чтения, так и средства записи. Обычно вы определяете средство чтения, если хотите прочитать слот, и оба вида средств доступа, если хотите читать и записать слот. Можно определить только запись (с помощью опции слота :writer), но это делается редко.

### Слоты, используемые в классах блокировок

Здесь мы рассмотрим, как мы намерены использовать слоты name и owner, и соотнесем это с параметрами слотов, выбранными для слотов:

	> name            У каждой блокировки есть имя. Мы инициализируем имя при создании блокировки, передавая его в 
	>                     качестве аргумента make-instance. Мы не предоставляем начальное значение по умолчанию для слота
 	>                     name, потому что это не имело бы смысла; каждой блокировке нужно имя, соответствующее ее назначению,
	>                     поэтому ни одно имя по умолчанию не подходит в достаточном количестве случаев, чтобы оправдать
	>                     дефолт( worth-while).

	> owner           У каждой простой блокировки есть владелец. Слот владельца всегда инициализируется равным nil при 
	>                    создании простой блокировки. Мы не разрешили инициализировать слот аргументом make-instance, потому
	>                    что мы хотим, чтобы все вновь созданные простые блокировки были свободными.	>                    Мы можем использовать считыватель  lock-owner, чтобы узнать владельца простой блокировки. Мы можем
 	>                    использовать метод записи, соответствующий lock-owner, чтобы изменить владельца простой блокировки.
 	>                    Имя метода записи  - (setf lock-owner). Этот метод записи будет полезен внутри методов захвата(seize), но мы
	>                    не предполагаем, что он будет частью интерфейса.

Параметры слота :reader и :accessor аналогичны. Параметр :слот для считывателя генерирует метод только для универсальной функции считывателя. Опция :слот для доступа генерирует два метода: один для чтения и один для записи. Термин "универсальная функция доступа" является обобщающим термином, который включает в себя как средства чтения, так и средства записи. Обычно вы определяете средство чтения, если хотите прочитать слот, и оба вида средств доступа, если хотите прочитать и записать слот. Можно определить только запись (с помощью опции :writer slot), но это делается редко.

В отличие от этого, :initform предоставляет начальное значение по умолчанию для слота. Слот инициализируется значением, указанным в параметре :initform, вместо того, чтобы инициализироваться аргументом make-instance. Мы использовали :initform для слота owner(владельца).

## 3.3 СОЗДАНИЕ НОВЫХ ОБЪЕКТОВ-ЭКЗЕМПЛЯРОВ(OBJECTS-INSTANCES)

Написанный нами код будет казаться более реальным, если мы создадим несколько блокировок и будем манипулировать ими. В следующих разделах мы создадим экземпляры simple-lock и null-lock и поэкспериментируем с ними.

### Использование make-instance или конструкторов

Функция для создания новых экземпляров называется make-instance. Здесь мы используем make-instance для создания нулевой блокировки и инициализации ее слота имени как  "Null lock"(Нулевая блокировка).:
<pre>
(setq *null-lock* 
      (make-instance 'null-lock :name "Null lock")) 
;=> #<NULL-LOCK {23FEFD01}>
</pre>

Здесь мы используем make-instance для создания простой блокировки и инициализации ее слота имени как "Simple Lock".:
<pre>
(setq *simple-lock* 
      (make-instance 'simple-lock :name "Simple lock"))
;=> #<SIMPLE-LOCK {240CBD21}>
</pre>
Вы можете использовать make-instance для создания экземпляра класса. Первый аргумент - это имя класса. Следующие аргументы являются initargs, за которыми следуют значения. Здесь initarg :name используется для инициализации слота name значением.

Мы рекомендуем вам определить функции конструктора, которые будут использоваться клиентами для создания экземпляров. Конструктор - это специально разработанный способ создания экземпляра данного класса; его имя обычно описывает тип экземпляра, который он создает. Конструктор предоставляет более абстрактный внешний интерфейс, чем make-instance, поскольку его имя описывает его назначение более высокого уровня (создание нулевой блокировки), а не его внутреннюю реализацию (создание экземпляра класса null-lock).

Еще одним преимуществом является то, что конструктор может иметь требуемые аргументы. Напротив, все аргументы для make-instance, за исключением первого, являются необязательными. Мы могли бы предпочесть потребовать, чтобы пользователи инициализировали имя блокировки.

Вы можете определить конструктор, используя defun и вызывать make-instance в теле функции. Например, здесь мы определяем два конструктора, один для создания нулевой блокировки, а другой для создания простой блокировки:

<pre>
(defun make-null-lock (name) 
   (make-instance 'null-lock :name name)) 

(defun make-simple-lock (name) 
   (make-instance 'simple-lock :name name)) 
</pre>

Мы будем рекламировать make-null-lock и make-simple-lock как часть интерфейса, который будет использоваться клиентами при создании новых блокировок. Таким образом, вместо использования make-instance клиенты используют конструкторы:

<pre>
(make-null-lock "Null lock") 
(make-simple-lock "Simple lock") 
</pre>

### Использование Методов Доступа(Accessors)

Мы можем поэкспериментировать с обобщенными функциями reader и writer, которые были автоматически сгенерированы с помощью опций :reader и :accessor в defclass.

У нас есть обобщенная функция чтения lock-name и метод для нее. Этот метод присоединен к классу lock и наследуется как null-lock, так и simple-lock, поскольку оба они построены на lock.

<pre>
(lock-name *null-lock*)              ;=>"Null lock"
(lock-name *simple-lock*)            ;=>"Simple lock"
</pre>

У нас также есть обобщенная функция чтения с именем lock-owner и соответствующая обобщенная функция записи с именем (setf lock-owner). У каждого из этих аксессуаров есть метод для него, прикрепленный к классу simple-lock.
Мы можем использовать эти аксессуары на экземплярах simple-lock.

В следующем примере мы используем lock-owner для вновь созданной простой блокировки, которая показывает, что начальное значение слота owner равно nil. Затем мы вызываем универсальную функцию записи, чтобы установить значение слота равным 3401, и снова вызываем считыватель, чтобы убедиться, что значение действительно равно 3401.

<pre>
(lock-owner *simple-lock*)                    ;=>NIL
(setf (lock-owner *simple-lock*) 3401)        ;=>3401
(lock-owner *simple-lock*)                    ;=>3401
</pre>
Мы не можем использовать lock-owner или (setf lock-owner) для экземпляров null-lock. Ни один метод не привязан к null-lock для этих обобщенных функций, и null-lock не наследует для них никаких методов. Поэтому, если мы попытаемся использовать эти обобщенные функции с экземпляром null-lock, CLOS выдаст сообщение об ошибке "нет применимого метода".

<pre>
(lock-owner *null-lock*) 
ERROR: No applicable method for LOCK-OWNER 
for the argument #<NULL-LOCK 802335> 

(setf (lock-owner *null-lock*) 3401) 
ERROR: No applicable method for (SETF LOCK-OWNER) 
for the argument #<NULL-LOCK 802335> 
</pre>

### ### Запрос блокировки(Lock) о ее типе 

Теперь, когда у нас есть экземпляры, мы можем продемонстрировать, что CLOS аккуратно интегрирован с существующей иерархией типов Common Lisp. Имена всех классов являются общими спецификаторами типов Lisp, поэтому вы можете использовать type-of и type для запроса объекта Lisp о его типе. Тип экземпляра - это его класс.

<pre>
(type-of *null-lock*)                          ;NULL-LOCK
(type-of *simple-lock*)                        ;SIMPLE-LOCK

(typep *simple-lock* 'simple-lock)             ;T
(typep *simple-lock* 'lock)                    ;T
(typep *simple-lock* 't)                       ;T
</pre>
Мы используем показанный typep, чтобы указать, что блокировка `*simple-lock*` относится не только к типу simple-lock, но также к типу lock и типу t.
Это полностью аналогично тому, как работает type для других спецификаторов типов Common Lisp, когда один тип является подтипом другого. Например, объект типа integer также имеет тип number, поскольку integer является подтипом number. Аналогично, все объекты относятся к типу t.

Значение этого связано с наследованием. Экземпляр `*simple-lock*` относится к типам simple-lock, lock и т. Д. Это означает, что каждый из этих классов может вносить свой вклад в структуру и поведение `*simple-lock*`. Таким образом, мы можем использовать typep, чтобы выяснить, влияет ли конкретный класс на поведение экземпляра.

Точно так же, чтобы узнать отношение одного класса к другому, мы можем использовать subtypep с классами:

<pre>
(subtypep 'simple-lock 'lock)                  ;T   T
(subtypep 'null-lock   'lock)                  ;T   T
(subtypep 'null-lock   'simple-lock)           ;NIL T
</pre>

Результаты подтверждают то, что мы уже знали: простая блокировка — это подтип блокировки, нулевая блокировка — подтип блокировки, а нулевая блокировка — не подтип простой блокировки.

Первое значение subtypep указывает, является ли первый аргумент подтипом второго аргумента. Второе значение subtypep указывает на достоверность первого значения. Если взаимосвязь между двумя типами неизвестна, значения будут равны nil nil. Это может случиться для типов Common Lisp, но никогда не может случиться для двух классов. Когда оба аргумента subtypep являются именами классов, вторым значением всегда будет t.

## 3.4 ОПРЕДЕЛЕНИЕ ОБОБЩЕННЫХ-ИНТЕРФЕЙСНЫХ ФУНКЦИЙ 

Мы уже завершили одну часть интерфейса, предоставив клиентам возможность создавать новые блокировки. У каждого типа блокировки есть свой конструктор для создания новой блокировки. Конструктор make-simple-lock создает простую блокировку, а make-null-lock создздает null-lock блокировку. Конструкторы — это обычные функции, а не обобщенные функции.

После того, как блокировка создана, она должна поддерживать две операции блокировки: захват и освобождение. Мы будем реализовывать эти операции как обобщенные функции.

### Использование defgeneric для документирования интерфейса

Мы можем задокументировать интерфейс каждой обобщенной функции, используя форму defgeneric. Интерфейс состоит из трех концептов, каждый из которых представлен в родовой форме:

| Интерфейс                    | Описано defgeneric                |
|--------------------------------------|----------------------------------------------|
|Ожидаемые аргументы   | Параметры в лямбда-списке  |
|Что он делает                 | Строка документации            |
|Возвращаемые значения | Строка документации            |

Вы можете использовать defgeneric для документирования обобщенной функции в интересах программистов, которые вызывают ее или определяют для нее дополнительные методы. Форма defgeneric также устанавливает рекомендации для обобщенной функции, которым должны следовать любые будущие расширения программы.

Форма defgeneric описывает обобщенную функцию в целом. Формы defgeneric для seize(захвата) и release(освобождения) предоставляют текст на английском языке в строке документации, описывающей общую цель обобщенной функции. Строка документации не является функциональной частью программы; на самом деле она ничего не делает. Однако без этой документации людям, которые хотели бы прочитать код и узнать, как работает программа, пришлось бы смотреть на определения методов и пытаться понять общее назначение обобщенной функции на основе набора методов.

<pre>
(defgeneric seize (lock) 
   (:documentation 
    "Seizes the lock. 
     Returns the lock when the operation succeeds. 
     Some locks simply wait until they can succeed, while 
     other locks return NIL if they fail.")) 

(defgeneric release (lock Soptional failure-mode) 
   (:documentation 
    "Releases the lock if it is currently owned by this process. 
     Returns T if the operation succeeds. 
     If unsuccessful and failure-mode is :no-error, returns NIL. 
     If unsuccessful and failure-mode is :error, signals an error. 
     The default for failure-mode is :no-error."))
</pre>

В Лиспе лямбда-список — это часть функции, которая указывает имена для параметров функции. Форма defgeneric для seize указывает один обязательный параметр (с именем lock), а форма defgeneric для release указывает один обязательный параметр с именем lock и один необязательный параметр с именем failure-mode.

Строки документации выглядят несколько неуклюже, как показано, но есть причина выровнять их по левому краю. Если бы мы сделали для них отступ, функция документирования сделала бы для них отступ, а это не то, что нам нужно. Нет необходимости выравнивать первую строку строки документации по левому краю, но мы выбираем этот стиль для строк, которыедлиннее одной строки, просто чтобы соответствовать следующим строкам.

### Создание обобщенной функции

Форма defgeneric создает новую обобщённую функцию. Использование defgeneric — не единственный способ определить обобщенную функцию. Другой способ — определить метод. Если вы определяете метод для обобщенной функции, а сама эта функция еще не существует, CLOS автоматически создает ее. Лямбда-список обобщенной  функции получается из лямбда-списка метода. Вы можете использовать defgeneric позже, чтобы указать лямбда-список обобщенной функции, строку документации и любые другие параметры; CLOS модифицирует существующую обобщенную функцию в соответствии с вашим новым определением.

Хотя нет необходимости явно документировать интерфейс с помощью defgeneric, как мы делаем здесь, это часто облегчает другим людям изучение того, как работает ваша программа, и дает рекомендации для программистов, которые хотят расширить программу.

### Создание шаблона параметра

Форма  defgeneric определяет шаблон параметра, которому должны следовать все методы этой обобщенной функции. Таким образом, лямбда-список формы defgeneric является функциональной частью программы. CLOS требует, чтобы лямбда-списки всех методов и форма определения обобщенной функции имели одинаковую «форму» или были «конгруэнтны». Лямбда-списки должны иметь одинаковое количество обязательных параметров и одинаковое количество необязательных параметров. Специальные правила определяют, что означает конгруэнтность для ключевых параметров(&key). Подробности см. в разделе «Конгруэнтные лямбда-списки», стр. 132.

### Проблемы Именования

Имена параметров обобщенной функции должны подразумевать класс объектов, с которыми может работать обобщенная функция. Здесь мы используем имя "lock", чтобы указать, что обобщенную функцию можно использовать для любой блокировки. Бывает, что «lock» также является именем класса, но нет требования, чтобы имена параметров универсальной функции были именами классов.

То же самое относится и к имени обобщенной функции. Имя должно что-то говорить нам о назначении функции и должно отвечать на вопрос: «Насколько она общая/универсальна?» Например, позже мы могли бы добавить в протокол обобщенную функцию для сброс(resetting) блокировки, что было бы полезно для отладки; процесс может сбросить блокировку, принадлежащую другому процессу. Название «reset-lock» было бы лучше, чем просто «reset», которое носит слишком общий характер. Одна потенциальная ловушка слишком общего имени для обобщенной  функции связана с требованием, чтобы все методы для обобщенной  функции имели конгруэнтные лямбда-списки. Если мы назовем обобщенную функцию "reset", и несколько разных программ захотят написать методы для сброса различных типов устройств, вполне вероятно, что разные программы захотят установить разные шаблоны аргументов, что недопустимо.

### Протокол блокировки

Обобщенная функция определяет интерфейс одной операции. Это ценная концепция на начальной фазе проектирования, потому что она помогает вам сосредоточиться на интерфейсе, оставляя детали реализации на потом. Это также ценно во время обслуживания программы. Набор отдельных форм, появляющихся в начале программы, может иметь большое значение для документирования ролей отдельных фрагментов программы.

Обобщенные функции, взятые вместе, можно назвать протоколом. Протокол охватывает полное поведение объектов в программе. Например, основание протокола блокировки заключается в следующем:	>    Должны быть средства для создания новых блокировок, и все существующие блокировки должны поддерживать
	>    операции захвата(seize) и освобождения(release).

Протокол блокировки должен предоставить больше информации о семантике каждой операции: ее аргументы, что она делает, и её возвращаемые значения. Для обобщенных функций эта информация содержится в отдельных формах defgeneric.

Идея протокола дает нам еще один взгляд на прикладную программу. Вопрос "Что такое блокировка?" Можно ответить с помощью «Блокировка(lock) - это объект, который подчиняется протоколу блокировки». Теперь у нас есть оперативное определение блокировок. Эта перспектива допускает естественное и точное описание null lock(нулевой блокировки): «Нулевая блокировка подчиняется протоколу блокировки, не защищая ничего от одновременного доступа». Обратите внимание, что экземпляр класса базовой блокировки не является блокировкой по этому определению, поскольку он не подчиняется протоколу блокировки.

Когда мы определяем блокировки по протоколу, которому они подчиняются, мы используем внешнюю точку зрения. Мы могли бы взять внутреннюю точку зрения, определив блокировку как «экземпляр любого класса, который включает в себя класс блокировки(lock)». Каждая из этих перспектив является действительной и полезной сама по себе. Разработчики программного обеспечения, которые используют блокировки выгоды от внешней точки зрения. Реализатор Блокриовок берет на себя внутреннюю точку зрения при определении классов и методов, которые составляют программу блокировки. Однако реализатор не может пренебрегать внешней точкой зрения, поскольку реализация должна гарантировать, что блокировки следуют за рекламируемым протоколом блокировки.

Мы обсуждаем не формализованную концепцию протокола, а скорее неформальное представление о том, что программисты считают полезным при разработке и описании объектно-ориентированных программ. Clos не включает в себя какой-либо механизм для обеспечения соблюдения протоколов.

## 3.5 ОПРЕДЕЛЕНИЕ РЕАЛИЗАЦИИ — МЕТОДЫ

В этом разделе мы определяем методы для null и simple блокировок. Мы подробно обсуждаем методы, в том числе когда вызывается метод, какие аргументы он получает и как метод может предоставить значение по умолчанию для аргумента. На протяжении всего обсуждения помните о различиях между терминами «аргумент» и «параметр». Вы предоставляете аргументы лисп-функции при ее вызове и именуете параметры функции при ее определении. В теле функции вы можете ссылаться на аргумент, используя соответствующий параметр. Таким образом, параметр — это переменная, которая привязывается к аргументу во время выполнения функции. Подробнее о различных типах параметров см.Steele, Common LISP: Язык, страницы 59-61.

Обобщенные функции и методы используют ту же терминологию. Лямбда-список формы defgeneric именует параметры обобщенной функции, а лямбда-список формы defmethod именует параметры метода.

### Методы нулевых блокировок(Null Locks)

Цель реализации нулевых блокировок — отключить блокировку в программе, выполняющей операции блокировки. Программа выполняет свою обычную процедуру захвата и освобождения без необходимости в специальном «режиме отладки/debug mode», который отключает блокировку в исключительных обстоятельствах. Методы существуют для того, чтобы нулевую блокировку можно было использовать везде, где программа ожидает блокировку.

Методы операций блокировки нулевых блокировок просты. Это первичные методы, и они выполняют всю работу обобщенных функций, которые они реализуют. Каждый метод придерживается интерфейса своей обобщенной функции. Поскольку эти методы на самом деле ничего не захватывают и не освобождают, они всегда успешны и всегда возвращают значение, указывающее на успех.

<pre>
(defmethod seize ((l null-lock)) 
   l)                                   ;return lock, no waiting 

(defmethod release ((l null-lock) &optional failure-mode) 
   (declare (ignore failure-mode))      ;never fails for null locks 
   t) 
</pre>

### Лямбда-список метода

В объектно-ориентированной программе важно понимать область действия метода. Когда применим этот метод? Лямбда-список указывает область действия метода с помощью специализированных параметров, которые связывают метод с одним или несколькими классами. Метод применим, когда аргументы обобщенной функции удовлетворяют требованиям специализированных/указанных параметров в лямбда-списке.

На рис. 3.2 показан лямбда-список метода release, который имеет один специализированный параметр.

![Рисунок 3.2: Специализированный параметр в лямбда-списке.](images/f03-02.jpg)**Рисунок 3.2: Специализированный параметр в лямбда-списке.**

Лямбда-список метода — это обычный лямбда-список с одним отличием. Он различает два типа параметров:

* Специализированный параметр указывает на применимость метода, указывая класс аргумента, для которого применяется этот метод. Специализированный параметр — это список, содержащий переменную и имя класса. Говорят, что параметр специализируется на этом классе. Вы можете специализировать любой из обязательных параметров, но не &optional, &key или &rest параметры.* обычный параметр не указывает на применимость метода; он просто дает переменную, которая должна быть привязана к аргументу обобщенной функции.

Хотя специализированный параметр имеет тот же синтаксис, что и параметр по умолчанию, двусмысленности нет. В методах обязательные параметры могут быть специализированными, но могут не иметь значений по умолчанию. Необязательные параметры не могут быть специализированными, но могут иметь значения по умолчанию.

### Применимость метода

При вызове обобщенной функции CLOS выбирает набор применимых методов. Метод применим, если аргументы обобщенной функции соответствуют специализированным параметрам этого метода. Чтобы аргумент совпадал, он должен иметь тип, указанный классом параметра. Сюда входят экземпляры самого класса и экземпляры классов, созданных на основе этого класса (подклассы).

В лямбда-списке на рис. 3.2 специализированным является только первый параметр. Специализирующим параметром является класс с именем null-lock, указывающий, что метод применим, когда первый аргумент обобщенной функции является экземпляром null-lock или некоторым построенным на нем классом. Другими словами, следующее выражение должно быть истинным:

<pre>
(typep argument 'null-lock) 
</pre>

Иногда мы говорим о классе, «наследующем метод». Это естественный способ описать тот факт, что экземпляр может использовать метод, присоединенный к суперклассу своего класса. Эта модель позволяет нам изобразить связь между классом и методом, присоединенным к этому классу.

Важно иметь в виду, что метод может содержать любое количество специализированных параметров. Метод может иметь ссылки более чем на один класс; он связан со всеми классами, которые используются в качестве специализаторов для параметров. Мы обсуждаем этот стиль программирования в разделе «Мультиметоды» на стр. 75. Для методов, которые имеют более одного специализированного параметра, модель «применимости метода» более подходит, чем модель «наследования метода». Мы можем выразить правило применимости метода в одном предложении:

|**Правило применимости метода:**                       |
|-----------------------------------------------------------------------------|
|Метод применим, если каждому из его специализированных параметров удовлетворяет   |
 |соответствующий аргумент обобщенной функции.                                                             |

Многие методы имеют только один специализированный параметр. Методы доступа попадают в эту категорию, как и все методы, которые мы определяем в программе блокировки. Мы будем продолжать использовать модель «наследования метода» для методов, имеющих только один специализированный параметр.

### Аргументы, передаваемые методу

Когда CLOS выбирает реализацию обобщенной функции и вызывает методы, она передает все аргументы, предоставленные обобщенной функцией, каждому методу. Переменные в лямбда-списке привязаны к аргументам. В теле метода вы можете использовать переменные, привязанные к объектам, используя обобщенные функции или обычные функции для управления ими.

Например, когда release вызывается для экземпляра null-lock, вызывается метод, который мы определили для release. Переменная 1 привязана к первому аргументу обобщенной функции, блокировке.

Переменная failure-mode привязана ко второму аргументу. Метод предпочитает игнорировать эту переменную, поскольку в ней нет необходимости. Несмотря на то, что метод не использует этот аргумент, он должен явно разрешить его, включив для него параметр в лямбда-список. Это необходимо, потому что метод получает все аргументы, переданные обобщенной функции.

### Блокировки и процессы

Прежде чем определить методы для простых блокировок, нам нужно дальше обсудить процессы. В нашем примере предполагается, что процессы на самом деле не выполняются одновременно, а чередуются, как это происходит при использовании одного процессора с квантованием времени.

Поскольку Common Lisp в настоящее время не включает функции для работы с процессами, для целей этого примера мы предполагаем три примитива, которые поддерживают несколько процессов в общем адресном пространстве. Эти примитивы не являются частью CLOS или Common Lisp.

	>  without-process-preemption &body body 
	>           Тело этой специальной формы выполняется без риска прерывания процесса планировщиком.
	>           Другими словами, тело является атомарной операцией по отношению к планированию процесса.

	>  process-wait reason function &rest arguments 
	>            This function is the primitive for waiting. The current process waits until the
	>            application of function to arguments returns non-nil. At that time process-wait
	>            returns the values of applying function to arguments. The argument reason is a
	>            string describing the reason for waiting. 	>            Эта функция является примитивом для ожидания. Текущий процесс ожидает, пока применение
	>            функции к аргументам не вернет значение, отличное от нуля. В это время process-wait возвращает
	>            значения применения функции к аргументам. Аргумент reason(Причина) — это строка, описывающая
 	>            причину ожидания.

	>  *current-process* 
	>               Значение этой переменной является идентификатором процесса, который выполняется в 
	>               данный момент.

Теперь мы определим макрос setf-if, который мы будем использовать в методах seize(захвата) и release(освобождения). Макрос setf-if сравнивает значение обобщенной переменной с ожидаемым значением. Если эти значения совпадают, setf-if устанавливает значение переменной в новое значение и возвращает t; в противном случае он не изменяет значение и возвращает nil. setf-if использует without-process-preemption(без вытеснения процесса), чтобы гарантировать, что операции происходят атомарно, чтобы гарантировать, что другой процесс не сможет изменить переменную между временем, когда setf-if проверяет переменную, и временем, когда он ее изменяет.

<pre>
;; If value of place is old-value, set it to new-value 
;; Return t if the setf worked, nil otherwise 
(defmacro setf-if (place old-value new-value) 
   `(without-process-preemption         ;do atomically 
     (cond ((eql  ,place ,old-value) 
            (setf ,place ,new-value) 
            t) 
           (t nil)))) 
</pre>

Обратите внимание, что реальная многопроцессорная система будет включать собственное определение операции setf-if, которая, несомненно, будет более эффективной и лучше справится с вопросами порядка вычисления.

### Методы Simple Locks(простых блокировок)

Во-первых, мы определяем check-for-mylock для проверки распространенной ошибки, при которой процесс пытается захватить блокировку, которой он уже владеет. Следующий метод проверки моей блокировки сигнализирует об ошибке в этой ситуации. Мы будем использовать check-for-mylock в методе seize(захвата).

<pre>
(defmethod check-for-mylock ((l simple-lock) process) 
   (when (eql (lock-owner 1) process) 
      (error "Can't seize ~A because you already own it." 1))) 
</pre>

Следующий метод захвата повторяется с do до тех пор, пока setf-if не завершится успешно. На каждой итерации setf-if определяет, свободна ли блокировка, используя lock-owner, чтобы узнать, равен ли слот владельца nil. Если блокировка свободна, setf-if устанавливает ее владельца на текущий процесс, тем самым захватывая его. (Это делается атомарно с помощью setf-if.) Если блокировка не свободна в первый раз, вызывается process-wait для ожидания, пока владелец блокировки не вернет nil, что указывает на то, что блокировка в данный момент свободна. Затем форма setf-if пытается снова.

<pre>
(defmethod seize ((l simple-lock)) 
   (check-for-mylock l *current-process*) 
   (do () 
       ((setf-if (lock-owner l) nil *current-process*)) 
      (process-wait "Seizing lock" 
                    #'(lambda () (null (lock-owner l))))) 
   l) 
</pre>

Обратите внимание, что тело do не обязательно, потому что без него сам end-test будет многократно повторяться до тех пор, пока setf-if не завершится успешно. Проблема в том, что setf-if может использовать много машинного времени, прежде чем, наконец, добьется успеха. Напротив, использование process-wait в теле do позволяет запускать другие процессы и пробует setf-if только тогда, когда есть вероятность успеха.

Следующий метод оrelease(свобождения) использует setf-if как удобный способ убедиться, что процесс, пытающийся снять блокировку, является текущим владельцем блокировки. В противном случае setf-if не освобождает блокировку.

<pre>
(defmethod release ((l simple-lock) 
                    &optional (failure-mode :no-error)) 
   (or (setf-if (lock-owner l) *current-process* nil) 
       (ecase failure-mode 
         (:no-error nil) 
         (:error (error "~A is not owned by this process" l))))) 
</pre>

### Установка необязательных(Optional) параметров методов по умолчанию

Лямбда-список метода release для simple-lock(простой блокировки) дает значение по умолчанию для необязательного параметра failure-mode(режим отказа). Лямбда-список метода может предоставлять значения по умолчанию для любых необязательных параметров, но не для обязательных параметров. Форма defgeneric может не предоставлять значение по умолчанию для любого параметра в своем лямбда-списке.

## 3.6 СПЕЦИАЛИЗАЦИЯ ПОВЕДЕНИЯ БЛОКИРОВОК

На данный момент мы выполнили требования приложения блокировки. Интерфейс определен, и реализация завершена. В этом разделе мы добавляем некоторые последние штрихи, специализируясь на печатном представлении и описании блокировок. Мы опишем предоставляемые системой методы по умолчанию для печати и описания объектов и обсудим, почему часто бывает полезно предоставить метод для переопределения поведения по умолчанию. Мы также показываем, как методы могут играть разные роли и совместно работать.

### Управление печатью объектов блокировок

Печатные представления нулевых блокировок и простых блокировок выглядят примерно так:

<pre>
   #<NULL-LOCK 738592> 
   #<SIMPLE-LOCK 220478>
</pre>

Этот вывод дает тип блокировки и адрес в памяти, где хранится экземпляр. Однако он не дает имени блокировки. Мы можем решить изменить способ вывода блокировок, чтобы напечатанное представление блокировки содержало его имя, а также его тип и адрес в памяти:

<pre>
   #<NULL-LOCK "Debug lock" 738592> 
   #<SIMPLE-LOCK "Database lock" 220478> 
</pre>

CLOS указывает, что Lisp всегда вызывает обобщенную функцию print-object всякий раз, когда вызывается одна из функций печати, такая как print, prinl, princ, write, format и так далее. Эта обобщенная функция предлагает программам hook(ловушку/крючек) для управления печатным представлением различных классов объектов.

Каждая реализация CLOS предоставляет метод по умолчанию для print-object. Метод по умолчанию наследуется всеми определяемыми пользователем классами. Однако любой класс может предоставить метод для переопределения метода по умолчанию.

Мы используем этот хук, специализируясь на print-object. Концептуально специализация обобщенной функции означает, что эта обобщенная функция ведет себя настраиваемым образом для заданного набора аргументов. Мы специализируем обобщенную функцию, определяя для нее метод. В этом случае мы предоставим метод для переопределения унаследованного метода, поэтому блокировки будут напечатаны индивидуальным образом.

Прежде чем писать метод, вы должны понять интерфейс обобщенной функции. Интерфейс  print-object задокументирован в спецификации CLOS. CLOS указывает, что обобщенная функция print-object печатает объект в поток, а затем возвращает объект. Она принимает два обязательных аргумента: объект и поток. Когда Лисп вызывает print-object, аргументом потока будет реальный поток, а не t или nil.(Это отличается от print, которая принимает t или nil в качестве аргумента потока.)

### Специализация print-object для блокировок(locks)

Мы хотим, чтобы метод был выбран, если первым аргументом является блокировка(lock). Другими словами, мы хотим, чтобы все объекты типа lock унаследовали этот метод. Поскольку для выбора метода будет использоваться только первый аргумент, лямбда-список метода имеет один специализированный параметр и один обычный параметр.

<pre>
(defmethod print-object ((l lock) stream) 
   (format stream "#<~S ~A ~D>" 
           (type-of l) 
           (if (slot-boundp l 'name) 
               (lock-name l) 
               "(no name)") 
           (sys:%pointer l)) 
   l) 
</pre>

Как только этот метод будет определен, он будет использоваться всякий раз, когда печатается блокировка, и результат будет именно тем, что мы хотим.

Функция sys:%pointer не является частью Common Lisp; это функция, которая в некоторых реализациях возвращает адрес объекта в памяти. Для методов объекта печати полезно печатать адрес объекта, поскольку он отличает этот объект от других объектов, что может быть полезно для отладки. Однако адрес объекта может измениться из-за сборки мусора.

Методы для print-object не должны сигнализировать об ошибках; должна быть возможность получить печатное представление любого объекта Лиспа без ошибок. Метод print-object для блокировки использует slot-boundp для проверки того, что блокировка имеет имя перед вызовом lock-name. Если бы слот имени не был связан, то средство доступа к имени блокировки (accessor lock-name) сигнализировало бы об ошибке; см. «Чтение несвязанных слотов», стр. 75.

Важно помнить о области действия этого метода. Мы знаем, что он привязан к классу блокировки(lock), и поэтому можем использовать знание внутренних деталей этого класса. Мы также знаем, что он унаследован классами simple-lock и null-lock и будет использоваться для экземпляров simple-lock и null-lock. Этот метод не может использовать знание каких-либо классов, построенных на блокировке. Например, этот метод может использовать обобщенное имя функции чтения lock-name, потому что класс lock имеет для этого метод; однако он не может использовать обобщенную функцию  lock-owner(владельца блокировки) для чтения, потому что единственный класс, который имеет метод для  lock-owner, — это simple-lock. Если бы этот метод действительно использовал  lock-owner, а аргумент для print-object был нулевой блокировкой, во время выполнения было бы сообщено об ошибке, чтобы указать, что для lock-owner не существует применимого метода.

Хотя этот метод должен ограничиваться знанием класса блокировки, мы знаем, что этот метод наследуется другими классами. Обычная ошибка, которую совершают люди, впервые учась писать объектно-ориентированные программы, состоит в том, что предполагается, что метод будет вызываться только для экземпляров блокировки(lock), а не для экземпляров классов, построенных на основе блокировки. Этот метод мог бы сделать это неверное предположение и вывести результат, утверждающий, что экземпляр является блокировкой(lock), вместо того, чтобы признать, что объект может быть экземпляром класса, построенного на базе блокировки. Однако, запрашивая у объекта его тип с помощью type-of, мы понимаем, что несколько разных классов будут наследовать этот метод.

### Что такое метод по умолчанию(Default Method)?

Системный метод для print-object является методом по умолчанию для объектов всех определяемых пользователем классов. Мы предоставили метод print-object для класса блокировкиа. Это метод по умолчанию для всех блокировок, потому что все блокировки построены на базе блокировки.

Как и термин «базовый класс», термин «метод по умолчанию» не имеет технического значения. Эти термины просто описывают предполагаемое назначение класса или метода. Базовый класс обычно предназначен для того, чтобы быть основой набора классов. Метод по умолчанию предназначен для наследования набором классов. Многие базовые классы обеспечивают поведение по умолчанию; таким образом, методы по умолчанию обычно присоединяются к базовым классам.

### Специализация описания для блокировок(Locks)

В дополнение к управлению печатным представлением блокировок было бы полезно предоставить людям возможность более подробно изучить блокировку(объект lock).

Один из способов сделать это — специализировать/указать обобщенную функцию describe(описание). Альтернативой может быть написание метода для новой обобщенной функции, такой как show-lock. В любом случае будет достигнуто одно и то же, но часто предпочтительнее расширить знакомую функцию Common Lisp, чем вводить новую функцию. Этот подход работает, только если функция является обобщенной функцией.

Как и print-object, describe(описать) — это обобщенная функция, предоставляемая CLOS, чтобы пользователи могли специализировать ее поведение для предоставленного класса объектов. Доступен системный метод по умолчанию, но вы можете указать метод для его переопределения.

Интерфейс для describe утверждает, что он принимает один аргумент, выводит описание своего аргумента на стандартный вывод и не возвращает никаких значений. Этот метод describe специализируется для блокировок:

<pre>
(defmethod describe ((l lock)) 
   (format t "~&~S is a lock of type ~S named ~A." 
           l (type-of l) 
           (if (slot-boundp l 'name) 
               (lock-name l) 
               "(no name)")) 
   (values)) 
</pre>

Этот основной метод применим для всех блокировок. Он наследуется нулевыми блокировками и простыми блокировками. Мы используем slot-boundp, чтобы гарантировать, что метод describe не сигнализирует об ошибке, если слот имени не связан.

### After-method для описания простых блокировок

Основной метод describe(описания) не дает адекватного описания простой блокировки. Важнейшим элементом простой блокировки является её владелец, если она в данный момент занята. Метод describe(описания), предоставленный блокировкой, не может предоставить эту информацию, потому что он выходит за его пределы. Класс lock(Блокировка) не имеет слота owner(владельца).

Мы хотим специализировать поведение describe для простой блокировки(simple-lock), чтобы он давал ту же информацию, что и метод describe(описания) для lock(блокировки), но также описывал владельца(owner) простой блокировки.

Мы могли бы предоставить основной метод для describe, прикрепленный к классу simple-lock, чтобы переопределить метод, унаследованный от класса lock(блокировки). Конечно, нам пришлось бы продублировать код для отображения  типа и имени блокировки, а также для обеспечения того, чтобы никакие значения не возвращались. Однако дублирование кода противоречит объектно-ориентированному стилю программирования. Вместо того, чтобы переопределять метод, мы должны стремиться унаследовать его и добавить к нему поведение.
Мы можем сделать это, предоставив метод after для класса simple-lock. After-метод заботится об описании владельца(owner) простой блокировки.

Когда обобщенная функция describe вызывается для простой блокировки, обобщенная процедура диспетчеризации(generic dispatch procedure) сначала вызывает первичный метод, предоставляемый классом блокировки, а затем вызывает дополнительный метод, предоставляемый классом simple-lock. Обобщенная функция возвращает значения, возвращенные основным методом, что нам и нужно. Любые значения, возвращаемые after-методом, игнорируются. After-методы используются для выполнения побочных эффектов, а не для возврата значений. After-метод имеет ключевое слово :after в качестве квалификатора метода. Этот квалификатор метода задает роль метода. До сих пор мы видели только первичные методы, не имеющие квалификаторов методов. Если у метода есть квалификаторы, они появляются сразу после имени обобщенной функции.

<pre>
(defmethod describe :after ((l simple-lock)) 
   (let ((owner (lock-owner l))) 
      (format t (if owner 
                    "~&It is now owned by process ~A.~%" 
                    "~&It is now free.~%") 
              owner))) 
</pre>

Когда для простой блокировки вызывается обобщенная функция describe, вызываются два метода. Когда для нулевой блокировки вызывается обобщенная функция describe, вызывается только один метод, describe имеет только один интерфейс, но имеет различные реализации. В этом смысл термина обобщенная функция.

В этом методе мы предполагаем, что слот owner(владелец) связан. Если это не так, этот метод будет сигнализировать об ошибке. Семантика упорядоченных блокировок требует, чтобы слот owner(владельца) был либо процессом, либо nil.

### Cистемы по умолчанию Метод describe 

Поведение метода по умолчанию для describe зависит от реализации. Как правило, метод по умолчанию дает тип объекта, а также имена и значения его слотов. Почему метод по умолчанию нежелателен для описания блокировок?
Вместо того, чтобы просто отображать имена и значения слотов, наш метод делает шаг вперед и передает семантику слотов и их значений. Наш метод describe выдает концептуальное описание блокировки на английском языке. Вывод нашего метода описания выглядит следующим образом:

<pre>
#<SIMPLE-LOCK File lock 2417> is a lock of type 
SIMPLE-LOCK named File lock. 
It is now owned by Process 3299. 
</pre>

Вывод типичного системного метода по умолчанию для describe выглядит следующим образом:

<pre>
#<SIMPLE-LOCK "File lock" 2417> is of type SIMPLE-LOCK, 
with slots: 
         NAME:                "File lock" 
         OWNER:               3299 
</pre>

Есть еще одно преимущество в предоставлении метода describe(описания), настроенного для класса объекта. Часто желательно скрыть детали реализации объекта. У метода по умолчанию нет другого способа описать объект, кроме как обнажая его реализацию. Предоставляя метод describe, вы можете управлять тем, как пользователи видят ваш объект.

## 3.7 АНАЛИЗ НАСЛЕДОВАНИЯ БЛОКИРОВОК

До сих пор мы программировали с неявным пониманием того, как должно работать наследование. На этом этапе стоит более подробно изучить наследование и прояснить некоторые механизмы, лежащие в его основе.

### Переопределение унаследованных признаков

Наша организация блокировок включает базовый класс блокировки и два класса, построенных на блокировке. И простая блокировка, и нулевая блокировка наследуются от класса блокировки. Кроме того, все пользовательские классы наследуются от класса standard-object(стандартного объекта).

Класс standard-object — это предопределенный класс, целью которого является поддержка поведения по умолчанию. То есть к классу standard-object привязано несколько системных методов по умолчанию.

Рассмотрим, что происходит, когда обобщенная функция print-object вызывается с экземпляром null-lock в качестве аргумента. Класс null-lock имеет два применимых основных метода для print-object: метод, прикрепленный к lock, и метод, прикрепленный к standard-object.

| Класс              | Метод для print-object |
|------------------------|------------------------------------|
| lock                 |   primary                      |
| standard-object |   primary                     |

Рассмотрим, что происходит, когда обобщенная функция print-object вызывается с экземпляром null-lock в качестве аргумента. Класс null-lock имеет два применимых основных метода для print-object: метод, прикрепленный к lock, и метод, прикрепленный к standard-object.

Причина, по которой блокировка является более конкретной, чем standard-object, заключается в том, что класс имеет приоритет над своими суперклассами. Класс standard-object является надклассом класса lock.

### Списки приоритетов классов нулевых и простых блокировок

Список приоритетов(предшествования) классов является арбитром конфликтующих признаков. CLOS определяет список приоритетов классов для каждого класса на основе организации классов, настроенной программистом. В ходе этого процесса CLOS должен ответить на два вопроса:
* От каких классов наследуется этот класс? Класс наследуется от самого себя и всех своих суперклассов. Сюда входят его прямые суперклассы, каждый из их прямых суперклассов и так далее. CLOS получает эту информацию из набора определений классов.
* Каков порядок старшинства среди этих классов? Ответ на этот вопрос также получен из определений классов. CLOS использует алгоритм для определения приоритета, и этот алгоритм всегда подчиняется следующему правилу приоритета класса:

| **Правило 1 приоритета/предшествования класса:** 
|------------------------------------------------------
|Класс всегда имеет приоритет над своими суперклассами.

Мы упоминали, что все пользовательские классы имеют standard-object в качестве суперкласса. Кроме того, все классы имеют класс t в качестве суперкласса. Класс t является корнем всех классов. Точно так же, как все типы являются подтипами t, все классы являются подклассами t.

Рассмотрим пример simple-lock(простой блокировки). Этот класс наследует сам от себя simple-lock и его суперклассы lock, standard-object и т.д. Когда CLOS применяет Правило 1 к каждому из этих определений классов, результатом является набор ограничений упорядочения:

	> simple-lock(простая блокировка) имеет приоритет над lock(блокировкой)
	> simple-lock(простая блокировка) имеет приоритет над standard-object(стандартным объектом)
	> simple-lock(простая блокировка) имеет приоритет над t
	> lock(блокировка) имеет приоритет над standard-object
	> lock имеет приоритет над t
	> standard-object имеет приоритет над t

Список приоритетов классов должен удовлетворять всем этим ограничениям. Результирующий список приоритетов классов для simple-lock(простой блокировки):
<pre>
(simple-lock lock standard-object t) 
</pre>
Точно так же список приоритетов классов для null-lock(нулевой блокировки)
<pre>
(null-lock lock standard-object t) 
</pre>

Определить списки приоритетов для этих двух классов несложно. Это сложнее для классов, которые имеют более одного прямого суперкласса. Мы вводим еще одно правило приоритета класса для решения этой ситуации в «Списки приоритета класса упорядоченных блокировок», стр. 48.

### Обобщенная процедура отправки

Когда вызывается обобщенная функция, CLOS берет на себя ответственность за выбор реализации, соответствующей аргументам. Это влечет за собой поиск применимых методов, затем их сортировку по порядку приоритета и, наконец, вызов одного или нескольких из них. Эта процедура называется обобщенной отправкой(generic dispatch). Это происходит автоматически всякий раз, когда вызывается обобщенная функция.

Вы несете ответственность за определение классов и методов, в первую очередь, с пониманием того, как работает обобщенная диспетчеризация. CLOS заботится о механике обобщенной отправки(диспетчеризации).

	>  Что вы делаете                Что делает CLOS

	> Определите классы.            Вычисляет список приоритетов классов на основе определений классов.

	> Определите методы.            Сохраняет методы для использования при вызове обобщенной функции.

	> Вызываете обобщенные функции. Определяет типы аргументов.
	>                               Находит набор применимых методов.
	>                               Сортирует методы от наиболее конкретных к наиболее общим на основе списка приоритетов классов.
	>                               Вызывает before-методы.
	>                               Вызывает наиболее конкретный основной метод.
	>                               Вызывает after-методы.
	>                               Возвращает значение(я) основного метода.

Хотя вызов обобщенной функции кажется медленным и сложным процессом, хорошие реализации CLOS оптимизируют его, предварительно вычисляя многие шаги. Фактически, в некоторых реализациях вызов обобщенной функции почти так же быстр, как и вызов обычной функции. Такая оптимизация может сделать CLOS достаточно эффективной для использования, например, в операционной системе.

Мы обсуждаем порядок выполнения методов до(before-) и после(after-) в разделе «Порядок выполнения методов до и после», стр. 50.

## 3.8 РАСШИРЕНИЕ ПРОГРАММЫ БЛОКИРОВКИ

На этом разработка блокирующего приложения завершена, реализованы простые и нулевые блокировки. Теперь мы хотим добавить новый тип блокировки к существующему приложению блокировки. В этом разделе мы иллюстрируем определение «класса миксина»("mixin class"), который будет использоваться в качестве строительного блока, и «агрегированных классов»("aggregate classes"), построенных на миксине и другом классе.

### Предотвращение взаимоблокировок(Deadlock) с помощью упорядоченных блокировок(Ordered Locks)

Некоторые операции требуют доступа более чем к одному общему ресурсу. Вы можете удалить элемент из одной структуры данных и добавить его в другую структуру данных. Если структуры данных являются общими ресурсами с блокировками, защищающими их от одновременного доступа, вы должны владеть блокировками для обоих ресурсов при выполнении операций добавления и удаления.

Вот еще один сценарий: чтобы получить масло, вам нужно одновременно держать блюдо масла и нож для масла. Когда вы держите блюдо масла и нож, вы защищаете их от одновременного использования другими людьми (другими словами, вы «владеете блокировками» на двух ресурсах масла).

Когда вам нужно владеть двумя блокировками одновременно, существует риск взаимоблокировки. Предположим, один человек держит блюдо с маслом и ждет нож для масла. Тем временем другой человек держит нож для масла и ждет блюдо с маслом. Ни один человек не может получить масло, пока другой не закончит. В этом случае оба человека поймут, что возникла тупиковая ситуация( deadlock), и один человек, вероятно, освободит один из конфликтующих ресурсов. Это позволяет другому человеку получить масло, а затем высвободить оба ресурса для использования другими людьми. В этом решении люди обнаруживают взаимоблокировку и разрешают ее.

Когда процессу необходимо захватить более одной простой блокировки, существует риск взаимоблокировки. Помните, что если простая блокировка не может немедленно захватить ресурс, она ждет, пока ресурс освободится.

Вместо реализации обнаружения и разрешения взаимоблокировок мы можем попытаться избежать взаимоблокировки. Мы используем технику, в которой все процессы должны захватывать группу блокировок в заданном порядке. Мы могли бы применить этот подход к обеденному столу, установив правило, согласно которому, чтобы получить масло, вы должны взять блюдо для масла, прежде чем взять в руки нож для масла. Если все люди будут соблюдать это правило, никто не будет держать нож для масла и ждать блюдо с маслом, поэтому тупика не произойдет.

Мы можем изобрести новый тип блокировки, называемый упорядоченной блокировкой(ordered lock), чтобы помочь программистам использовать эту технику. Она позволит назначить порядок блокировки для набора блокировок. Механизм упорядоченной блокировки — это инструмент программирования, обеспечивающий проверку ошибок во время выполнения, чтобы убедиться, что порядок не нарушен. Он проверяет работающий код, чтобы увидеть, не рискует ли программа зайти в тупик, и в этом случае сигнализирует об ошибке.

Таким образом, если мы ожидаем, что перед выполнением операции процессам потребуется захватить как блокировку A, так и блокировку B, мы можем использовать упорядоченные блокировки. Каждая заказанная блокировка имеет уровень(level) блокировки. Механизм упорядоченной блокировки применяет правило, согласно которому процесс не может захватить упорядоченную блокировку, если процесс уже владеет блокировкой более высокого уровня. Мы могли бы назначить уровень блокировки 1 для блокировки-A и уровень блокировки 2 для блокировки-B, чтобы гарантировать, что блокировка-A должна быть занята до блокировки-B. В этой схеме все программы должны быть написаны так, чтобы захватить блокировку-A, затем захватить блокировку-B, выполнить операцию и, наконец, снять обе блокировки. Если какой-либо процесс владеет блокировкой B и пытается захватить блокировку A, механизм упорядоченной блокировки сообщает об ошибке во время выполнения. Такой подход гарантирует, что ни один процесс не может находиться в состоянии владения блокировкой B и ожидания блокировки A.

### Определение класса Mixin

Мы предполагаем, что нам понадобятся как упорядоченные нулевые блокировки, так и упорядоченные простые блокировки. Общее поведение этих двух классов — упорядоченное поведение блокировки. Здесь полезно создать класс mixin(примесь), который поддерживает упорядоченное поведение блокировки. Мы называем этот класс упорядоченной блокировкой-примесью(ordered-lock-mixin).

Ожидается, что этот класс миксинов не будет самостоятельным; мы не создаем его экземпляры. Вместо этого мы определяем два агрегатных класса, которые объединяют этот класс mixin с другими классами блокировки, и создаем их экземпляры. Агрегатные классы называются ordered-null-lock(упорядоченной нулевой блокировкой) и  ordered-lock(упорядоченной блокировкой). Термины «mixin/примесь» и «aggregate/агрегат» являются неформальными обозначениями, описывающими предполагаемую цель класса.

Мы не указываем никаких суперклассов для ordered-lock-mixin. Существует единственный слот с именем level. Мы можем инициализировать этот слот при создании экземпляров и использовать функцию чтения для чтения его значения. Мы не ожидаем изменения уровня упорядоченной блокировки после создания блокировки, поэтому для слота level не предусмотрено средство записи. Наша реализация позволяет процессу захватывать упорядоченную блокировку только в том случае, если процесс не владеет другой упорядоченной блокировкой на более высоком уровне.

<pre>
(defclass ordered-lock-mixin () 
  ((level :initarg :level 
          :reader lock-level 
          :type integer)) 
  (:documentation "Avoids deadlock by checking lock order.")) 
</pre>

Назначение класса mixinа — настроить поведение построенных на нем классов. Как правило, mixin(примеси) не мешают унаследованному поведению и не переопределяют его. Вместо этого примеси обычно предоставляют методы до(before-) и после(after-), чтобы дополнить унаследованные первичные методы настраиваемым поведением. Миксины также могут предоставлять первичные методы для дополнительных обобщенных функций.

Обратите внимание на новую опцию слота :type. Эта опция слота объявляет, что вы ожидаете, что значение слота будет определенного типа. Объявления типов в слотах игнорируются некоторыми реализациями, в то время как другие реализации повышают эффективность при использовании объявлений. Объявления типов также являются способом документирования слота. Однако вы не можете полагаться на то, что CLOS выполняет проверку типов, когда значение сохраняется в слоте. Хотя некоторые реализации CLOS могут выбрать проверку типов, они не обязаны это делать. Такое поведение согласуется с самим Common Lisp, у которого нестрогая проверка типов.

### Определение агрегатных(Aggregate) классов

Здесь мы определяем два агрегатных класса, включая желаемый набор суперклассов:

<pre>
(defclass ordered-lock (ordered-lock-mixin simple-lock) 
  () 
  (:documentation 
   "Avoids deadlock by ensuring that a process seizes 
locks in a specific order. 
When seizing, waits if the lock is busy."))

(defclass ordered-null-lock (ordered-lock-mixin null-lock) 
  ()
  (:documentation 
   "Avoids deadlock by ensuring that a process seizes locks 
in a specific order. Does not actually seize anything, 
but does check that the lock ordering is obeyed.")) 
</pre>

Агрегатный класс включает в себя набор суперклассов, которые вместе составляют законченное целое, класс, который может существовать отдельно. Здесь агрегатный класс ordered-lock(упорядоченной блокировки) получает большую часть своего поведения от класса simple-lock(простой блокировки) и настраивает его с поведением упорядоченной блокировки класса ordered-lock-mixin. Лишь изредка агрегатный класс предоставляет дополнительные методы, потому что это сделало бы программу менее модульной. В идеале все слоты и методы предоставляются базовым классом или миксинами. Агрегирующие классы здесь не нуждаются в каких-либо дополнительных модификациях.

Нам нужно определить конструкторы для этих двух новых типов блокировок:

<pre>
(defun make-ordered-null-lock (name level) 
   (make-instance 'ordered-null-lock :name name 
                                     :level level)) 

(defun make-ordered-lock (name level) 
   (make-instance 'ordered-lock :name name 
                  ':level level)) 
</pre>

### Списки приоритетов классов Ordered Locks(упорядоченных блокировок)

Для нулевых блокировок(null locks) и простых блокировок(simple locks) CLOS может определять список приоритетов классов, ссылаясь только на правило 1: Класс всегда имеет приоритет над своими суперклассами.

Однако, когда класс имеет более одного прямого суперкласса, этого правила недостаточно для определения списка приоритетов классов. Правило 1 не указывает, как ранжировать прямые суперклассы. Например, при определении списка приоритетов классов для ordered-lock, имеет ли ordered-lock-mixin приоритет над simple-lock или наоборот? В этой ситуации CLOS использует другое правило:

| Правило 2 приоритета класса:                                              
|---------------------------------------------------------------------------
| Каждое определение класса устанавливает порядок приоритета своего прямого 
| суперкласса.                                                              

Порядок прямых суперклассов в форме defclass указывает их относительный приоритет. Например, определение класса ordered-lock включает в себя два прямых суперкласса:
ordered-lock-mixin и simple-lock.
Поскольку ordered-lock-mixin появляется первым (крайним слева) в списке, он более специфичен, чем simple-lock.

Когда мы принимаем во внимание два правила, мы можем определить список приоритетов классов для двух агрегрегатных классов. Список приоритетов классов ordered-lock является

<pre>
(ordered-lock ordered-lock-mixin simple-lock lock standard-object t) 
</pre>

Списоком приоритетов классов ordered-null-lock является
<pre>
(ordered-null-lock ordered-lock-mixin null-lock lock standard-object t) 
</pre>

### Специализированное описание для упорядоченных блокировок

Прежде чем углубляться в реализацию упорядоченных блокировок, мы специализируемся на отображении уровня блокировки упорядоченной блокировки. Поскольку уровень блокировки является критическим аспектом упорядоченной блокировки, для описания важно предоставить эту информацию.

<pre>
(defmethod describe :after ((l ordered-lock-mixin)) 
   (format t "~&Its lock level is ~D." (lock-level l))) 
</pre>

Когда мы пытаемся описать экземпляр ordered-lock, CLOS находит следующие применимые методы:

| Класс         | Метод для описания |
|-------------------|---------------------------------|
|ordered-lock-mixin | after                 |
|simple-lock        | after                 |
|lock               | primary               |
|standard-object    | primary               |

Существует два применимых основных метода. Основной метод, предоставляемый lock, является более специфичным из двух, поэтому вызывается он.

Существует два применимых after-метода. Оба они вызываются. Они вызываются в порядке: наиболее-специфичный-последним. Здесь метод after для simple-lock вызывается первым, потому что он менее специфичен из двух. Когда он возвращается, вызывается метод after для ordered-lock-mixin.

Здесь мы создаем упорядоченную блокировку и вызываем для нее describe, чтобы показать влияние generic dispatch(обобщенной отправки) на этот набор методов:

<pre>
(setq *lock-C* (make-ordered-lock "C" 3)) 
=> #<ORDERED-LOCK C 29451> 

(describe *lock-C*) 
#<ORDERED-LOCK C 29451> is a lock of type ORDERED-LOCK named C. 
It is now free. 
Its lock level is 3. 
=> no values 
</pre>

### Порядок методов "До"(Before-) и "После"(After-)

Обобщенная процедура отправки находит все применимые методы, которые могут включать в себя несколько методов до(before-), первичных методов и методов после(after). Общая процедура отправки вызывает следующие методы:

1. Все before- методы в наиболее специфичном порядке. Это позволяет более конкретному классу выполнять операцию до того, как произойдет что-либо еще, где "что-либо еще" включает унаследованные методы before-(до), основной метод и методы after-(после).
2. Наиболее специфичный первичный метод. Это позволяет более конкретному классу при желании переопределять унаследованный основной метод.
3. Все after-методы в порядке: наиболее специфичный последним. Это позволяет более конкретному классу выполнять операцию после того, как произойдет все остальное, где "все остальное" включает в себя методы before-(до), основной метод и унаследованные методы after-(после).

Другими словами, класс может сделать что-то до поведения, унаследованного от менее специфичных классов; он также может сделать что-то после того, как произойдет поведение, унаследованное от менее специфичных классов. Такой вид вложенности должен казаться естественным программистам, знакомым с Lisp.

Представьте, что классы ordered-lock-mixin, simple-lock и lock предоставляют метод before и метод after. На рисунке 3.3 показан порядок, в котором будут вызываться методы.

	> before-method для ordered-lock-mixin 
	> before-method для simple-lock 
	> before-method для lock 
	> most specific primary method 
	> after-method для lock 
	> after-method для simple-lock 
	> after-method для ordered-lock-mixin 


![Рисунок 3.3: Вложенность методов "до"(before-) и "после"(after-).](images/f03-03.jpg )**Рисунок 3.3: Вложенность методов "до"(before-) и "после"(after-).**

На практике любой из этих методов до(before-) или после(after-) может присутствовать или отсутствовать. Когда вызывается обобщенная функция, единственным требованием является наличие по крайней мере одного применимого основного метода. Если такового нет, выдается сигнал об ошибке.

### Реализация Поведения Упорядоченной  Блокировки(Ordered Locking)
Мы будем реализовывать поведение упорядоченной блокировки, отслеживая, какие упорядоченные блокировки принадлежат процессу. Когда процесс пытается захватить упорядоченную блокировку, мы сначала проверим, владеет ли процесс уже упорядоченной блокировкой на более высоком уровне. Если это так, блокировка считается "неисправной" и недействительной; выдается сообщение об ошибке, и мы не позволяем процессу перехватить эту блокировку. В противном случае блокировка считается "в порядке" и действительной, поэтому мы разрешаем процессу захватить ее.

Мы используем хэш-таблицу для отслеживания упорядоченных блокировок, принадлежащих каждому процессу. Первые две функции используются для обновления таблицы, когда процесс захватывает или освобождает упорядоченную блокировку; вторые две функции проверяют таблицу.

<pre>
(defvar *process-lock-table* (make-hash-table) 
  "Each key is a process identifier; 
value is a list of ordered locks it owns") 

(defun add-process-lock (process lock) 
   (without-process-preemption 
       (push lock 
             (gethash process *process-lock-table*)))) 

(defun delete-process-lock (process lock) 
   (without-process-preemption 
       (let ((hash-entry 
               (gethash process *process-lock-table*))) 
          (setf (gethash process *process-lock-table*) 
                (delete lock hash-entry))))) 

(defun get-process-locks (process) 
   (without-process-preemption 
       (gethash process *process-lock-table*))) 

(defun get-highest-lock (process) 
   (first (get-process-locks process))) 
</pre>

В этом коде мы предполагаем, что gethash и setf операций gethash не являются атомарными, поэтому мы используем without-process-preemption для использования этих функций. Обратите внимание, что get-highest-lock зависит от того, что первая блокировка является самой высокой блокировкой. Мы полагаемся на то, что вызывающий add-process-lock всегда добавляет более высокий уровень блокировки; в этом и заключается суть упорядоченной блокировки. Функция delete-process-lock может удалить любую блокировку из данного процесса, но она не изменяет порядок остальных блокировок.

Хэш-таблица - это простой и эффективный способ хранения связи между процессом и упорядоченными блокировками, которыми он владеет. В некоторых реализациях Lisp сам процесс будет реализован как экземпляр класса. В этих случаях у каждого процесса может быть слот, в котором он хранит список своих упорядоченных блокировок; это заменит механизм хэш-таблицы.

Функции, определенные здесь, являются интерфейсом для связи между процессами и их списками упорядоченных блокировок. Мы будем использовать этот интерфейс в методах, реализующих упорядоченную блокировку. Ничто не мешает нам когда-нибудь переключиться с хэш-таблицы на другое представление. Мы могли бы переопределить эти функции, чтобы они выполняли свою работу по-другому, не влияя на вызывающих функции. Например, мы могли бы изменить их с обычных функций на обобщенные функции и методы, не меняя вызывающих.

### Методы для упорядоченных блокировок

Прежде чем разрешить процессу захватить упорядоченную блокировку, мы проверяем, что в данный момент он не владеет блокировкой более высокого уровня. Мы делаем это, определяя метод before для seize. Если метод before определяет, что для процесса допустимо захватить блокировку, он просто возвращается. Этот метод не выполняет никакой фактической блокировки, но предполагает, что об этом позаботится другой метод. Если метод before определяет, что для процесса недопустимо захватывать эту блокировку, он сигнализирует об ошибке. Поскольку ошибка никогда не возвращается, никакой другой метод не вызывается. Вызов обобщенной функции seize прерывается нелокальным завершением, вызванным вызовом error. Таким образом, этот метод может предотвратить захват замка, если это необходимо.

<pre>
(defmethod seize :before ((l ordered-lock-mixin)) 
   "Checks validity of this process seizing this ordered lock. 
If invalid, signals an error. 
If valid, does nothing and allows primary method to run." 
   ;; First check for the mylock mistake to give the specific 
   ;; error for that case, instead of the "Out of order" error, 
   (check-for-mylock 1 *current-process*) 
   ;; Now check for a possible infraction of ordered locking, 
   (let ((highest-lock (get-highest-lock *current-process*))) 
      (when (and highest-lock 
                 (<= (lock-level 1) (lock-level highest-lock))) 
         (error "Out of order: Can't seize ~A while owning ~A" 
                l highest-lock)))) 
</pre>

После того, как процесс захватил упорядоченную блокировку, необходимо обновить *process-lock-table*, чтобы связать эту блокировку с процессом. Мы делаем это обновление с помощью последующего метода для захвата:

<pre>
(defmethod seize :after ((l ordered-lock-mixin)) 
   "Adds the lock to the *process-lock-table*" 
   (add-process-lock *current-process* l)) 
</pre>

Аналогично, после снятия упорядоченной блокировки мы должны обновить *process-lock-table*. Нам нужен другой последующий метод, чтобы позаботиться об этом обновлении:

<pre>
(defmethod release :after ((l ordered-lock-mixin) 
                           &optional failure-mode) 
   "Deletes a lock from the *process-lock-table*" 
   (declare (ignore failure-mode)) 
   (delete-process-lock *current-process* l)) 
</pre>

Класс ordered-lock-mixin предоставляет метод before, который проверяет наличие ситуации (фактически, как для ошибок "mylock", так и для ошибок "out of order"), и метод after, который отмечает ситуацию (новая связь между блокировкой и процессом). Это типичное использование методов "до"(before-) и "после"(after-).

Это упрощенная реализация упорядоченных блокировок, поскольку в этом коде не рассматривается возможность прерываний, происходящих в неподходящее время, в результате чего таблица процессов не соответствует фактическому состоянию блокировки. Эти подробности опущены, поскольку они не имеют отношения к обсуждению объектно-ориентированного программирования.

## 3.9 КАК КЛИЕНТСКИЕ ПРОГРАММЫ ИСПОЛЬЗУЮТ БЛОКИРОВКИ

До сих пор наши блокировки не были связаны ни с каким общим ресурсом. Один из способов сделать ресурс блокируемым - включить блокировку в структуру данных, представляющую ресурс. Затем вы пишете функции для доступа к структуре данных, которые сначала захватывают блокировку, затем получают доступ к структуре данных и, наконец, снимают блокировку.

### Блокировка общей очереди(Shared Queue)

Рассмотрим, как может работать диспетчер очереди печати. Когда пользователь запрашивает распечатку на бумажном носителе, диспетчер очереди печати сохраняет запрос на печать в очереди до тех пор, пока принтер не будет готов, а затем отправляет запрос на принтер. Диспетчер очереди печати поддерживает очередь запросов на печать. Несколько процессов могут получить доступ к этой очереди, поэтому важно гарантировать, что очередь обновляется согласованным образом. Это хороший кандидат для клиентской программы нашего приложения блокировки.

Простая блокировка(simple lock) - это правильный вид блокировки здесь. Этим процессам не нужно будет владеть более чем одной блокировкой одновременно, поэтому взаимоблокировка не должна быть проблемой.

Мы можем реализовать нашу очередь запросов на печать, определив класс, который включает слот для блокировки и слот для списка запросов на печать:

<pre>
(defclass print-request-queue () 
  ((lock :accessor print-queue-lock 
         :initform (make-simple-lock "Print Queue")) 
   (requests :accessor print-requests
             :initform nil)) 
  (:documentation "Queue of pending print requests."))

(defun make-print-queue () 
   (make-instance 'print-request-queue)) 
</pre>

Здесь мы создаем очередь запросов на печать и определяем конструктор make-print-queue. Конструктор не принимает аргументов, поэтому два слота инициализируются их начальными значениями по умолчанию. Слот блокировки инициализируется простой блокировкой с именем "Очередь печати", а слот запросов инициализируется пустым списком.

<pre>
(defvar *print-queue* (make-print-queue)) 
</pre>

Следующие функции для изменения очереди обеспечивают захват блокировки, изменение структуры данных и снятие блокировки. Функция защиты от разматывания гарантирует, что блокировка будет снята, даже если операция будет прервана.

<pre>
(defun enqueue-print-request (r) 
   (let ((lock (print-queue-lock *print-queue*))) 
      (unwind-protect 
           (progn (seize lock) 
                  (push r (print-requests *print-queue*))) 
         (release lock :no-error))))
</pre>

Функция dequeue-print-request принимает запрос в качестве аргумента вместо того, чтобы просто удалять первый запрос из списка. Это позволяет вызывающей стороне — диспетчеру очереди печати — выбирать, какой запрос печатать первым.

<pre>
(defun dequeue-print-request (r) 
   (let ((lock (print-queue-lock *print-queue*))) 
      (unwind-protect 
           (progn 
              (seize lock) 
              (setf (print-requests *print-queue*) 
                    (delete r (print-requests *print-queue*)))) 
         (release lock :no-error))))
</pre>

### Поддержка типичного использования блокировок: with-lock

Когда мы отступаем назад и смотрим на первую клиентскую программу, мы видим, что как запрос на печать в очереди, так и запрос на снятие с очереди демонстрируют каноническое использование блокировок: сначала захват блокировки, затем выполнение операции, затем снятие блокировки.

Мы можем добавить макрос with-lock в приложение блокировки, чтобы программам было удобнее использовать блокировки:

<pre>
(defmacro with-lock ((lock) &body body) 
   (let ((lock-var (gensym))) 
      `(let ((,lock-var ,lock)) 
        (unwind-protect 
             (progn (seize ,lock-var) 
                    ,@body) 
           (release ,lock-var :no-error))))) 
</pre>

Этот макрос позволяет разработчику клиентской программы значительно упростить обе функции:

<pre>
(defun enqueue-print-request (r) 
   (with-lock ((print-queue-lock *print-queue*)) 
      (push r (print-requests *print-queue*))))

(defun dequeue-print-request (r) 
   (with-lock ((print-queue-lock *print-queue*)) 
      (setf (print-requests *print-queue*) 
            (delete r (print-requests *print-queue*))))) 
</pre>

### Специализация describe для очередей запросов на печать(Print-Request Queues)

Это хороший стиль для клиентской программы - специализировать describe для класса print-request-queue. Обратите внимание, что этот метод не захватывает print-request-queue перед его описанием. Это означает, что, если у очереди есть владелец, этот процесс может в настоящее время изменять очередь, поэтому ожидающие запросы на печать могут изменяться.

Причина, по которой мы не захватываем очередь, заключается в том, что мы считаем, что для describe(описания) более ценно показывать владельца блокировки, если она занята, а не ждать, пока очередь освободится. Если бы мы ждали, пока очередь освободится, было бы невозможно использовать describe для отладки в случаях, когда один процесс ожидает, владея блокировкой, потому что describe также будет ждать.

<pre>
(defmethod describe ((queue print-request-queue)) 
   (let ((owner (lock-owner (print-queue-lock queue))) 
         (requests (print-requests queue))) 
      (if owner 
          (format t "~SProcess ~A owns queue.~%" owner)) 
      (format t (if (null requests) 
                    "~SThere are no print requests.~%" 
                    "~SPending print requests:~%")) 
      (dolist (x requests) 
         (format t "~S~A " x)))) 
</pre>

## 3.10 ОБЗОР КЛАССОВ БЛОКИРОВОК

Представьте, что вы собираетесь описать структуру программы блокировки другому программисту. При описании организации объектно-ориентированной программы вам, вероятно, потребуется ответить на подобные вопросы:

	> Что представляет собой набор классов?
	> Какой вклад вносит каждый класс в целое?
	> Как взаимодействуют классы?

Как только мы соберем эту информацию, мы внимательно рассмотрим класс ordered-lock, чтобы увидеть, как он работает.

### Что представляет собой набор классов?

Первые два класса - это строительные блоки, которые не предназначены для самостоятельной работы. Остальные четыре класса поддерживают полный протокол блокировки и могут работать автономно. Это различие очень важно.

	>  Class                  Описание класса

	>  lock                   Основа всех блокировок

	> ordered-lock-mixin     Примесь, поддерживающая упорядоченное поведение блокировки; неотъемлемая 
	>                                часть всех упорядоченных блокировок.

	> simple-lock            Блокировка, которая либо занята, либо свободна. Когда она занята, она сохраняет 
	>                             своего владельца. Конструктор make-simple-lock.

	> null-lock              Блокировка, которая всегда свободна. Она подчиняется протоколу блокировки, ничего 
	>                           не захватывая. Конструктор make-null-lock.

	> ordered-lock           Блокировка, которая поддерживает упорядоченную блокировку и либо занята, либо 
	>                              свободна. Конструктор make-ordered-lock.

	>ordered-null-lock       Блокировка, поддерживающая упорядоченную блокировку, но всегда свободная. Ничего 
	>                              не захватывает. Конструктор make-ordered-null-lock.

### Какой вклад вносит каждый класс?

Класс может предоставлять слоты и методы. Также наследуются опции слота; то есть они влияют на классы, созданные на основе класса, предоставляющего параметр(опцию) слота. Например, параметры слота :initarg и :initform наследуются подклассами. Если класс предоставляет методы доступа, они применимы и для подклассов. Здесь мы сосредоточимся на слотах и ​​методах, поддерживающих протокол блокировки. Начнем с перечисления слотов, которые предоставляет каждый класс:

|   Class               |  Slots   |
|-----------------------|----------|
| lock                  | name     |
| ordered-lock-mixin    | level    |
| simple-lock           | owner    |
| null-lock             | none     |
| ordered-lock          | none     |
| ordered-null-lock     | none     |

Теперь мы перечислим методы для seize(захвата) и release(освобождения):

|    Class              | seize       |  release |
|-----------------------|-------------|----------|
| lock                  | none        | none     |
| ordered-lock-mixin    |before, after| after    |
| simple-lock           | primary     | primary  |
| null-lock             | primary     | primary  |
| ordered-lock          | none        | none     |
| ordered-null-lock     | none        | none     |

Теперь мы перечислим методы для describe и print-object. Обратите внимание, что мы включаем здесь класс standard-object, поскольку он предоставляет методы для этих обобщенных функций:

|     Class             | describe    |print-object |
|-----------------------|-------------|-------------|
| standard-object       | primary     | primary     |
| lock                  | primary     | primary     |
| ordered-lock-mixin    | after       | none        |
| simple-lock           | after       | none        |
| null-lock             | none        | none        |
| ordered-lock          | none        | none        |
| ordered-null-lock     | none        | none        |

### Как Взаимодействуют Классы?

Взаимодействие классов происходит через наследование. Ключом к пониманию того, как один класс наследует от своих суперклассов, является список приоритетов этого класса. Мы составили каталог того, что каждый класс вносит в общее дело. Теперь мы можем подробно описать любой класс, просмотрев список приоритетов его классов и собрав вклад каждого класса в список.

Список приоритетов классов каждого класса включает в себя сам класс и все его суперклассы, упорядоченные от наиболее специфичных к наименее специфичным. Хотя все пользовательские классы имеют standard-object и t в конце своих списков приоритета классов, мы опускаем здесь эти системные классы, поскольку они являются заданными.

| Class                | Class Precedence List                |
|----------------------|--------------------------------------|
| lock                 | (lock)                               |
| ordered-lock-mixin   | (ordered-lock-mixin)                 |
| simple-lock          | (simple-lock lock)                   |
| null-lock            | (null-lock lock)                     |
| ordered-lock         | (ordered-lock ordered-lock-mixin     |
|                      |  simple-lock lock)                   |
| ordered-null-lock    | (ordered-null-lock ordered-lock-mixin| 
|                      |  null-lock lock)                     |

### Проверка Упорядоченных Блокировок

Мы используем информацию, собранную в предыдущих разделах, чтобы более подробно рассмотреть класс ordered-lock. Какие слоты в нем есть? Посмотрите на каждый класс в его списке приоритетов классов, чтобы увидеть, какие слоты они предоставляют. В следующей таблице показано, что упорядоченная блокировка имеет три слота: level(уровень), owner(владелец) и name(имя). (Классы standard-object и t не имеют слотов и не показаны.)

|     Class          | Slots  |
|--------------------|--------|
| ordered-lock       | none   |
| ordered-lock-mixin | level  |
| simple-lock        | owner  |
| lock               | name   |

Как класс ordered-lock реализует обобщенную функцию seize? Посмотрите на классы в его списке приоритетов классов, чтобы узнать, какие методы они предоставляют для seize:

|   Class           | Method for seize |
|-------------------|------------------|
| ordered-lock      | none             |
| ordered-lock-mixin| before, after    |
| simple-lock       | primary          |
| lock              | none             |

Когда seize вызывается для экземпляра ordered-lock, вызываются следующие методы:

1. Метод before, предоставляемый ordered-lock-mixin, который проверяет действительность разрешения этому процессу захватить эту упорядоченную блокировку
2. Основной метод, предоставляемый simple-lock, который сохраняет идентификатор процесса в слоте владельца
3. Последующий метод, предоставляемый ordered-lock-mixin, который обновляет *process-lock-table*, чтобы отметить, что этот процесс теперь владеет этой упорядоченной блокировкой

Мы можем пройти через ту же процедуру, чтобы проверить любой класс блокировки, чтобы выяснить, какие слоты у него есть и как он реализует любую из этих универсальных функций.

### 3.11 ВНЕШНЯЯ И ВНУТРЕННЯЯ ПЕРСПЕКТИВЫ

Первоначально мы намеревались написать методы, которые поддерживали бы протокол блокировки. В ходе разработки программы мы определили дополнительные методы, макрос и несколько функций. Здесь мы классифицируем каждую из этих операций Lisp в соответствии с их назначением: какие из них являются частью внешнего интерфейса, а какие являются внутренними?

### Внешний Протокол Блокировки

Внешний Протокол блокировки состоит из конструкторов и операций блокировки. Ожидается, что клиентские программы будут создавать свои собственные блокировки с помощью этих конструкторов и использовать захват и освобождение для управления блокировками.

|  seize           |  release              |
|------------------|-----------------------|
|make-simple-lock  | make-null-lock        |
|make-ordered-lock | make-ordered-null-lock| 

### Поддержка других протоколов

Эти методы предназначены для внешнего использования, но они не являются частью протокола блокировки. Как describe, так и print-object имеют собственные протоколы, которым следуют наши методы.

	>  describe                     print-object

### Поддержка использования блокировок

Этот макрос предназначен для внешнего использования. Это синтаксическое расширение протокола блокировки.

	>    with-lock

### Только Для Внутреннего Использования

Мы определили методы для обобщенных функций, макроса, специальной переменной и нескольких функций, которые не являются частью внешнего интерфейса для блокировки. Они используются в рамках реализации блокировки или для отладки. Нижеследующее предназначено только для внутреннего использования:

	>   lock-name                    lock-level 
	>   lock-owner                   (setf lock-owner) 
	>   setf-if                      get-process-locks 
	>   get-highest-lock             add-process-lock 
	>   delete-process-lock          *process-lock-table*

Нет никакой гарантии для клиентов программы блокировки, что внутренние функции, подобные этим, всегда будут существовать или всегда будут работать так же, как они работают сейчас. Аналогичным образом, определения классов могут быть изменены позже. Например, названия слотов могут изменяться, а слоты могут быть добавлены или удалены. Эти чисто внутренние детали находятся в ведении разработчика, который волен изменять их по любой причине.

### Отличать Внутреннее от внешнего

CLOS не проводит различия между внешней и внутренней перспективами. Программист должен разрабатывать программу с таким разделением в качестве цели проектирования. Документация программы должна предоставлять только внешний интерфейс.

Вы можете различить внутренние имена от внешних с помощью пакетов, настроив пакет для вашей программы и экспортировав из пакета только те символы, которые предназначены для внешних имен. Common Lisp предоставляет программе удобные способы использования экспортированных символов пакета, не сталкиваясь с другими символами; эти методы включают использование пакета и синтаксис символов с одним двоеточием. Использование пакетов - это общая техника Common Lisp, и мы не рассматриваем его далее в этой книге.

## 3.12 РУКОВОДСТВО ПО РАЗРАБОТКЕ ПРОТОКОЛОВ

Мы были довольно строги с нашим определением протокола блокировки. Такая строгость выгодна пользователям, которые могут зависеть от работы протокола в соответствии с объявлениями, и разработчику, который может изменять реализацию, не нарушая работу сообщества пользователей. CLOS предлагает набор инструментов для определения протокола, но ответственность за изобретение протокола для нового приложения лежит на программисте. В дополнение к рекомендациям по использованию пакетов, мы предоставляем эти рекомендации, чтобы помочь вам отделить внутренние функции от внешнего протокола:

* Ограничить доступ пользователя к внутренним структурам данных. Наши методы описания дают хорошее английское описание простых блокировок и упорядоченных блокировок. Выходные данные не раскрывают названия слотов, что является внутренней деталью реализации. Метод для describe(описания) по умолчанию, вероятно, отображал бы имена и значения слотов, но наши методы избегают отображения этого внутреннего представления блокировок.
* Предоставить функции конструктора для создания структур данных. Существует два способа создания экземпляров: использовать функцию конструктора или использовать make-instance. В любом случае конечный результат один и тот же, но функция конструктора побуждает пользователей думать об объекте в более абстрактных, концептуальных терминах. Напротив, make-instance выдает подробную информацию о реализации. Во-первых, в нем сообщается, что концептуальный объект реализован как экземпляр класса. Если бы make-instance был частью рекламируемого(предоставляемого) протокола, было бы неудобно изменять некоторые аспекты реализации. Было бы невозможно изменить имя класса или его initargs, или переключиться на представление данных defstruct без изменения объявленного протокола.
* Разработайте протокол таким образом, чтобы предвидеть потребности пользователей. Когда протокол предлагает всю мощь и гибкость, необходимые сообществу пользователей, у людей мало соблазна углубляться в реализацию. Но иногда протокола достаточно для большинства его пользователей, в то время как небольшое число пользователей разочаровывается отсутствием необходимой функции. Эти пользователи могут быть мотивированы на поиск внутренней функции, поддерживающей эту функциональность. Если пользователи начинают зависеть от внутренней функции, разработчик больше не волен изменять ее. Ценное различие между интерфейсом и реализацией становится смазанным(размытым).


Например, наш оригинальный проект блокировки предвосхищает потребности программ (операции создания, захвата и освобождения) и потребности людей (отсюда и методы, которые печатают и описывают блокировки). На бумаге этот проект кажется вполне адекватным, но однажды мы можем найти пользователя, который захочет изменить название блокировки. Постоянный пользователь может исследовать реализацию, выяснить, что имя хранится в слоте, и использовать примитив slot-value, чтобы изменить значение этого слота. (Даже если для слота нет средства доступа, вы можете получить доступ к слоту, вызвав slot-value. Мы обсуждаем это в разделе "Средства доступа(Accessors) против slot-value(значения слота)", стр. 72.)

* Разрешить протоколу развиваться в соответствии с разумными потребностями пользователей. На самом деле, как правило, невозможно заранее предвидеть все потребности пользователей. Когда вы услышите о необходимости какой-либо функции, вы можете рассмотреть возможность добавления нового интерфейса к протоколу. Некоторые запросы на функции являются разумными, например, изменение имени блокировки или добавление обобщенной функции "reset-lock"(сброс блокировки) в протокол блокировки. Вы можете счесть некоторые из них неразумными, например, желание преобразовать простую блокировку в упорядоченную блокировку. Если вы решите, что эта функция должна быть доступна, вы можете расширить протокол совместимым и контролируемым способом.

Мы уже говорили, что есть два варианта для пользователей, которые находят существующий протокол полезным, но не совсем подходящим для их приложений:
Они могут погрузиться во внутренние компоненты и использовать их на свой страх и риск, или они могут отправить запрос разработчику на добавление новых функций. Первый путь не рекомендуется, а второй может повлечь за собой задержку или даже отказ со стороны исполнителя.

Есть и другая альтернатива. Вы можете предложить большую гибкость и мощь, разработав протокол таким образом, чтобы другие люди могли его расширять. Это совершенно другой подход; он предполагает разработку и документирование набора классов, которые будут строительными блоками для пользовательских программ. Эта цель более амбициозна и требует тщательной проектной работы для достижения, но преимущества могут быть ценными. Мы добавим еще одно заключительное руководство, описывающее этот подход.

Разработайте некоторые протоколы так, чтобы они могли быть расширяемы пользователем. Обычный способ для пользователя расширить существующий протокол - это определить новые классы, которые включают некоторую комбинацию существующих классов. Таким образом, пользователи могут воспользоваться преимуществами существующих модулей и адаптировать их к своим собственным целям. Пользователи не должны вмешиваться в работу классов, предоставляемых протоколом; вместо написания методов для объявленных классов пользователи пишут методы для своих собственных настроенных(пользовательских) классов.

Этот последний подход прокладывает путь для будущих расширений программы, независимо от того, выполняются ли эти расширения другими штатными программистами или заказчиками продукта.

Подумайте, как этот подход может быть использован людьми, которые разрабатывают и продают компьютерные системы для программирования других. Первоначальный разработчик предоставляет документированные модули, которые используют знания о внутренних компонентах машины (включая аппаратное обеспечение и микрокод) и максимально эффективно используют возможности машины. Пользователи могут определять новые классы, построенные на основе объявленных модулей, и могут настраивать новые, агрегированные классы; они освобождаются от самостоятельного написания кода более низкого уровня. В то же время разработчики сохраняют свободу изменять базовый механизм, отслеживать обновления внутренних компонентов машины. У разработчиков есть только два требования: они должны задокументировать интерфейс, а затем придерживаться его.

Одна часть примера блокировки иллюстрирует оставление крючка(хука/hook) в коде для будущей расширяемости. Мы определили метод для check-for-mylock для класса simple-lock; метод сигнализирует об ошибке, если процесс, пытающийся захватить блокировку, уже владеет этой блокировкой. Было бы легко определить новый класс блокировки, построенный на simple-lock, который не сигнализирует об ошибке в ситуации mylock. Мы могли бы определить новый класс и дать ему ровно один метод: основной метод для check-for-mylock(проверки на mylock), который ничего не делает. Этот метод переопределит метод simple-lock и, таким образом, предотвратит передачу сигнала об ошибке. Обратите внимание, что, если бы мы определили check-for-mylock как обычную функцию, она не была бы крючком(хуком), потому что клиенты не могли бы специализировать её для данного класса.