# Элементы программ CLOS

Элементами программ CLOS являются классы, экземпляры, универсальные/обобщенные функции и методы. Ни один из этих элементов нельзя рассматривать изолированно, поскольку цель каждого из них - взаимодействовать с другими элементами полезными и предсказуемыми способами. Мы начнем с представления наиболее важных аспектов этих элементов и изучения взаимосвязей между ними.Затем мы опишем, как CLOS интегрируется с Common Lisp, сосредоточив внимание на общих чертах между классами и типами.

## 2.1 КЛАССЫ(CLASSES) И ЭКЗЕМПЛЯРЫ(INSTANCES)

Первым шагом в написании программы CLOS является определение нового типа структуры данных, называемой классом. Класс(class) - это тип Common Lisp. Каждый отдельный объект этого типа является экземпляром(instance) класса. Каждый экземпляр данного класса имеет ту же структуру, поведение и тип, что и другие экземпляры класса.

Мы могли бы определить класс с именем month, который будет иметь экземпляры, представляющие январь, февраль, март и так далее. Или мы могли бы определить класс с именем window для представления окон, которые появляются на экране дисплейного терминала. Когда нам нужно создать новое окно, мы создаем еще один экземпляр этого класса. На рисунке 2.1 показан класс с тремя экземплярами.

![Figure 2.1: Экземпляры классов.](images/f02-01.jpg)
**Figure 2.1: Экземпляры классов.**

Мы можем спросить экземпляр о его типе с помощью обычных функций type Common Lisp. Хотя все экземпляры, по-видимому, относятся к одному и тому же типу, каждый из них имеет отдельный идентификатор. Это совместимо с моделью Common Lisp, в которой два объекта могут иметь один и тот же тип и одну и ту же структуру (например, два массива с одинаковым содержимым), но при этом быть двумя разными объектами, каждый со своим собственным идентификатором.

## 2.2 СЛОТЫ(SLOTS)

Мы уже говорили, что все экземпляры класса имеют одинаковую структуру. Эта структура выполнена в виде слотов. Слот имеет имя и значение. Имя слота описывает характеристику, которую он моделирует, а значение описывает состояние слота в данный момент времени. Эта информация о состоянии может быть считана и записана с помощью методов доступа(*accessors*).

CLOS предлагает два вида слотов: *локальные слоты*( *local slots*) и *общие/разделяемые слоты*(*shared slots*). Для локальных слотов каждый экземпляр содержит свое собственное значение для слота. Для общих слотов все экземпляры совместно используют одно значение для слота. Поскольку локальные слоты используются чаще, здесь мы сосредоточимся на них; мы обсуждаем общие слоты в разделе "Локальные и Общие(совместно используемые) слоты", стр. 66.

Класс с именем window может иметь локальные слоты с именами x-position, y-position, width и height. Эта информация о состоянии описывает для любого данного окна размер этого окна и его положение. На рис. 2.2 показаны имена и значения слотов двух экземпляров класса window.

![Рисунок 2.2: Информация о состоянии, хранящаяся в локальных слотах.](images/f02-02.jpg)**Рисунок 2.2: Информация о состоянии, хранящаяся в локальных слотах.**

Обратите внимание, что два экземпляра одного и того же класса имеют один и тот же набор именованных слотов. Другими словами, они имеют одинаковую структуру. Однако каждый экземпляр поддерживает свои собственные значения для своих локальных слотов; то есть каждый экземпляр имеет свое собственное состояние.

## 2.3 СУПЕРКЛАССЫ( SUPERCLASSES)

CLOS позволяет создавать класс из других классов; классы компонентов называются суперклассами нового класса. Новый класс наследует как структуру (слоты), так и поведение от своих суперклассов.

Этот стиль программирования хорошо подходит для задачи моделирования нескольких видов объектов, связанных друг с другом. Например, мы могли бы захотеть иметь разные типы окон. В дополнение к обычным окнам нам могут понадобиться окна с надписями и окна с рамками.(1) Новые типы окон аналогичны существующему классу окон, но у них есть дополнительные функции. На рисунке 2.3 показаны два новых класса, window-with-label и window-with-border, которые построены на основе существующего класса window.

![Рисунок 2.3: Два новых класса, построенных на основе класса window.](images/f02-03.jpg)**Figure 2.3: Рисунок 2.3: Два новых класса, построенных на основе класса window.**

Чтобы создать класс из компонентов(других классов), вы включаете список классов в определение класса. Они называются прямыми суперклассами нового класса. На рис. 2.3 каждая стрелка указывает от класса к прямому суперклассу этого класса. На самом деле класс строится не только из его прямых суперклассов, но и из прямых суперклассов из каждого их компонента и так далее. Суперклассы класса - это все его составные классы. Термин "подкласс" является обратным термину "суперкласс". Здесь мы применяем эту терминологию к оконным классам:

		 (1) пример окон, окон с метками(label) и окон с границами(border), адаптирован из статьи "Вкусы: неиерархический подход к объектно-ориентированному программированию", Symbolics, Inc., 1982, с разрешения автора, Говарда И. Кэннона.

		 window - это прямой суперкласс window-with-border.
		 window - это прямой суперкласс window-with-label.

		 window-with-border является прямым подклассом window,
		 window-with-label является прямым подклассом window.


На рисунке 2.4 показан экземпляр window-with-label и экземпляр window-with-border. Класс window-with-label наследует четыре слота своего суперкласса window, а также имеет слот с именем label. Аналогично, класс window-with-border наследует слоты window, а также имеет слот с именем border-width. Таким образом, базовая структура окна определяется только один раз (классом window) и наследуется многими типами окон.

![Рисунок 2.4: Слоты, унаследованные от суперклассов.](images/f02-04.jpg )**Рисунок 2.4: Слоты, унаследованные от суперклассов.**

Порядок, в котором слоты хранятся в памяти, зависит от реализации и обычно не виден программисту.

## 2.4 ОБОБЩЕННЫЕ(GENERIC) ФУНКЦИИ

Программы и пользователи работают с экземплярами, используя обобщенные функции. Для вызывающей стороны обобщенная(универсальная) функция выглядит точно так же, как обычная функция Lisp; синтаксис вызова функции идентичен. Когда вы вызываете функцию, вам не нужно знать, определена ли функция как обычная функция или как обобщенная функция.

Концептуально обобщенная функция выполняет высокоуровневую операцию, такую как "обновить(refresh) окно". Для разных типов окон эта операция может потребовать разной работы; в то время как обычное окно просто очищается, окно с границей должно быть очищено, а затем его граница(border) перерисована. Цель высокого уровня "обновить(refresh) окно" должна быть реализована по-разному для разных типов окон. Другими словами, каждый тип окна нуждается в соответствующей ему реализации.

Когда мы сравниваем работу обычных функций и обобщенных функций, мы обнаруживаем семантические различия. Обычное определение функции Lisp определяет как интерфейс, так и реализацию операции, которую она выполняет. Как показано на рис. 2.5, когда вызывается обычная функция Lisp, система Lisp находит и выполняет единственный фрагмент кода, который реализует эту функцию.

![Рисунок 2.5: Обычная функция Lisp.](images/f02-05.jpg )**Рисунок 2.5: Обычная функция Lisp.**

Обобщенная функция определяет только интерфейс. Реализация обобщенной функции не существует в одном месте; она распределена по набору методов. В то время как реализация обычной функции не меняется от вызова к вызову, реализация обобщенной функции действительно меняется в зависимости от классов ее аргументов.

Рассмотрим задачу обновления трех типов окон. Мы можем определить обобщенную функцию под названием refresh, которую можно использовать для обновления любого типа окна. Интерфейс один и тот же, независимо от класса окна. Однако для каждого из трех классов window требуется несколько иная реализация refresh(обновления). Экземпляры window просто очищаются; область экрана, покрытая окном, становится пустой. Для экземпляра window-with-border окно очищается, а граница(border) перерисовывается. Аналогично, для экземпляра window-with-label окно очищается, а метка(label) перерисовывается. На рис. 2.6 показано, что обобщенная функция может иметь несколько отдельных реализаций.

![Рисунок 2.6: Обобщенная функция.](images/f02-06.jpg )**Рисунок 2.6: Обобщенная функция.**

Когда вызывается refresh, CLOS определяет класс аргумента и выбирает соответствующую реализацию для этого класса. Каждая реализация может состоять из одного метода или нескольких методов. Процедура определения того, какие методы следует вызывать, а затем их вызова называется generic dispatch. Это происходит автоматически всякий раз, когда вызывается обобщенная функция.

В примере refresh(обновления) generic dispatch(обобщенная рассылка) использует только один аргумент (окно/window) для выбора реализации. В разделе "Мультиметоды", стр. 75, мы покажем, что generic dispatch(универсальная отправка) CLOS может использовать более одного аргумента для выбора реализации.

## 2.5 МЕТОДЫ(METHODS)

Методы являются основой реализации обобщенных функций. Подобно обычным функциям Лиспа, методы принимают аргументы, выполняют вычисления и, возможно, создают побочные эффекты, такие как вывод и возвращают значения. В отличие от обычных функций Лиспа, методы не вызываются напрямую; они вызываются только процедурой generic dispatch(обобщённой отправки).

Программист прикрепляет метод к обобщенной функции, которую реализует метод, к одному или нескольким классам, указывая в лямбда-списке метода классы аргументов, которые обрабатывает данный метод. Метод вызывается только в том случае, если аргументы обобщенной функции относятся к соответствующим классам.

Например, на рис. 2.7 показано, что к обобщенной функции refresh могут быть присоединены три метода: один для класса window, один для  window-with-label(окна-с-меткой) и один для  window-with-border(окна-с-границей).

![Рисунок 2.7: Методы для refresh.](images/f02-07.jpg)**Рисунок 2.7: Методы для refresh.**

Мы сказали, что все экземпляры класса ведут себя одинаково. Методы реализуют поведение экземпляров. Класс наследует методы своих суперклассов. Например, классы window-with-border и window-with-label наследуют методы класса window.

Не обязательно однозначное соответствие между реализацией набора аргументов и одним методом. Когда вызывается обобщенная функция, аргументы могут выбирать реализацию, состоящую из более чем одного метода.

## 2.6 РОЛИ МЕТОДОВ

CLOS позволяет разделить работу обобщенной функции (для некоторых заданных аргументов) на несколько методов. Эта возможность связана с тем фактом, что методы наследуются и что методы могут иметь разные роли. Роль метода указывает, какую роль он играет в реализации обобщенной функции.

Основной(primary) метод выполняет основную часть работы обобщенной функции. Иногда один основной метод выполняет всю работу обобщеннойй функции для определенного набора аргументов. В других случаях основному методу могут помогать вспомогательные методы, такие как before-(до-) методы и after-(после-) методы. Before-методы вызываются перед основным методом; они могут выполнить настройку раньше других методов. After- методы вызываются после основного метода; они могут выполнять очистку или любые другие вычисления. (CLOS также поддерживает  around-методы, которые мы обсуждаем в разделе «Around-Методы», стр. 102.)

Основной метод возвращает значения обобщенной функции. Методы «до»(before) и «после»(after) предназначены только для получения узких побочных эффектов; они не вызываются для полученя значений.

Учитывая, что классы наследуют методы, эта схема позволяет разделить работу между классом и его суперклассами. Например, один класс может предоставлять основной метод, выполняющий основную часть работы, в то время как другие классы предоставляют вспомогательные методы, выполняющие дополнительную работу.

Реализация refresh(обновления) может извлечь выгоду из этой модели. Все три вида окон должны быть очищены. Таким образом, мы можем определить первичный метод для окна, выполняющего очистку. Для экземпляров window этого метода достаточно.

Этот основной метод для refresh наследуется классами window-with-border и window-with-label. Это желательно, потому что окна обоих классов должны быть очищены, прежде чем делать что-либо еще. Граница экземпляра window-with-border должна быть перерисована; это можно сделать с помощью метода after, присоединенного к классу window-with-border. Таким образом, класс window-with-border(окна с границей) предоставляет вспомогательный метод для выполнения своего специализированного поведения, но наследует основной метод от своего суперкласса. Точно так же нам нужно определить метод after, прикрепленный к классу window-with-label, чтобы перерисовывать метку.

На рис. 2.8 показано, что каждый метод содержит код Лиспа для выполнения некоторой задачи и что у каждого метода есть роль. Реализация обновления распределена между тремя различными методами. Основной метод, прикрепленный к классу окна, выполняет общую часть работы, и этот метод наследуется двумя классами, созданными на основе окна. Когда экземпляр окна обновляется, CLOS вызывает только один метод — основной метод, прикрепленный к классу окна.

![Рисунок 2.8: Роли методов refresh.](images/f02-08.jpg)**Рисунок 2.8: Роли методов refresh.**

На рис. 2.9 показан внутренний вид реализации, выбранной, когда аргументом для refresh является экземпляр window-with-label.

![Рисунок 2.9: Пример общей отправки(generic dispatch) refresh.](images/f02-09.jpg )**Рисунок 2.9: Пример общей отправки(generic dispatch) refresh.**

На рис. 2.9 CLOS выбирает реализацию, состоящую из двух методов: основного метода, присоединенного к классу window, и after- метода, присоединенного к классу window-with-label.

## 2.7 КОНТРОЛЕР НАСЛЕДОВАНИЯ(THE CONTROLLER OF INHERITANCE)

Наследование - это совместное использование характеристик и поведения между набором(множеством) классов. Слоты - это один из примеров унаследованных характеристик. Определения классов могут указывать другие характеристики, такие как значения по умолчанию для слотов; они также наследуются. Поведение представленое методами, которые наследуются. Класс наследуется от всех своих суперклассов.

Когда вы собираете программу из набора классов, важно, чтобы наследование происходило упорядоченным и предсказуемым образом. Например, рассмотрим, что произойдет, если два суперкласса предлагают конкурирующие характеристики, такие как методы для одной и той же обобщенной функции. Как решается такой конфликт?

Эта концепция имеет аналогию в генетике человека: у ребенка может быть ген карих глаз и ген голубых глаз. Цвет глаз ребенка определяется доминированием гена карих глаз над геном голубых глаз. Когда два класса предлагают конкурирующие черты, CLOS разрешает конфликт, проверяя, какой класс имеет приоритет над другим классом.

Когда вы разрабатываете организацию классов, вы определяете отношения приоритета между классами. CLOS вычисляет список приоритетов классов на основе вашей организации. Список приоритетов классов определяет, как наследуются методы, слоты и другие характеристики.

Каждый класс имеет список приоритетов классов(class precedence list), который включает в себя сам класс и все его суперклассы. Классы в списке приоритета классов упорядочены от наиболее специфичных к наименее специфичным. Когда один класс более специфичен, чем другой в этом списке, он имеет приоритет (или доминирование) над другим классом. Таким образом, если два класса обладают конкурирующими признаками, более специфичный класс имеет приоритет над менее специфичным классом. Список приоритетов классов подробно обсуждается позже, в разделе "Список приоритетов классов", стр. 118.

## 2.8 КРАТКОЕ ОПИСАНИЕ МОДЕЛИ CLOS

Объекты реального мира моделируются объектами Lisp, которые называются экземплярами. Вы управляете этими объектами с помощью обобщенных функций. Когда вызываются обобщенные функции, универсальная отправка(generic dispatch) автоматически организует вызов соответствующей реализации на основе классов аргументов.

Структура экземпляра определяется его классом. Каждый экземпляр поддерживает набор именованных слотов, в которых он хранит информацию о состоянии. Все экземпляры данного класса имеют одинаковую структуру и одинаковое поведение. Реализация обобщенной функции в экземпляре состоит из одного или нескольких методов, которые выбираются в соответствии с классом.

Вы можете создавать классы на основе других классов, чтобы наследовать структуру и поведение; это ключевой аспект модульного проектирования. Класс наследует как слоты, так и методы от своих суперклассов.

## 2.9 КАК CLOS РАСШИРЯЕТ COMMON LISP

CLOS - это совместимое расширение для Common Lisp. В этом разделе проводятся параллели между типами Common Lisp и классами CLOS, сравниваются структуры и классы defstruct и основное внимание уделяется новым возможностям, которые предлагает CLOS.

Мы начнем с обсуждения сходства между типами и классами. В Common Lisp каждый объект Lisp имеет тип. В CLOS каждый объект Lisp имеет не только тип, но и класс. CLOS основан на существующей системе типов Common Lisp; он не изобретает совершенно новую систему типов.

Класс - это тип Common Lisp, что означает, что вы можете использовать класс в качестве второго аргумента для typep. Напомним, что typep проверяет, относится ли объект к заданному типу, где "заданный тип" включает в себя сам тип или менее конкретные типы. Поскольку имена классов CLOS являются спецификаторами типов, форма (typep instance class-name) возвращает t, если class-name именует класс или суперкласс экземпляра(instance).

Common Lisp позволяет выбирать операцию на основе типа объекта с помощью typecase. CLOS обеспечивает автоматическую поддержку выбора операции на основе класса объекта. Вы пишете методы, которые привязаны к классам; при вызове обобщенной функции CLOS автоматически выбирает соответствующие методы на основе классов аргументов.

Средство Common Lisp defstruct позволяет вам определить новый тип данных с внутренней структурой, настроенной для вашей программы. Этот новый тип данных может наследоваться от типа, ранее определенного с помощью defstruct. Аналогично, средство CLOS defclass позволяет вам определить новый класс с внутренней структурой, настроенной для вашей программы. Новый класс может наследовать от существующих классов.

Сходство между типами и классами поднимает один важный вопрос. Зачем вообще нужны классы? Следующее сравнение, хотя и не является исчерпывающим, указывает на наиболее важные преимущества классов CLOS.

* CLOS поддерживает автоматическую ассоциацию между кодом и типом объекта. Механизм типизации Common Lisp также предлагает способ связать тело кода с типом объекта. Однако эта ассоциация локализована; необходимо явно использовать typecase в каждом месте, где операция зависит от типа объекта. Чтобы обновить программу для поддержки дополнительных типов объектов, вам потребуется отредактировать каждую форму typecase, чтобы создать связь между новыми типами и операциями, соответствующими этим типам.

* CLOS помогает вам абстрагировать операции, соответствующие различным типам. Вызывающие могут использовать операции над объектами, не зная о том, как эти операции реализуются для различных типов объектов.

* CLOS позволяет вам определять методы, которые внутренне связаны с классом объекта. Процесс выбора операции, соответствующей типу объекта (общая отправка/generic dispatch), полностью автоматизирован. CLOS предоставляет удобный способ постоянной привязки кода к типу объекта и снимает бремя поддержания ссылок в формах typecase.

* CLOS обеспечивает множественное наследование. С помощью defstruct вы можете создать новый тип из одного типа компонента, используя опцию :include. В отличие от этого, defclass позволяет вам создавать новый класс из любого количества классов компонентов. Множественное наследование CLOS обеспечивает гораздо большую гибкость и мощь, чем одиночное наследование defstruct.

* CLOS предлагает гибкое наследование поведения. CLOS поддерживает наследование структуры во многом так же, как это делает Common Lisp defstruct. Хотя и структуры defstruct, и классы наследуют слоты от своих компонентов, механизмы CLOS для наследования поведения гораздо более мощные, чем ограниченные механизмы Common Lisp defstruct.

Структура Common Lisp defstruct может использовать любые средства доступа для чтения или записи слотов, предоставляемых ее компонентом; это степень наследования поведения. В отличие от этого, CLOS поддерживает гораздо более прозрачные и гибкие средства наследования поведения: классы наследуют методы от своих суперклассов. Класс может переопределять унаследованное поведение, предоставляя первичный метод, который затеняет унаследованный метод. Класс может изменять унаследованное поведение, добавляя метод до(before-) или после( after-), чтобы настроить работу, выполняемую унаследованным основным методом. Кроме того, CLOS предлагает несколько продвинутых методов, которые дают вам дополнительный контроль над наследованием поведения.