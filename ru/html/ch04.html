<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
</head> 

<body bgcolor="white" text="black">
<h1>Программирование с помощью методов</h1>

<p>Программа блокировки проиллюстрировала основные функции CLOS. В этой главе описываются дополнительные полезные методы, в том числе как написать методы для выполнения следующих действий:</p>

<ul>
<li>Представление информации без сохранения ее в слотах</li>
<li>Добавление поведения к обобщенной функции средства доступа(accessor)</li>
<li>Специализироваться на более чем одном аргументе</li>
<li>Специализироваться на типах Common Lisp, таких как строки и массивы</li>
<li>Специализироваться на отдельном объекте Lisp</li>
</ul>

<p>В этой главе мы используем три примера. Первый пример представляет треугольники как экземпляры классов и демонстрирует различные способы хранения информации, связанной с треугольниками. Второй пример представляет собой программу установки, предназначенную для установки различных программных продуктов в разных операционных системах; показано, как писать методы, которые специализируются на более чем одном аргументе. Третий пример - это программа, поддерживающая удаленную оценку/выполнение, которая иллюстрирует методы, специализирующиеся на типах Common Lisp и на отдельных объектах Lisp.</p>

<h2>4.1 ВАРИАНТЫ РЕАЛИЗАЦИИ: МЕТОДЫ ПРОТИВ СЛОТОВ</h2>

<p>CLOS поддерживает несколько способов представления определенных видов информации, связанных с экземпляром или классом. В этом разделе вводится концепция общего(для всех экземпляров класса) слота и обсуждаются плюсы и минусы представления информации в слотах по сравнению с методами.</p>

<h3>Локальные и общие(Shared) слоты</h3>

<p>Существует два вида слотов. Локальный слот хранит информацию о состоянии конкретного экземпляра. Каждый экземпляр поддерживает свою индивидуальную копию слота со своим собственным значением. Это тип слота по умолчанию. Все слоты, упомянутые ранее в этой книге, являются локальными.</p>

<p>Общий слот хранит информацию о состоянии класса в целом. Существует только одно значение общего слота; оно связано с классом и совместно используется всеми экземплярами класса. Если один экземпляр изменяет значение общего слота, новое значение будет видно всем экземплярам, если они прочитают слот.</p>

<p>Например, мы могли бы определить класс с именем triangle. Каждый экземпляр хранит длину своих трех сторон в локальных слотах с именами side-a, side-b и side-c. Это должны быть локальные слоты, чтобы каждый экземпляр мог отслеживать свои собственные измерения.</p>

<p>Предположим, класс triangle является одним из нескольких классов в программе, которая обрабатывает геометрические фигуры. Протокол shape(фигуры) гласит, что обобщенная функция number-of-sides возвращает количество сторон заданной фигуры. Для класса triangle мы можем сохранить эту информацию в общем слоте с именем number-of-sides и предоставить для него метод считывания. Общий слот подходит, поскольку все экземпляры класса triangle имеют одинаковое количество сторон.</p>

<p><img src="images/f04-01.jpg " alt="Рисунок 4.1: Локальные и общие слоты." /><strong>Рисунок 4.1: Локальные и общие слоты.</strong></p>

<p>На рисунке 4.1 показано, что каждый экземпляр хранит свои индивидуальные значения для локальных слотов side-a, side-b и side-c, но существует только одно значение для общего количества сторон слота. Локальные слоты хранятся внутри каждого экземпляра, а общие слоты хранятся внутри самого класса.</p>

<p>Форма defclass определяет слоты и управляет тем, является ли слот локальным или общим. Параметр слота :allocation  указывает, является ли слот локальным или общим. Значение по умолчанию равно :allocation :instance(экземпляр), что означает, что слот является локальным. Чтобы указать, что слот должен быть общим, вы указываете параметр :allocation :class.</p>

<p>Следующая форма defclass определяет три локальных слота и один общий слот для класса triangle:</p>

<pre>
(defclass triangle (shape) 
  ((side-a :accessor side-a
           :initarg :side-a) 
   (side-b :accessor side-b
           :initarg :side-b) 
   (side-c :accessor side-c
           :initarg :side-c) 
   (number-of-sides :reader number-of-sides 
                    :initform 3 
                    :allocation :class))) 
</pre>

<p>Считыватель number-of-sides может быть использован для любого экземпляра triangle(треугольника). Метод reader возвращает значение слота с именем number-of-sides, которое является общим для всех экземпляров класса triangle.</p>

<h3>Полезные функции Triangle(Треугольника)</h3>

<p>В следующих примерах мы обозначаем каждый угол треугольника в соответствии с его противоположной стороной. Angle-A(Угол-A) является противоположной side-a(стороной-a) и примыкает к side-b(стороне-b) и side-c(стороне-c). На рисунке 4.2 показано, как углы и стороны связаны друг с другом. Рисунок 4.2 Углы и стороны треугольника. Здесь мы определяем две полезные функции для работы с треугольниками, которые мы используем в следующих примерах:</p>

<p><img src="images/f04-02.jpg " alt="Рисунок 4.2: Углы и стороны треугольника." /><strong>Рисунок 4.2: Углы и стороны треугольника.</strong></p>

<pre>
;;; Return the area of a triangle, given three sides. 
;;; Algorithm is: area - ab(sin C)/2 
(defun area-of-triangle (a b c) 
   (let ((angle-C (three-sides-to-angle c a b))) 
      (* a b (sin angle-C) .5)))

;;; Return the angle A between adjacent sides b and c 
;;; and opposite side a, given all sides of a triangle 
;;; Law of Cosines: aA2 - bA2 + cA2 - 2bc(cos A) 
(defun three-sides-to-angle (a b c) 
   (acos (/ (- (+ (expt b 2) (expt c 2)) 
               (expt a 2)) 
            (* 2 b c)))) 
</pre>

<p>Мы подробно остановимся на примере треугольника в разделе "Пример переопределения элементов CLOS", стр. 144.</p>

<h3>Представление информации Об Экземпляре</h3>

<p>В программе shape нам может потребоваться определить площадь заданной фигуры(area). Существует два способа представления площади фигуры: вычислить ее с помощью метода или сохранить площадь в локальном слоте. Например, вот способы представления площади треугольника:</p>

<pre><code> &gt; Метод                     Определите метод, который вычисляет площадь на основе
 &gt;                               длин сторон треугольника.
</code></pre>

<pre>
(defmethod area ((tri triangle)) 
   (area-of-triangle (side-a tri) 
                     (side-b tri) 
                     (side-c tri))) 
</pre>

<pre><code>&gt;Локальный слот             Определите локальный слот с именем area, в котором
&gt;                                      хранится площадь каждого треугольника и метод считывания
&gt;                                      для этого слота.
</code></pre>

<pre>
(defclass triangle (shape) 
  ((side-a :accessor side-a :initarg :side-a) 
   (side-b :accessor side-b :initarg :side-b) 
   (side-c :accessor side-c :initarg :side-c) 
   (number-of-sides :reader number-of-sides 
                    :initform 3 
                    :allocation :class) 
   (area :reader area :initarg :area))) 
</pre>

<pre><code>&gt;                          Мы должны вычислить площадь при первом создании
&gt;                          треугольника. Один из эффективных способов сделать это
&gt;                          - определить конструктор с именем make-triangle, который
&gt;                          инициализирует area:
</code></pre>

<pre>
(defun make-triangle (side-a side-b side-c) 
   (make-instance 'triangle 
                  :side-a side-a 
                  :side-b side-b 
                  :side-c side-c 
                  :area (area-of-triangle 
                         side-a side-b side-c))) 
</pre>

<pre><code>&gt;                          Поскольку многим программам необходимо выполнять
&gt;                          инициализацию, подобную этой, CLOS предоставляет технику,
&gt;                          специально предназначенную для этой цели, называемую
&gt;                          методами инициализации; мы обсуждаем их в разделе
&gt;                          "Управление инициализацией с помощью методов", стр. 159.

&gt;                          Также необходимо пересчитывать площадь всякий раз, когда
&gt;                          изменяется какая-либо из длин сторон, что мы демонстрируем
&gt;                          в разделе "Определение вспомогательных методов для средств
&gt;                          доступа(Accessors)", стр. 71.
</code></pre>

<p>Независимо от того, какой выбор реализации вы сделаете, клиент получает area одним и тем же способом: вызывая обобщенную функцию area. Выбор внутреннего представления остается за программистом. Эффект от использования метода для вычисления площади каждый раз таков: требуется меньше места для хранения, а создание объекта и обновление длины стороны выполняются быстрее, но запрос площади(area) выполняется медленнее. Эффекты хранения площади(area) в слоте таковы: запрос  area выполняется быстрее, но может потребоваться больше места для хранения, а создание объекта и обновление длины стороны выполняются медленнее.</p>

<h3>Представление информации О Классе</h3>

<p>Мы уже упоминали о необходимости представления информации, связанной с классом, такой как количество сторон треугольников. CLOS предлагает два способа сделать это:</p>

<pre><code>&gt; Метод                Определите метод, который возвращает информацию.
&gt;                           Количество сторон "хранится" только в теле метода, а не
&gt;                           в слоте.
</code></pre>

<pre>
(defmethod number-of-sides ((tri triangle))
   3) 
</pre>

<pre><code>&gt; Общий слот                Определите общий слот и метод считывания для обобщенной
&gt;                                   функции number-of-sides. Две формы defclass для triangle,
&gt;                                   приведенные ранее, показывают, как определить общий слот
&gt;                                   (используйте параметр слота :allocation :class) и метод
&gt;                                   считывания (укажите параметр слота :reader number-of-sides
&gt;                                   с числом сторон считывателя).
</code></pre>

<p>Здесь компромисс заключается между скоростью запроса и удобством обновления информации, связанной с классом. Когда метод хранит информацию, запрос, вероятно, выполняется быстрее, поскольку доступ к слоту не требуется. Этот метод также может сэкономить место для хранения, поскольку информация хранится одним способом, а не в слоте и способе считывания. Однако единственный способ изменить информацию - это переопределить метод. Этот подход работает, но он требует программирования (нахождения определения метода, его редактирования и компиляции), а не просто использования программы (вызова обобщенной функции writer). В некоторых приложениях вы можете разумно предположить, что информация, связанная с классом, никогда не изменится, поэтому обновление не является проблемой. Например, мы знаем, что количество сторон треугольника всегда будет равно 3, и нет необходимости когда-либо обновлять эту информацию. Однако в других контекстах может потребоваться изменить информацию, связанную с классом.</p>

<p>Когда информация хранится в общем слоте, вы можете удобно изменить ее, используя обобщенную функцию записи. Однако (в зависимости от реализации CLOS) запрос может выполняться медленнее и может использоваться больше места для хранения.</p>

<h2>4.2 ПРОГРАММИРОВАНИЕ С ПОМОЩЬЮ СРЕДСТВ ДОСТУПА(ACCESSORS)</h2>

<p>В этом разделе описывается, как изменить поведение обобщенной функции доступа, и обсуждаются различные способы доступа к слотам.</p>

<h3>Автоматически Сгенерированные Средства доступа(Accessors)</h3>

<p>Предоставляя defclass параметр слота :accessor, вы просите CLOS сгенерировать метод для обобщенной функции reader и метод для обобщенной функции writer. Метод reader просто возвращает значение слота, а метод writer записывает новое значение в слот.</p>

<p>Это первичные методы, которые ведут себя так же, как и любой другой первичный метод, что означает, что вы можете написать вспомогательные методы для выполнения дополнительных вычислений. То есть вы можете определить методы before и after, чтобы улучшить поведение первичных методов для обобщенных функций reader и writer.</p>

<h3>Определение вспомогательных методов для средств доступа(Accessors)</h3>

<p>Здесь мы продолжаем использовать пример с треугольником(triangle). Напомним, что определение класса triangle предоставляет опцию слота :accessor для генерации методов для устройства чтения с именем side-a и соответствующего устройства записи с именем (setf side-a).</p>

<p>Ранее мы упоминали о возможности сохранения площади треугольника в слоте и пересчета площади каждый раз, когда изменяется длина стороны треугольника. Чтобы использовать этот подход, нам нужен метод, который будет выполняться каждый раз, когда новое значение сохраняется в любом из слотов side-a, side-b или side-c. Мы можем сделать это, определив after-методы для обобщенной функций writer (setf side-a), (setf side-b) и (setf side-c).</p>

<p>Вы можете использовать defmethod для написания вспомогательного метода для обобщенной функции reader или обобщенной функции writer. Первый аргумент - это имя обобщенной функции, которое для читателя является символом, а для записи - списком, таким как (setf symbol). В методах для обобщенной функций записи первый параметр в лямбда-списке является параметром для нового значения, которое будет записано в слот. Например:</p>

<pre>
(defmethod (setf side-a) :after (new-length (tri triangle)) 
   (setf (area tri) 
         (area-of-triangle new-length 
                           (side-b tri) 
                           (side-c tri)))) 
</pre>

<p>Это after-метод, который выполняется после основного метода для (setf side-a). Этот метод вычисляет площадь треугольника и сохраняет ее в слоте area каждый раз, когда вызывается функция записи (setf side-a). Нам нужно было бы написать аналогичные  after- методы для (setf side-b) и (setf side-c), чтобы гарантировать, что area обновляется всякий раз, когда изменяется какая-либо из длин сторон.</p>

<h2>Определение основных методов для средств доступа(Accessors)</h2>

<p>Опции слотов :accessor, :reader и :writer являются удобными функциями CLOS. Вы могли бы реализовать основные методы для чтения и записи слота самостоятельно, используя defmethod. Тело метода чтения будет использовать примитивное значение слота для считывания значения слота, где в качестве метода записи будет использоваться setf со значением слота.</p>

<p>Например, в нашем предыдущем определении для класса triangle мы дали параметр :accessor для определения reader и writer для side-a. В качестве альтернативы, мы могли бы вручную определить основные методы для читателей и авторов.</p>

<pre>
;;; Defining the reader side-a 
(defmethod side-a ((tri triangle)) 
   (slot-value tri 'side-a)) 

;;; Defining the writer (setf side-a) 
(defmethod (setf side-a) (new-side-a (tri triangle)) 
   (setf (slot-value tri 'side-a) new-side-a))
</pre>

<p>Обычно нет никакого преимущества в определении основного метода средства доступа вручную, потому что почти во всех случаях вы хотите, чтобы основной метод просто считывал или записывал значение слота. Когда вам нужно сделать что-то особенное, вы можете предоставить метод "до"(before-) или "после"(after-) для работы в сочетании с основным методом, вместо предоставления специального основного метода.</p>

<h3>Средства доступа(Accessors) против slot-value</h3>

<p>Реализация первичных методов для средств доступа(accessors) (независимо от того, генерируется ли метод автоматически CLOS или определяется вручную) выполняется в терминах slot-value(значения слота). Вы можете прочитать значение любого слота с помощью slot-value, и вы можете записать значение слота, используя setf с помощью slot-value. Важно понимать разницу между использованием slot-value(значения слота) и использованием средства доступа(accessor).</p>

<p>Ожидается, что клиенты программы будут использовать средства доступа(accessors) для чтения и записи слотов, поскольку средства доступа обычно являются рекламируемым(объявляемым) интерфейсом. Напротив, slot-value является базовой реализацией средств доступа и не предназначен для использования в других контекстах. Чтобы вызвать slot-value, вам необходимо знать название слота, которое является строго внутренней деталью программы. Рассмотрим, что произойдет, если разработчик изменит внутреннее представление этой информации, изменив имя слота или сохранив информацию в методе вместо слота: предположительно, разработчик определяет новые методы для обобщенных функций, чтобы заменить методы доступа, поэтому вызывающие объявленные обобщенные функции продолжают работать. Однако любые вызывающие slot-value для этого слота будут признаны недействительными.</p>

<p>slot-value обращается к слоту напрямую, без вызова каких-либо методов доступа. Это является недостатком, если программа зависит от методов доступа для выполнения необходимой работы, связанной с доступом к слоту. Напомним, что в примере треугольника используются after-методы для записи слотов длины стороны для обновления области; если вы используете setf из slot-value для записи значения длины стороны, значение слота области будет неверным, поскольку методы доступа не будут вызваны.</p>

<p>Вы должны использовать slot-value для двух целей: если вы хотите определить средство доступа вручную или если вы хотите получить доступ к слоту без вызова каких-либо методов доступа. Последнее использование slot-value может быть полезно при отладке программы.</p>

<h3>Использование with-accessors и with-slots</h3>

<p>Другой способ получить доступ к слотам - использовать with-accessors или with-slots, два макроса, которые позволяют вам получать доступ к слотам с помощью имен переменных. В теле with-accessors использование переменной имеет тот же эффект, что и вызов соответствующей обобщенной функции accessor. В отличие от этого, with-slots переводит использование переменной в вызов slot-value, поэтому методы доступа не вызываются.</p>

<p>Цель этих макросов - упростить части кода, которые часто обращаются к слотам, за счет поддержки синтаксиса быстрого доступа. Таким образом, использование with-accessors - это ярлык для вызова средств доступа, а использование with-slots - это ярлык для вызова slot-value. Использование этих макросов может привести к более сжатому коду, особенно когда тела методов часто используют либо средства доступа, либо значение слота.</p>

<p>В примере с треугольником нам может понадобиться метод для возврата угла A, который противоположен стороне a и примыкает к сторонам b и c. Здесь мы показываем два эквивалентных способа доступа к сторонам.</p>

<p>Вызываем читателей чтобы получить сторону:</p>

<pre>
(defmethod angle-A ((tri triangle)) 
   (three-sides-to-angle (side-a tri) 
                         (side-b tri) 
                         (side-c tri))) 
</pre>

<p>Используем with-accessors, чтобы получить стороны:</p>

<pre>
(defmethod angle-A ((tri triangle)) 
   (with-accessors ((a side-a) 
                    (b side-b) 
                    (c side-c)) 
       tri 
      (three-sides-to-angle a b c))) 
</pre>

<p>Вы также можете записать значение слота, используя setq или setf с переменной. В следующей таблице показано, как переменные могут быть использованы в теле формы with-accessors в показанном методе:</p>

<table>
<thead>
<tr>
  <th>This Form</th>
  <th>Translates to This Form</th>
</tr>
</thead>
<tbody>
<tr>
  <td>a</td>
  <td>(side-a tri)</td>
</tr>
<tr>
  <td>(setq a value)</td>
  <td>(setf (side-a tri) value)</td>
</tr>
<tr>
  <td>(setf a value)</td>
  <td>(setf (side-a tri) value)</td>
</tr>
</tbody>
</table>

<p>Макрос with-accessors требует, чтобы вы указали переменную (например, a) для каждого аксессуара (например, side-a). Хотя вы можете указать, что переменная должна иметь тот же символ, что и средство доступа, для этого не существует краткого синтаксиса; вам всегда нужно перечислять имена как переменной, так и средства доступа.</p>

<p>Макрос with-slots имеет краткий синтаксис: вы перечисляете слоты, к которым хотите получить доступ, а затем можете получить к ним доступ по их именам. Здесь мы показываем два эквивалентных способа прямого доступа к слотам — вызов slot-value и использование with-slots:</p>

<pre>
;;; Using slot-value to access the slots 
(defmethod angle-A ((tri triangle)) 
   (three-sides-to-angle (slot-value tri 'side-a) 
                         (slot-value tri 'side-b) 
                         (slot-value tri 'side-c))) 

;;; Using with-slots to access the slots 
(defmethod angle-A ((tri triangle)) 
   (with-slots (side-a side-b side-c) 
       tri 
      (three-sides-to-angle side-a side-b side-c))) 
</pre>

<p>В следующей таблице показано, как переменные могут быть использованы в теле формы with-slots в показанном методе:</p>

<table>
<thead>
<tr>
  <th>Эта форма</th>
  <th>Переводится в эту форму</th>
</tr>
</thead>
<tbody>
<tr>
  <td>a</td>
  <td>(slot-value tri 'side-a)</td>
</tr>
<tr>
  <td>(setq a value)</td>
  <td>(setf (slot-value tri 'side-a) value)</td>
</tr>
<tr>
  <td>(setf a value)</td>
  <td>(setf (slot-value tri 'side-a) value)</td>
</tr>
</tbody>
</table>

<p>Обратите внимание, что при использовании with-slots или with-accessors форма экземпляра оценивается только один раз.</p>

<h3>Донастройка поведения несвязанных слотов</h3>

<p>Если слот не инициализирован, и никакое значение не было сохранено в нем с помощью записи, слот не привязан. Если вы попытаетесь прочитать значение несвязанного слота, будет выдан сигнал об ошибке.</p>

<p>Поведение по умолчанию (сигнализация об ошибке) поддерживается обобщенной функцией slot-unbound. То есть, если вы пытаетесь прочитать несвязанный слот, CLOS вызывает обработчик исключений slot-unbound. Обобщенная функция slot-unbound имеет системный метод по умолчанию, который сигнализирует об ошибке; вы можете специализировать эту обобщенную функцию, если хотите изменить то, что происходит, когда несвязанные слоты считываются в экземплярах определенного класса.</p>

<h2>4.3 МУЛЬТИМЕТОДЫ</h2>

<p>Многие объектно-ориентированные программы могут быть написаны с использованием методов, которые специализируются только на одном параметре. Однако иногда полезно писать методы, которые специализируются более чем на одном параметре. Они называются мультиметодами.</p>

<p>Техника использования мультиметодов предназначена для операций, реализация которых действительно зависит от типа более чем одного аргумента.</p>

<p>Мы вводим несколько методов, обсуждая сценарий инициализации. Предположим, компания продает различные программные продукты, каждый из которых может работать на различных операционных системах. Процедура установки зависит от типа программного продукта и от типа операционной системы. Эта компания хочет предоставить универсальную программу установки для автоматизации процесса установки.</p>

<p>В настоящее время компания поддерживает два программных продукта, Life и Adventure, в двух операционных системах, Genera и Unix. Компания планирует поддерживать дополнительные программные продукты и операционные системы в будущем, поэтому программа установки должна быть расширяемой. В этом примере мы используем следующее представление программных продуктов и операционных систем:</p>

<ul>
<li>Программные продукты представлены классами life и adventure</li>
<li>Все программные продукты построены на классе basic-product</li>
<li>Операционные системы представлены классами genera и unix</li>
<li>Все операционные системы построены на классе basic-os</li>
</ul>

<h3>Проверка аргументов с помощью мультиметодов</h3>

<p>Мы хотим предоставить одну функцию верхнего уровня для установки любого из наших поддерживаемых продуктов в любую из поддерживаемых нами операционных систем. Мы можем сделать это с помощью обобщенной функции install, которая ожидает программный продукт в качестве первого аргумента и операционную систему в качестве второго аргумента:</p>

<pre>
(defgeneric install (software-product operating-system) 
   (:documentation "Installs software on the operating system.")) 
</pre>

<p>Метод 1 применим, когда оба аргумента допустимы; то есть первый аргумент имеет тип basic-product, а второй аргумент имеет тип basic-os:</p>

<pre>
;;; Method 1 
(defmethod install ((sw basic-product) (os basic-os)) 
   body) 
</pre>

<p>Метод 1 является мультиметодом; он специализируется на двух параметрах. Этот метод применим только в том случае, если оба аргумента допустимы. Тело этого метода выполнит инсталяцию. (Пока мы оставляем тело метода пустым.)</p>

<p>Что делать, если пользователь вызывает install с недопустимыми аргументами? То есть, что, если первый аргумент не является программным продуктом, или второй аргумент не является операционной системой, или и то, и другое? CLOS будет искать применимые методы, не найдет ни одного и выдаст сообщение об ошибке типа "Нет применимого метода".</p>

<p>Такое сообщение об ошибке не дает понять, была ли ошибка вызвана ошибкой в программе или неправильным типом ввода, введенного пользователем. Для средства установки мы должны предоставить пользователю более информативное сообщение об ошибке. Мы можем предложить три метода для выполнения этой работы.</p>

<pre>
;;; Method 2 
(defmethod install ((sw basic-product) non-os) 
   (error "Cannot install because ~A is not 
a recognized operating system." non-os)) 

;;; Method 3 
(defmethod install (non-product (os basic-os)) 
   (error "Cannot install because ~A is not a 
recognized software product." non-product)) 

;;; Method 4 
(defmethod install (non-product non-os) 
   (error "Cannot install because ~A is not a 
recognized software product and -A is not 
a recognized operating system." 
non-product non-os)) 
</pre>

<p>Мы предполагаем, что для любой пары аргументов вызывается только один метод. Если оба аргумента допустимы, для выполнения установки следует вызвать метод 1. В противном случае следует вызвать наиболее подходящий метод из методов 2, 3 и 4, чтобы выдать информативное сообщение.</p>

<p>Методы правильно написаны для выполнения их предполагаемых целей. Поскольку все они являются первичными методами, мы знаем, что вызывается только наиболее конкретный применимый метод. CLOSE выбирает этот метод, сначала находя набор применимых методов, а затем ранжируя эти методы в порядке приоритета. В следующих двух разделах обсуждается применимость и порядок приоритета мультиметодов.</p>

<h3>Применимость Мульти-методов</h3>

<p>CLOS позволяет методам для одной и той же обобщенной функции специализировать любой из требуемых параметров. Методы установки используют преимущества этой гибкости:</p>

<table>
<thead>
<tr>
  <th>Method</th>
  <th>Lambda-list</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Method 1</td>
  <td>((sw basic-product) (os basic-os))</td>
</tr>
<tr>
  <td>Method 2</td>
  <td>((sw basic-product) non-os)</td>
</tr>
<tr>
  <td>Method 3</td>
  <td>(non-product (os basic-os))</td>
</tr>
<tr>
  <td>Method 4</td>
  <td>(non-product non-os)</td>
</tr>
</tbody>
</table>

<p>Когда вызывается install, CLOS ищет применимые методы. Метод применим, если каждому специализированному параметру удовлетворяет соответствующий аргумент обобщенной функции. "Удовлетворено" означает, что аргумент имеет тип специализатора параметра; это экземпляр самого класса или экземпляр подкласса.</p>

<p>Неспециализированный параметр эквивалентен классу t, являющемуся специализатором параметра. Поскольку все объекты имеют тип t, аргумент всегда удовлетворяет неспециализированному параметру. Таким образом, метод 4 применим для любых двух аргументов, независимо от их типов.</p>

<p>Предположим, что install вызывается с двумя допустимыми аргументами. Здесь <code>*life*</code> - это экземпляр life, а <code>*general*</code> - это экземпляр general.</p>

<pre>
;;; Here install is called with two valid arguments, 
(install *life* *genera*) 
</pre>

<p>Оба метода 1 и 2 применимы, как видно из следующих тестов:</p>

<pre>
;;; Method 1 is applicable because these forms are true. 
(typep *life* 'basic-product) 
(typep *genera* 'basic-os) 
;;; Method 2 is applicable because these forms are true. 
(typep *life* 'basic-product) 
(typep *genera* 't) 
</pre>

<p>Аналогичным образом, применимы методы 3 и 4:</p>

<pre>
;;; Method 3 is applicable because these forms are true. 
(typep *life* 't) 
(typep *genera* 'basic-os) 
;;; Method 4 is applicable because these forms are true. 
(typep *life* 't) 
(typep *genera* 't) 
</pre>

<p>Ранее мы заявляли, что метод применим, если каждому специализированному параметру удовлетворяет соответствующий аргумент обобщенной функции.
Это правило справедливо и для мультиметодов. Мы можем уточнить это утверждение, отметив, что все требуемые параметры должны быть удовлетворены, и что любые неспециализированные требуемые параметры обрабатываются так, как если бы они имели класс с именем t в качестве специализаторов параметров.</p>

<table>
<thead>
<tr>
  <th>Правило применимости нескольких методов:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Метод применим, если каждому из его требуемых параметров удовлетворяет</td>
</tr>
<tr>
  <td>соответствующий аргумент обобщенной  функции.</td>
</tr>
<tr>
  <td>Неспециализированный обязательный параметр эквивалентен параметру,</td>
</tr>
<tr>
  <td>который специализируется на классе с именем t.</td>
</tr>
</tbody>
</table>

<p>Когда CLOS находит более одного применимого основного метода, вызывается только самый конкретный из них. Таким образом, CLOS должны ранжировать применимые методы в порядке приоритета. Мы продолжаем этот пример и ранжируем методы с 1 по 4 в порядке приоритета.</p>

<h3>Порядок приоритета нескольких методов</h3>

<p>CLOS ранжирует два применимых метода в порядке приоритета, рассматривая требуемые аргументы метода слева направо по отношению к их спецификаторам параметров. Математики называют это лексико-графическим порядком.</p>

<p>Здесь мы показываем класс специализатора параметров первого требуемого параметра для четырех методов:</p>

<table>
<thead>
<tr>
  <th>Метод</th>
  <th>Первый параметр специализирован на</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Method 1</td>
  <td>basic-product</td>
</tr>
<tr>
  <td>Method 2</td>
  <td>basic-product</td>
</tr>
<tr>
  <td>Method 3</td>
  <td>t</td>
</tr>
<tr>
  <td>Method 4</td>
  <td>t</td>
</tr>
</tbody>
</table>

<p>Список приоритетов классов соответствующего аргумента обобщенной функции определяет, какой из этих классов является более специфичным. Класс первого аргумента, <em>life</em>, - это life, а список приоритетов его класса -</p>

<pre>
(life basic-product t) 
</pre>

<p>Поскольку basic-product(базовый продукт) более специфичен, чем t, методы 1 и 2 более специфичны, чем методы 3 и 4. Чтобы ранжировать приоритет метода 1 по сравнению с методом 2, CLOS переходит к следующему требуемому параметру и сравнивает пару специфицирующих параметров:</p>

<table>
<thead>
<tr>
  <th>Метод</th>
  <th>Второй параметр специализирован на</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Method 1</td>
  <td>basic-os</td>
</tr>
<tr>
  <td>Method 2</td>
  <td>t</td>
</tr>
</tbody>
</table>

<p>Класс второго аргумента, <code>*genera*</code>, является общим, и его список приоритетов классов является</p>

<pre>
(genera basic-os t) 
</pre>

<p>Поскольку basic-os более специфичен, чем t, метод 1 более специфичен, чем метод 2. Используя ту же процедуру, мы обнаруживаем, что метод 3 более специфичен, чем метод 4. Таким образом, порядок приоритета методов таков (метод-1 метод-2 метод-3 метод-4)</p>

<p>Просто взглянув на лямбда-списки методов, вероятно, кажется правильным, что метод 1 является наиболее специфичным (потому что он специализируется на обоих параметрах), а метод 4 является наименее специфичным (потому что он не специализируется ни на одном параметре). Однако интуитивно не очевидно, какой из методов 2 и 3 является более конкретным:</p>

<table>
<thead>
<tr>
  <th>Method</th>
  <th>Lambda-list</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Method 2</td>
  <td>((sw basic-product) non-os)</td>
</tr>
<tr>
  <td>Method 3</td>
  <td>(non-product (os basic-os))</td>
</tr>
</tbody>
</table>

<p>CLOS оценивает метод 2 как более специфичный, чем метод 3, из-за порядка сравнения спецификаторов параметров слева направо. То есть порядок параметров в лямбда-списке влияет на приоритет методов. Поскольку специализатор крайнего левого параметра метода 2 более специфичен, чем специализатор крайнего левого параметра метода 3, метод 2 более специфичен, чем метод 3. Остальные спецификаторы параметров не рассматриваются.</p>

<p>Порядок приоритета параметров слева направо является произвольным по умолчанию. Вы можете изменить его, используя параметр :argument-precedence-order на defgeneric; см. "Краткое описание наследования методов", стр. 98.</p>

<h3>Реализация install(установки)</h3>

<p>Обычно установка программного продукта требует нескольких отдельных шагов, которые должны выполняться в определенном порядке. Мы могли бы обнаружить, что все установки состоят из четырех отдельных этапов:</p>

<ol>
<li>Восстановление программного обеспечения с ленты</li>
<li>Компиляция программной системы</li>
<li>Настройка сайта, чтобы узнать о новом программном обеспечении</li>
<li>Проверка установки программного продукта</li>
</ol>

<p>Мы можем реализовать установку для вызова четырех обобщенных функций. Этот фреймворк позволяет удобно писать код в совместно используемых модулях.</p>

<pre>
(defmethod install ((sw basic-product) (os basic-os)) 
   (restore-product sw os) 
   (compile-product sw os) 
   (configure-site sw os) 
   (verify-product sw os)) 
</pre>

<p>Здесь мы рассмотрим, какие методы необходимы для каждой из четырех операций установки.</p>

<pre><code>    &gt; Restore(Восстановить)     Это, вероятно, использует зависящую от системы функцию для восстановления данных с ленты.
&gt;                          Поскольку эта операция зависит только от типа операционной системы, она может быть
&gt;                          реализована одним основным методом для каждого типа операционной системы:
</code></pre>

<pre>
(defmethod restore-product (sw (os genera)) body) 
(defmethod restore-product (sw (os unix)) body) 
</pre>

<pre><code>&gt;                  Аргумент sw используется для описания того, какой продукт восстанавливать с ленты.
&gt;                  Единственная часть restore-product, которая зависит как от типа продукта, так и от типа
&gt;                  операционной системы, - это путь, по которому должен храниться исходный файл. Тела
&gt;                  методов restore-product вызывают get-source-pathname для получения этой информации:
</code></pre>

<pre>
(defgeneric get-source-pathname (product os) 
   (:documentation "Returns a string.")) 

(defmethod get-source-pathname ((sw life) (os unix)) 
   "/bin/games/life.lsp") 

(defmethod get-source-pathname ((sw adventure) (os unix)) 
   "/bin/games/adventure.lsp") 

(defmethod get-source-pathname ((sw life) (os genera)) 
   "sys:games;life.lisp") 

(defmethod get-source-pathname ((sw adventure) (os genera)) 
   "sys:games;adventure.lisp") 
</pre>

<pre><code>&gt; Compile(Скомпилировать)  эту операцию, вероятно, можно с помощью одного метода по умолчанию.
</code></pre>

<pre>
(defmethod compile-product (sw os) 
(compile-file (get-source-pathname sw os))) 
</pre>

<pre><code>&gt; Configure(Настройка)       Этот шаг настраивает сайт для ознакомления с новым пакетом программного
&gt;                                        обеспечения. Это может включать обновление некоторых файлов конфигурации,
&gt;                                        например, определение местоположения для хранения любых сообщений об
&gt;                                        ошибках, генерируемых программным обеспечением. Этот шаг, вероятно, зависит
&gt;                                        как от типа программного продукта, так и от типа операционной системы:
</code></pre>

<pre>
(defmethod configure-site ((sw life) (os genera)) body) 
(defmethod configure-site ((sw adventure) (os genera)) bod 
(defmethod configure-site ((sw life) (os unix)) body) 
(defmethod configure-site ((sw adventure) (os unix)) body) 
</pre>

<pre><code>&gt; Verify             При этом выполняется набор тестов программного продукта, чтобы убедиться в успешности
&gt;                      установки. Поскольку внутренние тесты работают одинаково для данного программного
&gt;                      продукта независимо от типа операционной системы, методы специализируются только на
&gt;                      параметре программного продукта:
</code></pre>

<pre>
(defmethod verify-product ((sw life) os) body) 
(defmethod verify-product ((sw adventure) os) body) 
</pre>

<p>На этом этапе разработка программы завершена, и остается только реализация. Мы набросали реализацию, полностью основанную на первичных методах. Может случиться так, что этот эскиз не учитывает каждую часть инсталляции. Если мы определим поведение, которое необходимо добавить в этот эскиз, мы всегда можем использовать методы "до"(before-) и "после"(after-).</p>

<p>Такой дизайн обеспечивает разумный протокол. Чтобы добавить поддержку нового программного продукта или другой операционной системы, нам нужно реализовать методы только для подмножества операций установки. Такой дизайн эффективно отделяет сложности операционной системы от программного продукта:</p>

<ul>
<li><p>Мы могли бы добавить новый программный продукт, определив методы для configure-site, verify-product и get-source-pathname.</p></li>
<li><p>Мы могли бы поддерживать новую операционную систему, определив методы для configure-site, restore-product и get-source-pathname.</p></li>
</ul>

<h2>4.4 МЕТОДЫ ДЛЯ ТИПОВ COMMON LISP</h2>

<p>CLOS предоставляет классы, соответствующие некоторым (но не всем) стандартным типам Common Lisp. Имя такого класса совпадает с именем типа. Например, существует класс с именем array, соответствующий типу array. Эти классы предоставляются по единственной причине: чтобы вы могли писать методы, которые специализируются на типах Common Lisp.</p>

<h3>Классы, соответствующие типам COMMON LISP</h3>

<p>Мы уже видели один пример класса, соответствующего типу Common Lisp — класс t, который соответствует типу t. Класс t отображается как последний (наименее специфичный) класс во всех списках приоритета классов, включая классы, определенные пользователями, и классы, предоставляемые CLOS.</p>

<p>В таблице 4.1 перечислены классы, соответствующие типам Common Lisp, и список приоритетов каждого класса. Эта таблица адаптирована из "Спецификации объектной системы Common Lisp" с разрешения авторов.</p>

<table>
<thead>
<tr>
  <th>Класс</th>
  <th>Список приоритетов классов</th>
</tr>
</thead>
<tbody>
<tr>
  <td>array</td>
  <td>(array t)</td>
</tr>
<tr>
  <td>bit-vector</td>
  <td>(bit-vector vector array sequence t)</td>
</tr>
<tr>
  <td>character</td>
  <td>(character t)</td>
</tr>
<tr>
  <td>complex</td>
  <td>(complex number t)</td>
</tr>
<tr>
  <td>cons</td>
  <td>(cons list sequence t)</td>
</tr>
<tr>
  <td>float</td>
  <td>(float number t)</td>
</tr>
<tr>
  <td>integer</td>
  <td>(integer rational number t)</td>
</tr>
<tr>
  <td>list</td>
  <td>(list sequence t)</td>
</tr>
<tr>
  <td>null</td>
  <td>(null symbol list sequence t)</td>
</tr>
<tr>
  <td>number</td>
  <td>(number t)</td>
</tr>
<tr>
  <td>ratio</td>
  <td>(ratio rational number t)</td>
</tr>
<tr>
  <td>rational</td>
  <td>(rational number t)</td>
</tr>
<tr>
  <td>sequence</td>
  <td>(sequence t)</td>
</tr>
<tr>
  <td>string</td>
  <td>(string vector array sequence t)</td>
</tr>
<tr>
  <td>symbol</td>
  <td>(symbol t)</td>
</tr>
<tr>
  <td>t</td>
  <td>(t)</td>
</tr>
<tr>
  <td>vector</td>
  <td>(vector array sequence t)</td>
</tr>
</tbody>
</table>

<p>Таблица 4.1 Приоритет классов, соответствующих типам Common Lisp.</p>

<p>Эти классы имеют множественное наследование. Отношения класса/подкласса между ними параллельны отношениям типа/подтипа, описанным в книге Стила Common LISP: The Language. Рассмотрим вектор типа:</p>

<ul>
<li>Тип vector - это подтип sequence(последовательности) и array(массива)</li>
<li>Класс vector является подклассом sequence и array</li>
</ul>

<p>Для каждого класса, соответствующего типу Common Lisp, если Common LISP:
Язык определяет отношение тип/подтип, соответственно определяется отношение класс/подкласс. Однако в некоторых случаях не было указано соотношение тип/подтип, и рабочая группа CLOS приняла решение о порядке приоритета. Например, строка типа является подтипом как массива, так и последовательности, но Common Lisp не определяет отношения типа/подтипа между массивом и последовательностью. Рабочая группа CLOS решила, что массив должен предшествовать последовательности в списке приоритета класса для строки,</p>

<p>Для каждого класса должен быть полностью определенный список приоритетов классов, чтобы CLOS могли выбирать приоритет методов. Одна из причин, по которой рабочая группа CLOS не указала, что все типы Common Lisp должны иметь соответствующие классы, заключается в том, что некоторые типы имеют неопределенные отношения с другими типами, и было бы трудно определить порядок приоритета типов. Например, рассмотрим, что произойдет, если аргументом является экземпляр 7, и применимы два метода: один специализируется на (integer 0 10), а другой специализируется на (integer 5 15) — какой метод следует считать более конкретным? Поскольку семантика некоторых типов не поддается строгому порядку приоритета, у этих типов нет соответствующих классов.</p>

<p>Если тип Common Lisp не имеет соответствующего класса, вы не можете определить метод, который специализируется на этом типе. CLOS не поддерживает классы для спецификаторов типов, которые являются списками, такими как</p>

<pre>
(integer 0 10) 
(string 25) 
(not number) 
(vector (mod 256)) 
</pre>

<h3>Встроенные классы</h3>

<p>Обычно классы, соответствующие типам Common Lisp, реализуются как "встроенные классы", что означает, что они не обладают всеми свойствами классов, определенных с помощью defclass. Встроенные классы реализуются особым, зависящим от системы способом, чтобы использовать преимущества архитектуры машины или по другим причинам. По большей части, не имеет смысла реализовывать эти классы с помощью defclass, потому что они не совсем вписываются в эту модель.</p>

<p>Решение о том, как реализовать классы, соответствующие типам Common Lisp, принимается каждой реализацией CLOS. Любой из этих классов может быть реализован как встроенный класс или как класс, определяемый пользователем.
Хотя встроенные классы в некоторых отношениях следуют модели CLOS (они имеют множественное наследование; у них есть экземпляры; они наследуются от класса t, и вы можете определить методы, которые специализируются на них), они отличаются от модели другими способами. Это существенные различия между встроенными классами и пользовательскими классами:</p>

<ul>
<li><em>Structure</em>.    Структура пользовательского класса представлена в виде слотов. Однако внутренняя структура встроенных классов обычно не представлена слотами. Например, значение символа, вероятно, не хранится в слоте в большинстве реализаций CLOS.</li>
<li><em>Creation of instances</em>(<em>Создание экземпляров</em>). Для создания экземпляров пользовательских классов вы можете использовать make-instance. Однако CLOS не позволяет использовать make-instance для создания экземпляров встроенных классов. Вы используете независимый механизм для создания экземпляров, например, с помощью функции cons для создания экземпляра cons.</li>
<li><em>Use as a superclass</em>(<em>Использовать в качестве суперкласса</em>). CLOS не позволяет вам включать встроенный класс в качестве прямого суперкласса любого пользовательского класса. Единственным исключением из этого правила является класс с именем t, который автоматически является суперклассом каждого класса.</li>
<li><em>Inheritance from</em> standard-object(<em>Наследование от</em> стандартного объекта). Напомним, что standard-object неявно включен как суперкласс пользовательских классов. В отличие от этого, standard-object не является суперклассом встроенных классов. Это различие позволяет реализациям предоставлять методы по умолчанию, предназначенные только для пользовательских классов.</li>
</ul>

<p>Спецификация CLOS определяет набор требований, которым должны следовать реализации в отношении встроенных классов, но она также позволяет реализациям поддерживать расширения в этой области. Вот два расширения, с которыми вы можете столкнуться:</p>

<ul>
<li>Реализации CLOS могут предоставлять классы для других типов Common Lisp в дополнение к тем, которые требуются. Это может включать классы для pathname, package или других. Все такие классы должны придерживаться приоритета, подразумеваемого их отношениями типа/подтипа, определенными в Common LISP Стила: The Language.</li>
<li>Как упоминалось ранее, реализации CLOS могут выбрать реализацию класса для любого типа Common Lisp либо как встроенного класса (который соответствует указанным ограничениям), либо как определяемого пользователем класса. Например, реализация CLOS может свободно определять строку класса с помощью defclass. Когда это будет сделано, вы сможете делать со строкой класса все, что вы можете делать с другими классами, определенными defclass.</li>
</ul>

<p>Обратите внимание, что программы, которые зависят от расширений для CLOS, нелегко переносить на другие реализации CLOS.</p>

<h3>Примеры методов для типов COMMON LISP</h3>

<p>Мы можем проиллюстрировать определение методов для типов Common Lisp, реализовав простой сетевой протокол для выполнения удаленного выполнения(оценки). Эта программа позволяет пользователю отправлять форму Lisp на другой компьютер по сети и получать результат вычисления(оценки) этой формы. Машина, которая отправляет форму, называется клиентской машиной, а машина, которая выполняет вычисления и возвращает результат клиенту, называется серверной машиной.</p>

<p>Часть этой программы, относящаяся к типам Common Lisp, заключается в отправке и получении объектов Lisp по сети. Объект Lisp живет в одном мире Lisp, и передавать фактический объект невозможно или желательно. Вместо этого клиентская машина кодирует объект Lisp в представление, подходящее для отправки по сети. С другой стороны, серверная машина декодирует представление и создает или получает объект Lisp, эквивалентный объекту, который был закодирован. Результат вычисления затем кодируется сервером, передается и декодируется клиентской машиной.</p>

<p>На рисунке 4.3 показано взаимодействие между клиентской и серверной машинами во время удаленного вычисления/оценки.</p>

<p><img src="images/f04-03.jpg " alt="Рисунок 4.3: Удаленное вычисление/оценка." /><strong>Рисунок 4.3: Удаленная вычисление/оценка.</strong></p>

<p>Декодирование и кодирование аналогичны операциям чтения и печати Lisp: Программа чтения Lisp принимает введенное представление объекта и генерирует объект Lisp; принтер принимает объект Lisp и генерирует его представление, подходящее для печати. Подобно принтеру и считывателю, методы декодирования и кодирования сохраняют только "простые" характеристики объектов. Например, содержимое массива кодируется, но любой указатель на заполнение - нет.</p>

<p>Реализация кодирования использует преимущества классов, соответствующих типам Common Lisp. Программа удаленного вычисления поддерживает передачу простых объектов Lisp, таких как списки, целые числа, символы, строки, символы и векторы. Мы предоставляем методы для кодирования этих объектов; эти методы специализируются на классах, соответствующих различным типам объектов. Можно расширить эту модель, чтобы отправлять экземпляры пользовательских классов, а также, предоставляя методы кодирования и декодирования для этих классов.</p>

<p>Хотя основной смысл этого примера состоит в том, чтобы показать кодирование и декодирование, для полноты картины мы также описываем функции верхнего уровня, которые вызывают обобщенные функции кодирования и декодирования.</p>

<h3>Пример Сеанса Удаленного Вычисления</h3>

<p>Мы начнем с описания того, как использовать программу удаленного вычисления. Мы создаем remote-eval-stream и вызываем функцию remote-eval для отправки форм в поток и получения результатов. Наконец, мы закрываем поток:</p>

<pre>
(setq *my-stream* (make-remote-eval-stream server-machine)) 
(remote-eval *my-stream* "hello") => "hello" 
(remote-eval *my-stream* '(+ 1 23)) => 24 
(close *my-stream*)
</pre>

<h3>Функции Верхнего уровня</h3>

<p>make-remote-eval-stream создает сетевое подключение к серверной машине и возвращает двунаправленный двоичный восьмибитный поток байтов. Как только поток создан, на сервере запускается процесс для выполнения функции eval-server (определенной ниже). Закрытие этого потока завершает серверный процесс и закрывает сетевое соединение. Поскольку реализация make-remote-eval-stream обязательно специфична для операционной системы, она здесь не приводится.</p>

<p>remote-eval реализует клиентскую часть; он отправляет форму на сервер, получает результат оценки этой формы и возвращает результат. Форма вычисляется в среде сервера, и любые побочные эффекты происходят в этой среде. Этот пример не передает распечатанный вывод, не передает несколько возвращаемых значений и не обрабатывает ошибки, сгенерированные при оценке формы на сервере; любая из этих функций может быть добавлена.</p>

<pre>
;;; This must be defined on the client machine, 
(defun remote-eval (stream form) 
   (encode form stream) 
   (force-output stream) 
   ;; Read the return value 
   ;; The first byte is a control byte 
   (decode (read-byte stream) stream)) 
</pre>

<p>eval-server реализует серверную часть; он постоянно считывает отправленные ему формы, вычисляет/оценивает формы и возвращает результаты. Когда поток закрывается, этот процесс завершается.</p>

<pre>
;;; This must be defined on the server machine, 
(defun eval-server (stream) 
   (loop (encode 
          (eval (decode (read-byte stream) stream)) 
          stream) 
         (force-output stream)))
</pre>

<h3>Протокол кодирования и декодирования</h3>

<p>Основная часть программы заключается в кодировании и декодировании объектов Lisp. Для этой цели мы будем использовать простой протокол. Чтобы закодировать объект, мы сначала передаем по потоку управляющий байт, который объявляет тип объекта. (Управляющий байт - это восьмибитный байт.) Затем мы кодируем и передаем представление самого объекта; реализация этого варьируется в зависимости от типа объекта. При декодировании мы считываем управляющий байт из потока; этот байт указывает, какой тип объекта передается. Затем мы декодируем следующие байты и преобразуем закодированное представление в объект Lisp. Реализация декодирования объекта зависит от типа объекта.</p>

<p>Способ кодирования любого объекта одного типа (например, symbols/символов) работает вместе со способом декодирования объекта такого типа. Эти методы должны использовать одну и ту же технику для кодирования и декодирования. Однако способы кодирования и декодирования объектов другого типа (таких как символы) могут использовать совершенно иную технику кодирования и декодирования, чем техника, используемая для символов. Единственное требование заключается в том, что метод декодирования для любого данного типа объекта должен понимать, как работает метод кодирования для этого типа объекта.</p>

<p>Наш протокол состоит из двух обобщенных функций:</p>

<pre>
(defgeneric encode (object stream) 
   (:documentation 
    "Encode object and send the result to stream.")) 

(defgeneric decode (code stream) 
   (:documentation 
    "Based on the code, read an encoded representation 
from the stream, decode, and create an object.")) 
</pre>

<p>Это расширяемый протокол; его несложно расширить для поддержки дополнительных типов объектов. Для этого мы бы предоставили методы кодирования и декодирования. Нет необходимости изменять код, который вызывает encode и decode. Это одно из очевидных преимуществ использования обобщенных функций вместо того, чтобы вызывающие использовали typecase для выбора кода для кодирования и декодирования различных типов объектов.</p>

<p>В этом примере показано, как кодировать и декодировать несколько типов объектов. Каждый тип объекта имеет соответствующий управляющий байт. Эти управляющие байты являются</p>

<pre>
(defconstant %positive-integer 1) 
(defconstant %negative-integer 2) 
(defconstant Icharacter 3) 
(defconstant Isymbol A) 
(defconstant Istring 5) 
(defconstant Hist 6) 
(defconstant %vector 7) 
</pre>

<h3>Кодирование целых чисел</h3>

<p>Чтобы закодировать целое число, мы отправляем управляющий байт, указывающий положительное или отрицательное целое число, затем длину целого числа, затем абсолютное значение самого целого числа. Длина целого числа всегда передается в одном байте.</p>

<pre>
(defmethod encode ((num integer) stream) 
   (cond ((minusp num) 
          (write-byte %negative-integer stream) 
          (setq num (abs num))) 
         (t 
          (write-byte %positive-integer stream))) 
   (let ((n-bytes (ceiling (integer-length num) 8))) 
      (write-byte n-bytes stream) 
      (dotimes (i n-bytes) 
         (write-byte (ldb (byte 8 0) num) stream) 
         (setq num (ash num -8)))))
</pre>

<p>Чтобы декодировать целые числа, нам понадобится один метод для декодирования положительных целых чисел и другой метод для декодирования отрицательных целых чисел. Метод, который декодирует положительные целые числа, будет вызван, когда код равен %positive-integer. Этот метод считает длину целого числа, а затем само целое число; затем он может создать (прочитать) целое число и завершить работу. Следующий байт в потоке - это новый управляющий байт, который является началом нового закодированного объекта.</p>

<p>Отправляя длину целых чисел в одном байте, мы неявно наложили ограничение на передаваемое значение целых чисел: не может быть передано значение num, для которого (&gt; (ceiling (integer-length (abs num)) 8) 255) равно true, что означает, что максимальная длина целого числа равна 2040. Используя определение целочисленной длины на странице 224 книги Стила Common LISP: The Language, максимальное положительное целое число равно (1- (expt 2 (* 8 255))), а самое отрицательное целое число является отрицательным от этого. Таким образом, предел очень велик, чуть более 10, увеличенный до 614-й степени.</p>

<p>Методы декодирования приведены в следующем разделе, "Методы для отдельных объектов LISP", стр. 94.</p>

<h3>Кодировка Characters(символьных знаков)</h3>

<p>Чтобы закодировать символьный знак, мы отправляем управляющий байт, указывающий что это символьный знак, а затем ASCII-код символа в следующем байте. Этот метод отправляет только код символьного знака и игнорирует любой шрифт или биты.</p>

<p>Чтобы учесть различия в собственных наборах символьных знаков серверной и клиентской машин, мы преобразуем символьный знак в его код ASCII при кодировании и преобразуем его из ASCII в соответствующий код в собственном наборе символьных знаков при декодировании. Функция char-to-ascii зависит от реализации и здесь не предоставляется. Необходимо, чтобы charto-ascii возвращал значение меньше 256, чтобы оно помещалось в восьмибитный байт.</p>

<pre>
(defmethod encode ((char character) stream) 
   (write-byte %character stream) 
   (write-byte (char-to-ascii char) stream)) 
</pre>

<h3>Кодирование списков и векторов</h3>

<p>Чтобы закодировать список или вектор, мы определяем соответствующий управляющий байт, затем вызываем encode-sequence для отправки управляющего байта, длины последовательности и кодированного представления каждого элемента последовательности.</p>

<pre>
(defmethod encode ((list list) stream) 
   (encode-sequence list stream %list)) 

(defmethod encode ((vector vector) stream) 
   (encode-sequence vector stream %vector)) 

(defun encode-sequence (seq stream code) 
   (let ((length (length seq))) 
      (write-byte code stream) 
      (encode length stream) 
      (dotimes (i length) 
         (encode (elt seq i) stream)))) 
</pre>

<p>Эти два метода вызывают функцию encode-sequence для выполнения разделяемой части работы. Это модульная конструкция, которая использует обычную функцию вместо обобщенной функции. В этом контексте нет никакого преимущества в реализации encode-sequence как обобщенные функции.</p>

<h3>Кодирование строк</h3>

<p>Строка - это вектор, поэтому метод кодирования векторов применим к строкам, и он будет отлично работать для них. Однако мы собираемся предоставить метод для string по соображениям эффективности. Легко оптимизировать кодировку строк, потому что мы знаем, что каждый элемент строки является символьным знаком и умещается в одном байте(для ASCII символов, но не UTF8). Когда мы кодируем строку, нет необходимости кодировать каждый символ строки. Напротив, нет никакого способа узнать, каковы элементы вектора, поэтому каждый элемент должен быть закодирован.</p>

<p>Чтобы закодировать строку, мы отправляем управляющий байт, указывающий строку, затем длину строки, затем каждый символ строки. Любые указатели заливки, биты или шрифты не кодируются.</p>

<pre>
(defmethod encode ((string string) stream) 
   (let ((length (length string))) 
      (write-byte %string stream) 
      ;; careful to allow strings greater than 256 chars 
      (encode length stream) 
      (dotimes (i length) 
         (write-byte (char-to-ascii (aref string i)) stream))))
</pre>

<p>Когда encode вызывается со строкой в качестве первого аргумента, применяются два метода: метод, который специализируется на string, и метод, который специализируется на vector. Чтобы определить, какой метод является более конкретным, CLOS обращается к списку приоритетов класса string, который является</p>

<pre>
(string vector array sequence t) 
</pre>

<p>Поскольку класс string имеет приоритет над классом vector, метод, который специализируется на string, более специфичен, чем метод, который специализируется на vector.</p>

<h3>Кодирование Символов</h3>

<p>Чтобы закодировать символ и его пакет, мы отправляем управляющий байт, указывающий на  символ, закодированное представление имени символа и закодированное представление пакета символа. Обратите внимание, что значение, определение функции и любые свойства символа не передаются. Кроме того, пакет должен существовать на стороне сервера.</p>

<pre>
(defmethod encode ((symbol symbol) stream) 
   (write-byte %symbol stream) 
   (encode (symbol-name symbol) stream) 
   (encode (package-name (symbol-package symbol)) stream)) 
</pre>

<h3>Соображения по проектированию и эффективности</h3>

<p>Обратите внимание, что метод для символьного знака довольно эффективен; он отправляет один управляющий байт, затем код символа ASCII. Напротив, метод для символа приводит к большим накладным расходам. Этот метод отправляет управляющий байт, указывающий символ, затем закодированное представление имени символа, затем закодированное представление пакета символа. В таблице 4.2 показано кодированное представление символа + в пакете lisp.</p>

<table>
<thead>
<tr>
  <th>Datum</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>4</td>
  <td>%symbol</td>
</tr>
<tr>
  <td>5</td>
  <td>%string</td>
</tr>
<tr>
  <td>1</td>
  <td>%positive-integer</td>
</tr>
<tr>
  <td>1</td>
  <td>length of the integer</td>
</tr>
<tr>
  <td>1</td>
  <td>length of the string</td>
</tr>
<tr>
  <td>43</td>
  <td>ASCII character code of +</td>
</tr>
<tr>
  <td>5</td>
  <td>%string</td>
</tr>
<tr>
  <td>1</td>
  <td>%positive-integer</td>
</tr>
<tr>
  <td>1</td>
  <td>length of the integer</td>
</tr>
<tr>
  <td>4</td>
  <td>length of the string</td>
</tr>
<tr>
  <td>76</td>
  <td>ASCII character code of L</td>
</tr>
<tr>
  <td>73</td>
  <td>ASCII character code of I</td>
</tr>
<tr>
  <td>83</td>
  <td>ASCII character code of S</td>
</tr>
<tr>
  <td>80</td>
  <td>ASCII character code of P</td>
</tr>
</tbody>
</table>

<p>Таблица 4.2 Кодировка символа + в пакете lisp.</p>

<p>Закодированное представление символов использует пять управляющих байтов. Это результат использования encode как для имени символа, так и для его упаковки. Если важна скорость, мы можем разработать более эффективную стратегию кодирования символов. Однако нынешняя стратегия имеет два преимущества. Во-первых, она позволяет проверять ошибки на стороне декодирования: метод декодирования ожидает, что символ будет содержать строку (имя символа), за которой следует другая строка (пакет символа). Во-вторых, этот метод вызывает метод, который специализируется на string, вместо того, чтобы дублировать работу, выполняемую этим методом.</p>

<p>Общая конструкция кодирования и декодирования проста, модульна и эффективна. Этот дизайн легко вмещает улучшения и дополнения к программе в нескольких областях:</p>

<ul>
<li>Настройка для повышения эффективности</li>
<li>Передача нескольких возвращаемых значений</li>
<li>Передача печатного вывода</li>
<li>Обработка ошибок, возникших при вычислении формы на сервере</li>
<li>Расширение этого протокола для передачи дополнительных типов объектов</li>
</ul>

<h2>4.5 МЕТОДЫ ДЛЯ ОТДЕЛЬНЫХ ОБЪЕКТОВ LISP</h2>

<p>До сих пор мы видели методы, которые специализируются на классе аргументов обообщенной функции. То есть специализаторы параметров - это классы. Иногда бывает полезно написать метод, который специализируется на отдельном объекте Lisp. Метод, который специализирует один из своих параметров на отдельном объекте Lisp, называется индивидуальным(individual) методом.</p>

<h3>Применимость и приоритет Индивидуальных методов</h3>

<p>Предположим, у вас есть операция, которая работает определенным образом, когда аргументом является число, но должна работать по-другому, если аргументом является целое число 0. Метод 2 - это индивидуальный метод. Его второй параметр специализирован на целом числе 0. Специализатором параметра является список (eql 0).</p>

<pre>
;;; Method 1 
(defmethod divide ((dividend number) (divisor number)) 
   (/ dividend divisor)) 
;;; Method 2 
(defmethod divide ((dividend number) (zero (eql 0))) 
   (error "Cannot divide by zero.")) 
</pre>

<p>Лямбда-список отдельного метода содержит такой параметр, как</p>

<pre>
(var (eql form)) 
</pre>

<p>Специализатором параметра является (eql object), где object - это результат вычисления формы. Форма вычисляется только один раз, когда определен метод.</p>

<p>Когда divide вызывается с 0 в качестве второго аргумента, применимы оба метода. Далее следует правило применимости отдельных методов. Обратите внимание, что, поскольку в тесте на применимость используется eql, метод 2 применим только для целого числа 0, а не для 0.0.</p>

<table>
<thead>
<tr>
  <th>Правило применимости индивидуального метода:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Для специализатора параметров формы (объекта eql) аргумент обобщенной</td>
</tr>
<tr>
  <td>функции удовлетворяет специализатору параметров, если аргумент является</td>
</tr>
<tr>
  <td>eql для объекта. Другими словами, это выражение должно быть истинным:</td>
</tr>
<tr>
  <td>(объект аргумента eql ')</td>
</tr>
</tbody>
</table>

<p>Метод 2 более специфичен, как и следовало ожидать. Следует правило приоритета отдельных методов.</p>

<table>
<thead>
<tr>
  <th>Правило приоритета отдельного метода:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Когда сравниваются два специализатора параметров, параметр,</td>
</tr>
<tr>
  <td>специализированный в форме (объект eql), всегда более специфичен, чем</td>
</tr>
<tr>
  <td>класс.</td>
</tr>
</tbody>
</table>

<h3>Примеры индивидуальных методов</h3>

<p>Рассмотрим задачу декодирования закодированных представлений объектов Lisp. Каждый объект Lisp кодируется и декодируется в соответствии со своим типом, поэтому имеет смысл писать отдельные методы для кодирования и декодирования каждого отдельного типа объекта.</p>

<p>Кодировщик имеет объект Lisp в качестве своего аргумента, поэтому эти методы могут специализироваться на классах объектов. Однако декодер не имеет объектов Lisp в качестве аргументов; вместо этого он считывает данные из потока и получает предупреждение о типе объекта с помощью управляющего байта, предшествующего объекту в потоке. Таким образом, декодер не может предоставлять методы, которые специализируются на классах, но он может использовать отдельные методы, которые специализируются на каждом из этих управляющих байтов.</p>

<p>Здесь повторяется декодирование обобщенной функции:</p>

<pre>
(defgeneric decode (code stream) 
   (:documentation 
    "Based on the code, read an encoded representation 
from the stream, decode, and create an object.")) 
</pre>

<p>Каждый метод для decode(декодирования) специфицирует свой первый аргумент, и ровно один метод применим для каждого отдельного управляющего байта. Напомним, что decode вызывается с одним байтом в качестве первого аргумента (это управляющий байт) и потоком в качестве второго аргумента. Определение remote-eval повторяется здесь, чтобы проиллюстрировать, как вызывается decode:</p>

<pre>
(defun remote-eval (stream form) 
   (encode form stream) 
   (force-output stream) 
   ;; Read the return value 
   ;; The first byte is a control byte 
   (decode (read-byte stream) stream)) 
</pre>

<h3>Декодирование целых чисел</h3>

<p>Нам нужны два метода для декодирования целых чисел, потому что метод кодирования целых чисел отправляет два разных управляющих байта, в зависимости от того, является ли целое число положительным или отрицательным. Первый метод применим, когда первым аргументом является управляющий байт, указывающий на положительное целое число. Аналогично, второй метод применим, когда первым аргументом является управляющий байт, указывающий на отрицательное целое число.</p>

<pre>
(defmethod decode ((code (eql Ipositive-integer)) stream) 
   (decode-integer stream)) 

(defmethod decode ((code (eql %negative-integer)) stream) 
   (- (decode-integer stream))) 

(defun decode-integer (stream) 
   (let ((num 0) 
         (n-bytes (read-byte stream))) 
      (dotimes (i n-bytes) 
         (setq num (dpb (read-byte stream) (byte 8 (* i 8)) num))) 
      num)) 
</pre>

<p>%positive-integer и %negative-integer вычисляются ровно один раз, в момент определения этих методов.</p>

<p>Функция decode-integer выполняет разделяемую часть работы; она вызывается обоими методами. Нет никакого преимущества в реализации decode-integer в качестве обобщенной функции.</p>

<h3>Декодирование символьных знаков(Characters)</h3>

<p>Чтобы декодировать символьный знак, мы считываем один байт и преобразуем его из кода ASCII в соответствующий код символьного знака в нативном наборе символьных знаков. Функция ascii-to-char зависит от реализации и здесь не предусмотрена.</p>

<pre>
(defmethod decode ((code (eql %character)) stream) 
   (ascii-to-char (read-byte stream))) 
</pre>

<h3>Декодирование списков и векторов</h3>

<p>Чтобы декодировать список или вектор, мы считываем длину последовательности, затем декодируем каждый элемент в последовательности. Опять же, мы можем использовать функцию для выполнения разделяемой части работы.</p>

<pre>
(defmethod decode ((code (eql %list)) stream) 
   (decode-sequence stream 'list)) 

(defmethod decode ((code (eql %vector)) stream) 
   (decode-sequence stream 'vector)) 

(defun decode-sequence (stream type) 
   (let* ((length (decode (read-byte stream) stream)) 
          (seq (make-sequence type length))) 
      (dotimes (i length) 
         (setf (elt seq i) 
               (decode (read-byte stream) stream))) 
      seq)) 
</pre>

<h3>Декодирование строк</h3>

<p>Чтобы декодировать строку, мы считываем длину строки, затем каждый символьный знак строки.</p>

<pre>
(defmethod decode ((code (eql Istring)) stream) 
   (let* ((length (decode (read-byte stream) stream)) 
          (string (make-string length))) 
      (dotimes (i length) 
         (setf (aref string i) (ascii-to-char (read-byte stream)))) 
      string)) 
</pre>

<h3>Декодирование символов</h3>

<p>Чтобы декодировать символьный знак, мы сначала расшифровываем название, а затем расшифровываем пакет. Обратите внимание, что этот метод не создает пакет, если он еще не существует.</p>

<pre>
;;; Does not create the package. 
(defmethod decode ((code (eql %symbol)) stream) 
   (let ((code (read-byte stream))) 
      (when (/- %string code) 
         (error "The symbol's name must be a string.")) 
      (let ((symbol-name (decode code stream))) 
         (setq code (read-byte stream)) 
         (when (/- %string code) 
            (error "The symbol's package name must be a string.")) 
         (let* ((pkg-name (decode code stream)) 
                (pkg (find-package pkg-name))) 
            (when (null pkg) 
               (error "Package named ~A not found." pkg-name)) 
            (intern symbol-name pkg))))) 
</pre>

<h2>4.6 КРАТКОЕ ОПИСАНИЕ НАСЛЕДОВАНИЯ МЕТОДОВ</h2>

<p>Наследование методов включает в себя два отдельных механизма. И то, и другое происходит автоматически как часть generic dispatch(обобщенной диспетчеризации).</p>

<ol>
<li>Выбор набора применимых методов2. Ранжирование применимых методов в порядке приоритета</li>
</ol>

<p>Чтобы выбрать набор применимых методов, CLOS требует знания аргументов обобщенной функции и методов, определенных для обобщенной функции. Следующее общее правило учитывает все виды методов, включая методы, которые специализируются только на одном параметре, мультиметоды и отдельные методы:</p>

<table>
<thead>
<tr>
  <th>Общее правило применимости метода:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Метод применим, если каждому из его требуемых параметров удовлетворяет</td>
</tr>
<tr>
  <td>соответствующий аргумент (arg) обобщенной функции.</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
  <th>Требуемый параметр</th>
  <th>Тест</th>
</tr>
</thead>
<tbody>
<tr>
  <td>(var (eql form))</td>
  <td>(eql arg 'object)</td>
</tr>
<tr>
  <td>(var class-name)</td>
  <td>(typep arg 'class-name)</td>
</tr>
<tr>
  <td>var</td>
  <td>(typep arg 't)</td>
</tr>
</tbody>
</table>

<p>В первом случае объект получается путем оценки формы один раз, в момент определения метода. В последнем случае требуемый параметр является неспециализированным, что эквивалентно специализации на классе t. Любой аргумент удовлетворяет неспециализированному параметру, поскольку каждый объект Lisp имеет тип t.</p>

<p>Чтобы ранжировать применимые методы в порядке приоритета, CLOS требует знания следующего:</p>

<ul>
<li>Набор применимых методов</li>
<li>Список приоритета класса каждого требуемого аргумента обобщенной функции</li>
<li>Порядок приоритета аргументов обобщенной функции</li>
</ul>

<p>При ранжировании приоритета двух методов CLOS сравнивает специализаторы параметров методов. Неспециализированный параметр эквивалентен классу с именем t, являющемуся специализатором параметра.</p>

<p>Обычно порядок приоритета аргументов слева направо, что означает, что CLOS начинается со сравнения первого (крайнего левого) специализатора параметров метода A с первым специализатором параметров метода B. Если два специализатора параметров различны, CLOS использует следующее правило, чтобы определить, какой специализатор параметров более специфичен, и ранжирует методы на этой основе, не принимая во внимание какие-либо другие специализаторы параметров. Однако, если два специализатора параметров одинаковы, CLOS не может ранжировать приоритет методов на этой основе. CLOS переходит к следующей паре специализаторов параметров и так далее, пока не найдет пару специализаторов параметров, которые отличаются; затем методы ранжируются на основе этой пары специализаторов параметров.</p>

<p>Если два метода имеют одинаковые спецификаторы параметров, они должны иметь разные квалификаторы. В этом случае не имеет значения, какой метод является более конкретным.</p>

<table>
<thead>
<tr>
  <th>Правило ранжирования специализаторов параметров:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Специализатор параметров (eql object) более специфичен, чем</td>
</tr>
<tr>
  <td>класс.</td>
</tr>
</tbody>
</table>

<p>Когда оба специализатора параметров являются классами, они ранжируются в соответствии со списком приоритетов классов класса соответствующего аргумента универсальной функции. Список приоритетов классов указывает, какой класс более специфичен, чем другой.</p>

<h3>Порядок приоритета Аргументов</h3>

<p>Приоритет методов зависит от порядка приоритета аргументов обобщенной функции. По умолчанию CLOS использует порядок приоритета аргументов слева направо, что означает, что первый аргумент (самый левый) более важен для ранжирования приоритета, чем следующие аргументы. Вы можете использовать параметр :argument-precedence-order для defgeneric, чтобы указать другой порядок.</p>

<p>Порядок приоритета аргументов важен, когда CLOS ранжирует два метода, которые специализируются на разных параметрах, или методы, которые специализируются более чем на одном параметре. Рассмотрим следующие методы:</p>

<pre>
;;; Method A 
(defmethod install ((sw basic-product) non-os) 
   body)

;;; Method B 
(defmethod install (non-product (os basic-os)) 
   body) 
</pre>

<p>Метод A специализируется на своем первом параметре, но оставляет свой второй параметр неспециализированным. Метод B специализирует свой второй параметр, но оставляет свой первый параметр неспециализированным. Если мы рассмотрим первые параметры изолированно, метод A более специфичен, поскольку любой специализированный параметр имеет приоритет над неспециализированным. Однако, если мы рассмотрим вторые параметры изолированно, метод B более специфичен. Порядок приоритета аргументов разрешает этот конфликт, указывая, какой из аргументов следует рассмотреть первым.</p>
</body> </html>
