<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
</head> 

<body bgcolor="white" text="black">
<h1>Основные моменты CLOS</h1>

<p>В этой главе мы обсудим первоначальные цели проектирования CLOS и то, как они были достигнуты. Мы решаем три важные цели проектирования CLOS и одну нецелевую:</p>

<ul>
<li>CLOS должен быть стандартным расширением языка, включающим наиболее полезные аспекты существующих объектно-ориентированных парадигм.</li>
<li>Интерфейс CLOS программиста должен быть достаточно мощным и гибким для разработки большинства прикладных программ</li>
<li>Сам CLOS должен быть разработан как расширяемый протокол, позволяющий настраивать его поведение и стимулировать дальнейшие исследования в области объектно-ориентированного программирования.</li>
<li>CLOS не должны обеспечивать автоматическую поддержку для определения и применения протоколов </li>
</ul>

<p>12.1 РАЗРАБОТКА СТАНДАРТНОЙ ОБЪЕКТНО-ОРИЕНТИРОВАННОЙ ПАРАДИГМЫ</p>

<p>Когда CLOS был разработан (начиная с 1986 года), ряд объектно-ориентированных парадигм был доступен в различных реализациях Lisp в течение нескольких лет. Целью разработки CLOS было определение стандартного языкового расширения для Common Lisp. Непосредственным преимуществом этого стандарта было бы предоставление программистам Lisp возможности писать переносимый код в объектно-ориентированном стиле.</p>

<p>Многие из существующих объектно-ориентированных парадигм имели важные сходства. Рабочая группа CLOS хотела собрать наиболее полезные аспекты этих парадигм в единое, унифицированное языковое расширение. С самого начала Рабочая группа согласилась с тем, что основной целью при определении языкового стандарта было быть консервативным — включить в стандарт CLOS только те функции и методы, которые были хорошо поняты. Рабочая группа попыталась определить согласованную модель, основанную на сильных сторонах существующих парадигм, исключив при этом ненужные функции.</p>

<p>12.2 КРАТКОЕ ОПИСАНИЕ ИНТЕРФЕЙСА ПРОГРАММИСТА</p>

<p>Здесь мы обобщаем основные методы, поддерживаемые интерфейсом CLOS programmer:</p>

<ul>
<li><p>Определение организации классов. Вы можете удобно определять организацию классов. Класс наследует структуру и поведение от своих прямых суперклассов, которые перечислены в форме defclass. CLOS автоматически вычисляет список приоритетов классов на основе ограничений, указанных локально в формах defclass.</p></li>
<li><p>Создание и инициализация экземпляров. Вы можете создавать экземпляры с помощью make-instance. CLOS предоставляет вам хороший контроль над тем, как инициализируются экземпляры. Вы можете указать, что слот должен быть заполнен инициализацией, и указать начальные значения по умолчанию для слотов и инициализаций. Вы можете выполнить дальнейшую инициализацию, специализировавшись на initialize-instance.</p>

<ul>
<li>Определение различных видов методов. Вы можете определять методы для самых разных целей, включая:</li>
<li>Специализация поведения читателя или писателя</li>
<li>Специализирующийся на типе Common Lisp</li>
<li>Специализация на более чем одном аргументе (мультиметоды)</li>
<li>Специализируясь на отдельном объекте Lisp</li>
</ul></li>
<li><p>Определение методов, которые работают вместе. Поведение универсальной отправки(generic dispatch) по умолчанию (тип комбинации стандартных методов) допускает использование методов с различными ролями, включая первичные методы, методы до(before-), методы после(after-) и окружающие(around-) методы. Это чрезвычайно гибкая платформа, которая — вместе с механизмом наследования классов - позволяет вам определять код в модулях. Каждый модуль вступает в игру, когда это уместно, в соответствии с аргументами обобщенной функции и ролью метода.</p></li>
<li><p>Использование отличающейся рабочей среды для общей отправки(generic dispatch). Вы можете легко использовать один из встроенных типов комбинации методов или определить новый на основе функции Lisp, макроса или специальной формы. Свобода использования других типов комбинаций методов позволяет вам контролировать, как вызываются методы и что делается с их значениями.</p></li>
<li><p>Динамическое переопределение элементов. Вы можете переопределять обобщенные функции, методы и классы "на лету". Вы можете переопределить класс даже после того, как экземпляры класса существуют. CLOS гарантирует, что все, на что влияет переопределение, автоматически обновляется, включая экземпляры, подклассы и экземпляры подклассов. Когда экземпляры обновляются, метод по умолчанию добавляет или удаляет слоты в соответствии с новым определением и сохраняет значения слотов, которые не изменились. Вы можете выполнить дальнейшие действия во время переопределения, специализировав update-instance-structure.</p></li>
</ul>

<p>Эти особенности(функциональности) в совокупности придают ему большую выразительную силу. Однако цель "удовлетворения большинства приложений" имеет компромисс. Чтобы удовлетворить большинство приложений, интерфейс программиста очень гибкий. Недостатком такой гибкости является то, что пользователи CLOS могут быть ошеломлены широким спектром методов и функций, которые необходимо изучить. Кроме того, CLOS часто поддерживает более одного способа выполнения одной и той же задачи, и не всегда существует четкое указание на то, какой способ предпочтительнее.</p>

<p>Конечно, нет необходимости разбираться во всех этих методах, чтобы написать прикладную программу хорошего размера. Любая отдельная программа потребует только подмножества этих методов. Мы рекомендуем новым пользователям сосредоточиться на изучении основных тем работы CLOS, особенно общей отправки. Если вы понимаете, что происходит при вызове обобщенной функции, вы на верном пути. Следующий шаг - начать писать программы CLOS. В процессе разработки вы можете обнаружить проблемы, которые не могут быть удобно решены с помощью самых базовых функций CLOS (таких как первичные методы, методы до(before-) и после(after-)), и затем вы можете исследовать более продвинутые функции (такие как around-методы или другие типы комбинации методов).</p>

<p>12.3 ИЗУЧЕНИЕ АЛЬТЕРНАТИВНЫХ ПАРАДИГМ</p>

<p>При всей упомянутой до сих пор выразительной силе, что еще нужно? Интерфейс CLOS программиста поддерживает одну модель объектно-ориентированного программирования, но существуют альтернативные парадигмы.</p>

<p>Например, в CLOS класс наследует почти все аспекты своих суперклассов: слоты, некоторые параметры слотов и классов, а также методы. Мы можем назвать это "открытым общим доступом"; класс наследует почти все по умолчанию, но при желании может переопределить некоторые унаследованные поведения или характеристики. Альтернативная парадигма может поддерживать "закрытый общий доступ", когда класс по умолчанию ничего не наследует от своих суперклассов, но может явно указать, какие аспекты своих суперклассов он хочет унаследовать.</p>

<p>Два других ключевых аспекта любой объектно-ориентированной парадигмы - это то, как определяется организация классов и как контролируется приоритет среди этих классов. В CLOS программист определяет организацию классов в формах defclass; у каждого класса есть список суперклассов. Порядок этих суперклассов устанавливает локальные ограничения на приоритет классов. CLOS использует алгоритм для вычисления списка приоритетов(предшествования) классов для каждого класса, который всегда согласуется с набором локальных ограничений. Это всего лишь один из многих возможных способов управления наследованием.</p>

<p>Когда определялся CLOS, большинство разработчиков, имевших опыт работы с одной или несколькими существующими парадигмами, согласились с тем, что объектно-ориентированное программирование имеет важное значение для проектирования и внедрения больших систем. Однако даже словосочетание "объектно-ориентированное программирование" имело разное значение для разных людей. Каждая отдельная парадигма изобрела не только свой собственный синтаксис, но и свою собственную семантику.</p>

<p>Рабочая группа должна была принять определенные решения и сделать выбор, чтобы определить CLOS как последовательную/непротиворечивую модель. Рабочая группа также считала, что важно поощрять постоянное экспериментирование с альтернативными парадигмами. Решение состояло в том, чтобы определить и задокументировать сам CLOS как расширяемый протокол, который называется Metaobject Protocol.Мы обсуждаем это в "Протоколе метаобъектов CLOS", стр. 219.</p>

<p>12.4 НЕЦЕЛЕВОЕ: АВТОМАТИЧЕСКАЯ ПОДДЕРЖКА ПРОТОКОЛА</p>

<p>Некоторые объектно-ориентированные парадигмы активно помогают программисту в определении протоколов. Определение класса может описывать больше семантики класса. Например, в определении класса может быть указано, что класс предназначен только для использования в качестве строительного блока и что его экземпляры не должны создаваться. Требования к классу могут быть явно указаны в определении класса. Например, класс mixin, такой как ordered-lock-mixin, имеет некоторые неявные требования: он предназначен для использования в качестве строительного блока вместе с другим классом блокировки(lock) (таким как simple-lock или null-lock), и этот класс блокировки должен предоставлять методы для протокола блокировки. Некоторые объектно-ориентированные языки предоставляют средства для явного изложения этих требований и для их применения.</p>

<p>CLOS не обеспечивает автоматическую поддержку протоколов. Это область, которую Рабочая группа сочла экспериментальной и еще не готовой к стандартизации.</p>

<p>В этой книге мы сосредоточились на теме протоколов как ценного средства разработки программ. Хотя CLOS активно не поддерживает протоколы, тем не менее это язык, способствующий их определению. Аспект CLOS, который делает определение протокола удобным, заключается в том, что обобщенные функции не вызываются с помощью специального синтаксиса. Для вызывающего абонента нет заметной разницы между обычными и обобщенными функциями. В других объектно-ориентированных парадигмах вызывающий должен знать, является ли функция обычной или обобщенной, чтобы выбрать соответствующий синтаксис вызова. Разница в синтаксисе вызова скрывает существенное различие между интерфейсом и реализацией.</p>

<p>В этой книге мы сосредоточились на теме протоколов как ценного средства разработки программ. Хотя CLOS активно не поддерживает протоколы, тем не менее это язык, способствующий их определению. Аспект CLOS, который делает определение протокола удобным, заключается в том, что обобщенные функции не вызываются с помощью специального синтаксиса. Для вызывающего абонента нет заметной разницы между обычными и обобщенными функциями. В других объектно-ориентированных парадигмах вызывающий должен знать, является ли функция обычной или обобщенной, чтобы выбрать соответствующий синтаксис вызова. Разница в синтаксисе вызова скрывает существенное различие между интерфейсом и реализацией.</p>

<p>Хотя CLOS сам по себе не поддерживает протоколы, Рабочая группа считает, что протоколы являются ценными и важными. Сам CLOS задокументирован как расширяемый протокол. Основа интерфейса CLOS программиста лежит в протоколе metaobject, который документирован, чтобы позволить исследователям и разработчикам экспериментировать с другими объектно-ориентированными парадигмами.</p>

<p>12.5 ПРОТОКОЛ МЕТАОБЪЕКТА CLOS</p>

<p>В этом разделе дается краткий обзор протокола metaobject — этого достаточно, чтобы дать вам представление о том, как он связан с интерфейсом CLOS программиста.</p>

<p>Классы элементов CLOS</p>

<p>Важным аспектом CLOS является то, что каждый объект Lisp является экземпляром класса. Это означает, что сам объект класса имеет класс, как и объекты метода и объекты обобщенной функции. CLOS использует термин метакласс для обозначения класса, который является классом класса. Вот три предопределенных метакласса:</p>

<pre><code>   &gt;   standard-class 
   &gt;          Класс объектов класса по умолчанию, определенный defclass.

   &gt;   built-in-class 
   &gt;          Класс объектов класса, которые реализованы особым образом (не с помощью defclass).
   &gt;          Большинство объектов класса, соответствующих спецификаторам типов Common Lisp, 
   &gt;          реализованы как экземпляры встроенного класса, хотя другие могут быть реализованы как
   &gt;          экземпляры стандартного класса.

   &gt;   structure-class 
   &gt;              Класс объектов класса, определенный defstruct, когда параметр :type не задан.
</code></pre>

<p>Мы использовали неофициальный термин "пользовательский класс/user-defined class" при описании класса, метакласс которого является standard-class(стандартным классом). Аналогично, термин "встроенный класс/built-in class" обозначает класс, метакласс которого является встроенным классом. Метакласс важен для пользователей, поскольку он определяет поведение классов.
Например, стандартный класс(standard-class) поддерживает make-instance, а встроенный класс - нет. Другими словами, CLOS предоставляет метод для make-instance, прикрепленного к классу standard-class, но нет метода для make-instance, прикрепленного к встроенному классу.</p>

<p>CLOS расширяет defstruct, позволяя вам писать методы для структур defstruct. Если вы используете defstruct без указания параметра :type, структура defstruct реализуется как класс, метаклассом которого является structure-class. Преимущество этого заключается в том, что вы можете писать методы для этого класса. Однако, если вы хотите писать методы, использование defclass, вероятно, лучше, чем использование defstruct. Во-первых, использование defclass освобождает вас от ограничения одиночного наследования. Кроме того, гибкость переопределения классов поддерживается стандартным классом(standard-class), но не структурным классом(structure-class) или встроенным классом(built-in-class).</p>

<p>CLOS использует термин metaobject для объектов, представляющих элементы CLOS, таких как объекты класса, объекты метода и объекты универсальной функции. Вот два предопределенных класса метаобъектов:</p>

<pre><code>   &gt;    standard-method 
   &gt;           Класс объектов метода по умолчанию, определенный defmethod

   &gt;    standard-generic-function 
   &gt;           Класс объектов обобщенной функции по умолчанию, определенный defgeneric
</code></pre>

<p>Базовые элементы CLOS сами по себе реализованы как элементы CLOS, поэтому мы видим, что классы, обобщенные функции и методы следуют модели CLOS. Структура и поведение класса (или обобщенной функции, или метода) определяются его классом. Предопределенные классы метаобъектов имеют методы, которые поддерживают поведение CLOS по умолчанию.</p>

<p>Для большинства прикладных программ CLOS поведение CLOS по умолчанию является достаточно мощным и гибким, поэтому нет необходимости знать или заботиться о том, что классы, методы и обобщенные функции сами по себе являются экземплярами классов. Программисты, интересующиеся другими объектно-ориентированными парадигмами, могут использовать CLOS в качестве основы для экспериментов. Программисты могут определять новые метаклассы (обычно построенные на стандартных метаклассах), которые поддерживают новое и отличное поведение классов. Программисты также могут определять новые классы метаобъектов как классы обобщенных функций или методов. Это дополнительный уровень CLOS, называемый уровнем метаобъекта. Это основа функционального уровня, который, в свою очередь, является основой макроуровня.</p>

<p>В дополнение к стимулированию исследований и экспериментов, метаобъектный уровень позволяет разрабатывать инструменты для просмотра или анализа программ CLOS. Протокол metaobject описывает, как получить информацию о пользовательских элементах CLOS: объект класса может быть запрошен для получения его списка приоритетов  классов, слотов и параметров defclass; объект обобщенной функции может быть запрошен для его набора методов. Информация доступна; браузеры и инструменты среды могут разработать способы ее полезного представления программистам CLOS.</p>

<table>
<thead>
<tr>
  <th>уровень CLOS</th>
  <th>имеет дело с</th>
  <th>Контекста использования</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Macro</td>
  <td>names</td>
  <td>большинство CLOS приложений</td>
</tr>
<tr>
  <td>Functional</td>
  <td>objects</td>
  <td>программы, использующие анонимные объекты</td>
</tr>
<tr>
  <td>Metaobject</td>
  <td>metaobjects</td>
  <td>инструменты, исследования, эксперименты</td>
</tr>
</tbody>
</table>

<h3>Классы, Суперклассы и Метаклассы</h3>

<p>Обсуждение метаклассов добавляет определенную степень сложности модели CLOS. Даже терминология сбивает с толку. Здесь мы делаем некоторые утверждения, которые должны помочь прояснить значения классов, суперклассов и метаклассов. В прикладном программировании CLOS используются следующие концепции:</p>

<ul>
<li>Каждый объект Lisp является экземпляром класса. Вы можете использовать (class-of object), чтобы узнать класс объекта.</li>
<li>Класс объекта определяет его структуру и поведение. Все экземпляры данного класса имеют одинаковый
набор слотов. Любой метод, который специализируется на данном классе, применим ко всем экземплярам этого класса.</li>
<li>Класс имеет набор суперклассов. Класс наследует структуру и поведение от своих суперклассов. Другими словами, методы, присоединенные к классу, применимы к экземплярам подклассов этого класса.</li>
</ul>

<p>Ниже приведены концепции метаобъектного программирования CLOS. Обратите внимание, что каждое из этих понятий является естественным продолжением концепции, используемой в прикладном программировании.</p>

<ul>
<li>Поскольку каждый объект Lisp является экземпляром класса, сам объект класса является экземпляром класса. Вы можете использовать (class-of class-object), чтобы узнать класс объекта класса. Термин, обозначающий класс объектов класса, - это метакласс. Другими словами, экземпляры метакласса являются объектами класса.</li>
<li>Класс объекта класса (который является метаклассом) определяет структуру и поведение этого объекта класса. Все классы данного метакласса имеют одинаковый набор слотов. Методы, которые специализируются на данном метаклассе, применимы ко всем объектам класса этого метакласса.</li>
<li>Класс имеет набор суперклассов. Класс наследует структуру и поведение от своих суперклассов. Поскольку метакласс - это класс, у него также могут быть суперклассы, от которых он наследует структуру и поведение. Другими словами, методы, присоединенные к метаклассу, применимы к экземплярам подклассов этого метакласса.</li>
</ul>

<h3>Программирование метаобъектов</h3>

<p>Спецификация CLOS документирует набор предопределенных метаобъектов и протокол, которому они следуют. Разработчики могут использовать эти метаобъекты в качестве отправной точки. Чтобы поддерживать классы с совершенно другим поведением, вы можете определить новый метакласс. Вы можете лишь слегка изменить поведение по умолчанию, определив класс, построенный на основе standard-class; таким образом, вы можете переопределить некоторые аспекты поведения, наследуя другие аспекты.</p>

<p>Мы уже говорили, что CLOS прикладные программы переносимы. Преимущество переносимости распространяется и на метаобъектные программы. Разработчик может изобрести новую парадигму и приложения, основанные на ней, и может запускать их в других реализациях CLOS. Новыми парадигмами можно свободно делиться, что облегчает дальнейшие исследования. Приложения, использующие альтернативные парадигмы, являются переносимыми, поэтому конечные пользователи также могут воспользоваться протоколом metaobject.</p>
</body> </html>
