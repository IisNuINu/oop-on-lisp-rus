<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
</head> 

<body bgcolor="white" text="black">
<h1>Создание и инициализация экземпляров</h1>

<p>Клиентские программы обычно используют конструкторы для создания экземпляров. Конструкторы вызывают make-instance, который создает, инициализирует и возвращает новый экземпляр. CLOS позволяет вам управлять многими аспектами инициализации, начиная от указания значения по умолчанию для слота и заканчивая настройкой инициализации путем написания метода. Эта глава начинается с описания аргументов make-instance и краткого описания шагов, которые CLOS выполняет при вызове make-instance. Затем в нем показано, как использовать методы для управления инициализацией.</p>

<h2>9.1 АРГУМЕНТЫ ДЛЯ СОЗДАНИЯ ЭКЗЕМПЛЯРА</h2>

<p>Синтаксис make-instance таков</p>

<pre>
make-instance class Srest initargs 
</pre>

<p>Первый аргумент - это класс, который может быть либо именем класса, либо самим объектом класса. Это дает вам представление о том, что make-instance пересекает границу между макроуровнем и функциональным уровнем. Фактически, make-instance - это мощный инструмент, используемый как программистами приложений, так и программистами метаобъектов; мы описываем только те методы, которые предназначены для прикладных программистов.</p>

<p>Аргумент &amp;rest состоит из initargs, что является сокращением от аргументов инициализации. initarg управляет некоторым аспектом инициализации; он может заполнять слот или использоваться методом инициализации, или и тем, и другим.</p>

<p>Каждый initarg состоит из имени инициализирующего параметра, за которым следует значение. Имя инициализации initarg может быть любым символом, не обязательно ключевым словом. Формат аргумента &amp;rest совпадает с форматом аргументов ключевого слова, которые обрабатываются как параметры &amp;key.</p>

<h2>9.2 КРАТКОЕ ОПИСАНИЕ ТОГО, ЧТО ДЕЛАЕТ MAKE-INSTANCE</h2>

<p>Когда вы вызываете make-instance, CLOS выполняет следующие действия:</p>

<ol>
<li>Объединяет initargs, которые вы предоставляете make-instance, со значениями по умолчанию для любых initargs(инициализаций), которые вы явно не предоставляете. Результатом является список инициализации по умолчанию.</li>
<li>Гарантирует, что все имена initarg в списке инициализации(initarg) по умолчанию являются допустимыми, и выдает сообщение об ошибке, если это не так. Если :allow-other-keys указано как true при вызове make-instance, все имена initarg являются допустимыми.</li>
<li>Выделяет хранилище для экземпляра и создает экземпляр, все слоты которого не связаны.</li>
<li><p>Применяет обобщенную функцию initialize-instance к вновь созданному экземпляру и списку инициализации(initarg) по умолчанию. Основной метод по умолчанию для initialize-instance выполняет следующее:</p>

<pre><code>     a. Инициализирует слоты в соответствии со списком инициализации(initarg) по умолчанию

     b. Инициализирует все слоты, которые имеют :initforms и все еще не связаны
</code></pre></li>
</ol>

<p>Основной метод для initialize-instance выполняет эту работу, вызывая shared-initialize, который мы обсуждаем в "Процедурном определении: инициализация", стр. 165.</p>

<ol start="5">
<li>Возвращает инициализированный экземпляр.</li>
</ol>

<h2>9.3 УПРАВЛЕНИЕ ИНИЦИАЛИЗАЦИЕЙ С ПОМОЩЬЮ ПАРАМЕТРОВ DEFCLASS</h2>

<p>В этом примере мы определяем некоторые классы для представления окон(windows). В этих определениях классов используются методы инициализации windows. Окно базового класса предназначено для того, чтобы быть основой всех окон. Форма defclass использует два параметра слота, которые относятся к инициализации — параметры :initarg и :initform.</p>

<pre>
(defclass window () 
  ((x         :initarg :x-position :accessor x-position) 
   (y         :initarg :y-position :accessor y-position) 
   (height    :initarg :height     :accessor window-height) 
   (width     :initarg :width      :accessor window-width) 
   (exposed-p :initform nil        :accessor exposed-p)) 
  (:documentation "Foundation of all windows.")) 
</pre>

<h3>Использование опции слота :initarg</h3>

<p>В определении класса window для четырех слотов (x, y, height и width) используется параметр :initarg. Он объявляет четыре символа допустимыми именами инициализации для окна класса. Например, символ : x-position - это имя инициализации. Если вы передадите его make-instance, за которым последует значение, это значение будет сохранено в слоте x. Аналогично, символ :height - это инициализация, которую можно использовать для инициализации слота с именем height.</p>

<pre>
(make-instance 'window :x-position 0 
                       :y-position 0 
                       :height 200 
                       :width 75) 
</pre>

<p>Обратите внимание, что слот с именем exposed-p не использует параметр :initarg. Таким образом, вы не можете инициализировать этот слот, предоставив аргумент make-instance. Слот exposed-p не предназначен для инициализации пользователем.</p>

<h3>Использование опции слота :initform</h3>

<p>Слот с именем exposed-p использует параметр слота :initform, чтобы связать начальное значение по умолчанию со слотом. Значение равно nil. Семантика этого слота проста: когда вы впервые создаете окно, оно не отображается. Мы намеренно не предлагаем initarg, потому что мы хотим, чтобы все вновь созданные окна были деэкспонированы(скрыты); такой подход приводит к автоматической инициализации слота в его начальной форме(initform) (которая равна нулю) и эффективно предотвращает инициализацию пользователями слота exposed-p.</p>

<h3>Использование параметра класса :default-initargs</h3>

<p>Иногда классу полезно предоставить значение по умолчанию для инициализации. Параметр класса :default-initargs делает это. Он используется в основном для удаленного выполнения по умолчанию; то есть для предоставления значения по умолчанию для унаследованного initarg.</p>

<p>Если initarg(инициализация) предоставляется в вызове make-instance, она переопределяет инициализацию по умолчанию(default initarg). Но если initarg(инициализация) опущена, используется значение инициализации по умолчанию(default initarg).</p>

<p>Мы будем использовать :default-initargs при определении класса, который обычно используется в оконной программе. Полноэкранное окно(full-screen) - это окно, которое занимает весь экран. Высота и ширина такого окна получаются из переменных, которые хранят размеры экрана. Полноэкранное окно обычно располагается в начале координат, поэтому мы также задаем значения по умолчанию для :x-position и :y-position.</p>

<pre>
(defclass full-screen-window (window) () 
  (idefault-initargs 
   :x-position *screen-origin-x* 
   :y-position *screen-origin-y* 
   :height     *screen-height* 
   :width      *screen-width*)) 
</pre>

<p>Этот класс может использоваться отдельно или в качестве строительного блока для других классов. Он имеет те же слоты, что и window, но предлагает значения по умолчанию для четырех инициализаций для удобства клиентов, которым необходимо создавать полноэкранные окна.</p>

<h3>Два вида значений по умолчанию</h3>

<p>Важно иметь в виду разницу между :default-initargs и :initform. Параметр :default-initargs задает значение по умолчанию для initarg(инициализации), а параметр :initform задает значение по умолчанию для слота.</p>

<p>Если вы намерены разрешить пользователям инициализировать слот, то вам следует</p>

<ul>
<li>Использовать :initarg для объявления символа для инициализации слота</li>
<li>Использовать :default-initargs, если вы хотите присвоить этому initarg значение по умолчанию</li>
</ul>

<p>Если вы не собираетесь разрешать пользователям инициализировать слот, то вам следует</p>

<ul>
<li>Не использовать параметр :initarg</li>
<li>Используйте :initform, если вы хотите присвоить слоту начальное значение по умолчанию</li>
</ul>

<p>Эти два варианта вступают в конфликт, если они используются вместе. Рассмотрим, что происходит, когда слот имеет значение по умолчанию через :initform и инициализацию через :initarg, которая сама имеет значение по умолчанию через :default-initargs. Значение по умолчанию, заданное в :default-initargs, эффективно переопределяет значение по умолчанию, заданное в :initform.</p>

<p>Для обоих этих параметров форма значения по умолчанию вычисляется каждый раз, когда она используется. Значение :initform вычисляется каждый раз, когда оно используется для инициализации слота. Значение initarg в :default-initargs вычисляется при каждом вызове make-instance, и этот initarg не передается в качестве аргумента make-instance.</p>

<h2>9.4 УПРАВЛЕНИЕ ИНИЦИАЛИЗАЦИЕЙ С ПОМОЩЬЮ МЕТОДОВ</h2>

<p>Когда вызывается make-instance, он создает экземпляр и вызывает обобщенную функцию initialize-instance для инициализации нового экземпляра. CLOS предоставляет основной метод по умолчанию для initialize-instance, который заполняет слоты значениями в соответствии с их initargs и initforms. Вы можете настроить инициализацию экземпляров, написав метод для initialize-instance для выполнения дополнительной работы.</p>

<h3>Определение After(после)-методов для initialize-instance(инициализации экземпляра)</h3>

<p>Оконная система, вероятно, должна отслеживать все окна. Здесь мы добавляем новое окно в структуру данных, которая отслеживает деэкспонированные(deexposed/скрытые) окна.</p>

<pre>
(defmethod initialize-instance :after ((w window) Skey) 
   (push w *deexposed-windows*)) 
</pre>

<p>Обычно вы должны определять after-methods для initialize-instance (как мы делаем здесь) вместо primary methods. Основной метод переопределил бы основной метод по умолчанию и предотвратил бы обычную инициализацию слота.</p>

<p>Поскольку методы для initialize-instance получают все значения initargs по умолчанию в качестве аргументов, методы для initialize-instance должны использовать &amp;key в своих лямбда-списках. Результатом использования &amp;key здесь является то, что метод допускает ключевые слова без указания того, что он использует какие-либо аргументы ключевого слова. Для получения более подробной информации о лямбда-списках метода см. "Конгруэнтные лямбда-списки", стр. 132.</p>

<h3>Метод по умолчанию для initialize-instance(инициализации экземпляра)</h3>

<p>make-instance вызывает initialize-instance с экземпляром и списком инициализации по умолчанию(defaulted initarg). С этими аргументами метод по умолчанию для initialize-instance заполняет ячейки значениями следующим образом:</p>

<pre><code>      &gt; Шаг 1 Если вы предоставляете заполняющий слот initarg для make-instance, то его значение 
      &gt;           сохраняется в соответствующем слоте. (Параметр initarg, заполняющий слот, задается
      &gt;           параметром слота :initarg.)
      &gt; Шаг 2 Если слот не заполнен на шаге 1, и у initarg есть форма значения по умолчанию, то эта форма
      &gt;          вычисляется, и результат сохраняется в слоте. (Значение по умолчанию для initarg задается
      &gt;          параметром класса :default-initargs.)
      &gt; Шаг 3 Если слот не заполнен на шаге 2, и слот имеет форму начального значения по умолчанию, то 
      &gt;          эта форма вычисляется, и результат сохраняется в слоте. (Значение по умолчанию для слота
      &gt;          задается параметром слота :initform.)
      &gt; Шаг 4 Если слот не заполнен на шаге 3, то слот остается несвязанным.
</code></pre>

<p>Метод по умолчанию для initialize-instance выполняет эту инициализацию путем вызова shared-initialize, обобщенной функции, которая вызывается в других контекстах, а также при создании новых экземпляров. Мы подробно описываем общую инициализацию в разделе "Изоляция работы, разделяемой между процедурами", стр. 167.</p>

<h2>9.5 АРГУМЕНТЫ ИНИЦИАЛИЗАЦИИ</h2>

<p>В этом разделе более подробно описываются инициализации, уделяя особое внимание тому, как они используются для инициализации новых экземпляров. Инициализации используются и в других контекстах; см. "Выполнение инициализации с помощью Initargs", стр. 168.</p>

<h3>Действительность имен Initarg</h3>

<p>Имя initarg должно быть объявлено как допустимое для данного класса, прежде чем оно будет использовано в вызове make-instance. Существует два способа объявить, что имя initarg является допустимым:</p>

<pre><code>     &gt; :initarg slot option 
     &gt;            Объявляет символ как допустимое имя initarg(инициализации) и указывает, что значение initarg
     &gt;            должно быть сохранено в слоте.
     &gt;            Такой символ называется заполняющим слот initarg. Параметр слота :initarg наследуется
     &gt;            объединением: все имена initarg, объявленные классом или любым из его суперклассов,
     &gt;            действительны для класса.

       &gt; initialize-instance methods 
       &gt;            Объявляет все имена параметров &amp;key в лямбда-списке как допустимые имена инициализации
       &gt;            для класса. (Методы для других обобщенных функций также объявляют параметры &amp;key как
       &gt;            допустимые имена initarg. Смотрите "Объявление имен Initarg как допустимых", стр. 170.)
</code></pre>

<p>Кроме того, имя инициализации :allow-other-keys допустимо для всех классов. Его значение по умолчанию равно nil, что означает, что CLOS проверяет действительность всех инициализаций и выдает сообщение об ошибке, если обнаружено недопустимое имя инициализации. Если вы вызываете make-instance и даете :allow-other-keys, за которым следует значение, отличное от нуля, эта проверка ошибок отключена.</p>

<p>Если лямбда-список метода инициализации использует :allow-other-keys, все возможные символы объявляются как допустимые инициализации. Другими словами, использование :allow-other-keys в методе инициализации отключает проверку имен initarg на ошибки.</p>

<h3>Наследование Initargs(инициализаций) по умолчанию</h3>

<p>Параметр класса :default-initargs связывает значение по умолчанию с initarg. Набор initargs(инициализаций) по умолчанию наследуется объединением, но значение по умолчанию любого одного параметра initarg наследуется затенением. Другими словами,</p>

<pre><code>     &gt; Union(Объединение)         Набор initargs класса по умолчанию - это объединение всех
     &gt;                                         initargs(инициализаций) по умолчанию, предоставляемых классами в его
     &gt;                                         списке предшествования классов

       &gt; Shadowing(Затенение)            значения по умолчанию для любого одного initarg происходит от
       &gt;                                               наиболее конкретного класса, который предоставил для него значение по
       &gt;                                               умолчанию
</code></pre>

<h3>Разделение Initarg(инициализаций) и имен слотов</h3>

<p>Когда вы используете опцию слота :initarg, имя initarg(инициализации) не зависит от имени слота. Эта независимость обеспечивает определенный уровень абстракции; клиенты не могут предполагать, что инициализация отображается непосредственно в слот с тем же именем. Фактически, некоторые initargs(инициализации) могут вообще не отображаться в слот, а некоторые слоты могут быть заполнены значениями, которые вычисляются на основе нескольких initargs(инициализаций).</p>

<p>Например, класс triangle может принимать три initargs, по одной для длины каждой стороны. Однако класс может быть реализован для хранения длины двух сторон и угла между ними, который может быть вычислен из трех initargs. Таким образом, незаметно для клиента третья сторона использовалась бы для расчета противоположного угла, а затем была бы отброшена.</p>

<p>В следующем примере используется этот подход. Обратите внимание, что метод инициализации объявляет :side-a, :side-b и :side-c как допустимые имена initarg(инициализации), тогда как форма defclass не объявляет никаких имен initarg(инициализации). Мы определяем конструктор make-triangle, чтобы создать абстрактный интерфейс для создания треугольников и сделать все стороны обязательными аргументами. Вся работа по инициализации выполняется в методе для initialize-instance.</p>

<pre>
(defclass triangle (shape) 
  ((a : reader side-a) 
   (b :reader side-b) 
   (angle-C :reader angle-C)))

;;; Do all initialization in this method 
(defmethod initialize-instance .after 
    ((tri triangle) skey side-a side-b side-c) 
   (let* ((float-a (coerce a 'float)) 
          (float-b (coerce b 'float)) 
          (float-c (coerce c 'float)) 
          (float-angle-C (three-sides-to-angle 
                          float-c float-a float-b))) 
      (with-slots (a b angle-C) tri 
         (setf a float-a) 
         (setf b float-b) 
         (setf angle-C float-angle-C)))) 

;;; Define the constructor 
(defun make-triangle (side-a side-b side-c) 
   (make-instance 'triangle :side-a side-a 
                            :side-b side-b 
                            :side-c side-c)) 
</pre>

<h2>9.6 КОНСТРУКТОРЫ</h2>

<p>Мы рекомендуем использовать конструкторы в качестве внешнего интерфейса для создания экземпляров, поскольку конструкторы добавляют ценный уровень абстракции между клиентом и реализацией. Рассмотрим треугольники: название конструктора, make-triangle, подразумевает "создание треугольника", что является концепцией более высокого уровня, чем "создание экземпляра класса triangle".</p>

<p>Еще одним преимуществом конструкторов является то, что они могут использовать всю мощь обработки аргументов Common Lisp. Синтаксис make-instance крайне ограничен: после первого аргумента (класса) следует параметр &amp;rest, состоящий из initargs. Во многих случаях семантику класса можно лучше выразить с помощью обязательных аргументов, необязательных аргументов и так далее. Например, в случае с треугольниками аргумент &amp;rest для make-instance не подразумевает, что для создания треугольника требуются все три initargs(инициализации) — стороны. Конструктор, однако, может сделать три стороны обязательными аргументами; синтаксис конструктора точно отражает семантику треугольников.</p>

<p>Возможно, самое важное, конструкторы скрывают реализацию объектов, что позволяет вам изменять реализацию, не нарушая работу клиентских программ. Если вы рекламируете(предоставляете как внешний интерфейс) конструкторы как внешний интерфейс, вы можете позже перейти к представлению объекта defstruct или изменить имя или initargs(инициализации) класса, не делая недействительными клиентские программы. Конструкторы также могут выбрать один из нескольких классов на основе его аргументов. Если вы рекламируете make-instance как внешний интерфейс, вы не сможете внести эти изменения в рамках реализации.</p>
</body> </html>
