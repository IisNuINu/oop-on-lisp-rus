<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
</head> 

<body bgcolor="white" text="black">
<h1>Наследование классов</h1>

<p>CLOS использует список приоритета класса для определения приоритета или доминирования любых конкурирующих признаков. В этой главе описывается, как определяется список приоритетов классов и как он управляет наследованием слотов и опций слотов. Мы также обсуждаем классы, которые неявно включены в качестве суперклассов: standard-object и t.</p>

<h2>6.1 НАСЛЕДОВАНИЕ ОТ КЛАССОВ ПО УМОЛЧАНИЮ</h2>

<p>Все классы неявно включают t в качестве суперкласса. Это верно для пользовательских классов (тех, которые мы определяем с помощью defclass) и встроенных классов (таких как array и integer). Единственным исключением является сам класс t, у которого нет суперклассов. Одним из последствий наследования от t является то, что каждый объект Lisp имеет тип t. Тип t является корнем системы типов Common Lisp, а класс t является корнем системы классов CLOS.</p>

<p>Все пользовательские классы также неявно включают стандартный объект в качестве суперкласса, но встроенные классы этого не делают. Существование standard-object позволяет реализациям CLOS определять поведение по умолчанию, которое наследуется всеми пользовательскими классами. Например, первичные методы для класса standard-object реализуют print-object и описывают обобщенные функции. Классы t и standard-object не имеют слотов.</p>

<p>Все классы имеют t в качестве последнего (наименее специфичного) класса в своих списках приоритетов классов. Все пользовательские классы имеют standard-object в качестве предпоследнего класса в своих списках приоритетов классов. Это то, что вы можете считать само собой разумеющимся; это всегда верно.</p>

<h2>6.2 СПИСОК ПРИОРИТЕТОВ(предшествования) КЛАССОВ</h2>

<p>CLOS вычисляет список приоритетов классов для каждого класса. Список приоритетов классов содержит сам класс и все его суперклассы; он не содержит никаких повторяющихся классов. Порядок классов в списке приоритета классов имеет большое значение; он идет от наиболее специфичного к наименее специфичному. Если один класс более специфичен, чем второй класс, этот класс имеет приоритет над вторым классом.</p>

<p>Двумя правилами, регулирующими порядок приоритета классов, являются:</p>

<table>
<thead>
<tr>
  <th>Правило 1 приоритета класса:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Класс всегда имеет приоритет над своими суперклассами.</td>
</tr>
</tbody>
</table>

<p>Правило 1 позволяет классу переопределять или изменять аспекты поведения, предоставляемые его суперклассами.</p>

<table>
<thead>
<tr>
  <th>Правило 2 приоритета класса:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Каждое определение класса устанавливает порядок приоритета своих</td>
</tr>
<tr>
  <td>прямых суперклассов.</td>
</tr>
</tbody>
</table>

<p>Для правила 2 ограничения на порядок для прямых суперклассов определяются порядком суперклассов, перечисленных в форме defclass. То есть каждый класс более специфичен, чем классы, которые следуют за ним в этом списке.</p>

<p>Рассматривая только правило 1, мы знаем наиболее специфичный класс и наименее специфичный класс в любом списке приоритетов классов. Сам класс всегда является наиболее специфичным классом в своем собственном списке приоритетов классов, а класс t - наименее специфичным классом в любом списке приоритетов классов. (Поскольку каждый класс имеет t в качестве суперкласса, t не может предшествовать какому-либо классу и поэтому всегда является последним во всех списках приоритета классов.) Для пользовательских классов standard-object является предпоследним классом в списке приоритетов классов. В следующих примерах мы явно не упоминаем ограничения упорядочения standard-object или t, поскольку ограничения всегда одни и те же.</p>

<p>Когда CLOS определяет список приоритетов класса для класса, он начинается с определения класса. CLOS применяет оба правила к определению класса и получает набор локальных ограничений упорядочения. Затем CLOS применяет правила к определениям каждого из прямых суперклассов, каждого из их прямых суперклассов и так далее, пока все пути не закончатся в корневом классе t. Результатом является набор упорядочивающих ограничений для классов.</p>

<p>Следующий шаг - найти общий порядок, который удовлетворяет всем ограничениям упорядочения. CLOS делает это, сортируя набор ограничений упорядочения топологически. Другими словами, каждое из ограничений является частичным порядком, и список приоритетов классов достигается путем выполнения топологической сортировки по набору частичных порядков. Результатом является одна из этих трех возможностей:</p>

<pre><code>&gt; Случай 1. Ровно один полный порядок удовлетворяет ограничениям
&gt; Случай 2. Несколько полных упорядочений удовлетворяют ограничениям
&gt; Случай 3. Никакой полный порядок не удовлетворяет ограничениям
</code></pre>

<p>В любом из первых двух случаев CLOS создает список приоритетов классов.В третьем случае это сигнализирует об ошибке.</p>

<p>Мы приводим примеры каждого из этих случаев. В примерах показаны определения различных классов потоков, которые имеют суперклассы, но не имеют слотов. Мы не намерены описывать семантику этих классов, а скорее сосредоточимся на механике списков приоритета классов. (В разделе "Разработка расширенной программы CLOS: Потоки", стр. 171, мы разрабатываем пример потока, основанный на организации большого количества классов.)</p>

<h3>Случай 1: Ровно один Общий порядок Удовлетворяет ограничениям</h3>

<p>В этом случае, когда CLOS применяет два правила приоритета классов к определениям классов, класса и всех его суперклассов, результатом является только один возможный порядок. Это становится списком приоритетов классов.</p>

<p>Вот пример. Наша цель - определить список приоритетов классов для класса char-input-stream, учитывая следующие определения классов:</p>

<pre>
(defclass stream () ()) 
(defclass input-stream (stream) ()) 
(defclass char-stream (stream) ()) 
(defclass char-input-stream 
    (char-stream input-stream) 
  ()) 
</pre>

<p>На следующей диаграмме приведен набор ограничений упорядочения для char-input-stream. Символ &gt;&gt; является сокращением для обозначения "предшествует". Каждое ограничение является результатом применения одного из правил приоритета класса к одному из определений класса. Таким образом, первая запись на диаграмме означает "Входной поток класса предшествует потоку класса, который является результатом применения Правила 1 к определению класса входного потока". Аналогично, последняя запись означает "Класс char-stream предшествует классу input-stream, что является результатом применения правила 2 к определению класса char-input-stream".</p>

<table>
<thead>
<tr>
  <th>Ограничение</th>
  <th>Правило</th>
  <th>Класс</th>
</tr>
</thead>
<tbody>
<tr>
  <td>input-stream » stream</td>
  <td>1</td>
  <td>input-stream</td>
</tr>
<tr>
  <td>char-stream » stream</td>
  <td>1</td>
  <td>char-stream</td>
</tr>
<tr>
  <td>char-input-stream » char-stream</td>
  <td>1</td>
  <td>char-input-stream</td>
</tr>
<tr>
  <td>char-input-stream » input-stream</td>
  <td>1</td>
  <td>char-input-stream</td>
</tr>
<tr>
  <td>char-stream » input-stream</td>
  <td>2</td>
  <td>char-input-stream</td>
</tr>
</tbody>
</table>

<p>Ровно один общий порядок удовлетворяет ограничениям, поэтому список приоритетов классов для класса char-input-stream равен</p>

<pre>
(char-input-stream char-stream input-stream stream 
                   standard-object t) 
</pre>

<p>Хотя класс stream включен двумя разными классами (это прямой суперкласс как char-stream, так и input-stream), в списке приоритетов классов нет повторяющихся классов.</p>

<h3>Случай 2: Несколько полных порядков Удовлетворяют ограничениям</h3>

<p>Для многих программ два правила приоритета классов не приводят к единому порядку приоритета классов. То есть некоторые пары классов могут не иметь ограничения на порядок, основанного на правилах. Это может произойти, когда ни один из классов не является суперклассом другого (правило 1 не ограничивает их относительный приоритет), и ни один класс не включает оба класса в качестве прямых суперклассов (Правило 2 не ограничивает их относительный приоритет). Это не представляет проблемы по трем причинам:</p>

<ul>
<li><p>Отсутствие ограничений подразумевает отсутствие конфликта. Когда не задано ограничение на порядок для двух классов, это означает, что их относительный порядок приоритета не важен. Если порядок двух классов важен, программист может и должен установить ограничение на порядок, явно включив их в качестве прямых суперклассов нового класса.</p></li>
<li><p>CLOS выбирает один из возможных порядков. CLOS использует алгоритм, который всегда выдает детерминированное ранжирование классов. Это гарантирует, что все реализации CLOS выбирают один и тот же список приоритетов классов, учитывая один и тот же набор определений классов. Детали алгоритма не важны, но гарантия того, что алгоритм является детерминированным, обеспечивает защиту в ситуациях, когда работающая программа CLOS зависит от определенного порядка без явного указания зависимости в определении класса. Такая программа переносима на другую реализацию CLOS.</p></li>
<li><p>CLOS пытается сохранить генеалогические древа вместе в списке приоритетов классов. Рассматривайте класс и его суперклассы как "генеалогическое древо". Применяя алгоритм для выбора одного порядка из множества возможных порядков, CLOS использует это руководство: все "генеалогическое древо" каждого прямого суперкласса хранится вместе в списке приоритета класса, если это не нарушает ни одно из двух правил приоритета класса.</p></li>
</ul>

<p>Рассмотрим класс ascii-disk-stream, который имеет два прямых суперкласса, ascii-stream и disk-stream. Класс ascii-stream предшествует disk-stream, и (если возможно) все суперклассы ascii-stream предшествуют disk-stream в списке приоритетов классов. Эффект заключается в том, что вы можете рассматривать ascii-stream как "черный ящик" поведения; disk-stream не может переопределять поведение, предоставляемое ascii-stream или любым из его суперклассов.</p>

<p>В случаях, когда другие ограничения порядка не позволяют CLOS следовать этому руководству (то есть результат нарушил бы одно или оба правила), CLOS выбирает порядок, при котором члены каждого генеалогического древа располагаются как можно ближе друг к другу.</p>

<p>Здесь мы приводим пример случая, когда несколько полных упорядочений удовлетворяют ограничениям. Мы определяем список приоритетов классов для класса ascii-disk-stream, учитывая следующие определения классов:</p>

<pre>
(defclass stream () ()) 
(defclass buffered-stream (stream) ()) 
(defclass disk-stream (buffered-stream) ()) 
(defclass char-stream (stream) ()) 
(defclass ascii-stream (char-stream) ()) 
(defclass ascii-disk-stream 
    (ascii-stream 
     disk-stream) 
  0) 
</pre>

<p>Набор ограничений упорядочения для ascii-disk-stream выглядит следующим образом:</p>

<table>
<thead>
<tr>
  <th>Ограничение</th>
  <th>Правило</th>
  <th>Класс</th>
</tr>
</thead>
<tbody>
<tr>
  <td>buffered-stream » stream</td>
  <td>1</td>
  <td>buffered-stream</td>
</tr>
<tr>
  <td>disk-stream » buffered-stream</td>
  <td>1</td>
  <td>disk-stream</td>
</tr>
<tr>
  <td>char-stream » stream</td>
  <td>1</td>
  <td>char-stream</td>
</tr>
<tr>
  <td>ascii-stream » char-stream</td>
  <td>1</td>
  <td>ascii-stream</td>
</tr>
<tr>
  <td>ascii-disk-stream » ascii-stream</td>
  <td>1</td>
  <td>ascii-disk-stream</td>
</tr>
<tr>
  <td>ascii-disk-stream » disk-stream</td>
  <td>1</td>
  <td>ascii-disk-stream</td>
</tr>
<tr>
  <td>ascii-stream » disk-stream</td>
  <td>2</td>
  <td>ascii-disk-stream</td>
</tr>
</tbody>
</table>

<p>Нет никаких ограничений на приоритет потока символов по отношению к буферизованному потоку или на приоритет потока символов по отношению к дисковому потоку. Здесь мы показываем три полных порядка, которые удовлетворяют ограничениям. Средняя строка списка приоритетов каждого класса показывает, где происходят изменения:</p>

<pre>
(ascii-disk-stream ascii-stream 
                   char-stream disk-stream buffered-stream 
                   stream standard-object t) 
(ascii-disk-stream ascii-stream 
                   disk-stream buffered-stream char-stream 
                   stream standard-object t) 
(ascii-disk-stream ascii-stream 
                   disk-stream char-stream buffered-stream 
                   stream standard-object t)
</pre>

<p>В этом случае CLOS выбирает первый общий заказ. Здесь мы видим иллюстрацию принципа, согласно которому генеалогические деревья должны храниться вместе. Генеалогическое древо ascii-stream предшествует генеалогическому древу disk-stream, за исключением класса stream, который является суперклассом как ascii-stream, так и disk-stream.</p>

<p>Иногда невозможно сохранить генеалогические древа нетронутыми, но если два суперкласса имеют "общий хвост", он перемещается в конец списка приоритетов классов. Предположим, что класс A имеет прямые суперклассы B и C, а список приоритетов классов B и C выглядит следующим образом:</p>

<table>
<thead>
<tr>
  <th>Class</th>
  <th>Class Precedence List</th>
</tr>
</thead>
<tbody>
<tr>
  <td>B</td>
  <td>(B Bl B2 B3 B4 D Dl D2 standard-object t)</td>
</tr>
<tr>
  <td>C</td>
  <td>(C Cl C2 D Dl D2 standard-object t)</td>
</tr>
</tbody>
</table>

<p>Классы B и C имеют общий хвост, потому что, начиная с D, два списка приоритетов классов равны. До класса D списки приоритетов классов не пересекаются. В списке приоритета класса A общий хвост перемещается в конец:</p>

<pre>
(A B Bl B2 B3 B4 C Cl C2 D Dl D2 standard-object t) 
</pre>

<p>Нет необходимости беспокоиться, если несколько порядков удовлетворяют ограничениям, если только на самом деле программа не зависит от одного из порядков. Если это так, вы должны сделать зависимость упорядочения явной, как показано далее.</p>

<h3>Как добавить ограничения на порядок</h3>

<p>Чтобы продолжить предыдущий пример, предположим, что какой-то аспект программы зависит от класса disk-stream, предшествующего классу char-stream, и от класса char-stream, предшествующего buffered-stream. То есть вы хотите, чтобы была выбрана треть из возможных общих порядков.</p>

<p>В этом примере трудно представить какую-либо семантическую причину, по которой потоковая программа должна иметь упомянутые зависимости, потому что не должно быть никакого взаимодействия между классами, порядок которых не ограничен. Однако в других программах вполне может быть взаимодействие между различными классами.</p>

<p>Вы можете добавить упомянутые ограничения, определив класс ascii-disk-stream другим способом:</p>

<pre>
(defclass ascii-disk-stream 
    (ascii-stream disk-stream 
     char-stream buffered-stream) 
  0) 
</pre>

<p>Предыдущие упомянутые ограничения все еще действуют, и есть два новых ограничения:</p>

<table>
<thead>
<tr>
  <th>Ограничение</th>
  <th>Правило</th>
  <th>Класс</th>
</tr>
</thead>
<tbody>
<tr>
  <td>disk-stream &gt;&gt; char-stream</td>
  <td>2</td>
  <td>ascii-disk-stream</td>
</tr>
<tr>
  <td>char-stream &gt;&gt; buffered-stream</td>
  <td>2</td>
  <td>ascii-disk-stream</td>
</tr>
</tbody>
</table>

<p>Эти дополнительные ограничения приводят ровно к одному возможному полному упорядочению:</p>

<pre>
(ascii-disk-stream ascii-stream 
                   disk-stream char-stream buffered-stream 
                   stream standard-object t) 
</pre>

<h3>Случай 3: Ни один Полный порядок не удовлетворяет ограничениям</h3>

<p>Никакой полный порядок не удовлетворяет ограничениям, когда класс включен более чем в одно определение класса, а локальные ограничения, установленные определениями классов, находятся в прямом конфликте друг с другом.</p>

<p>CLOS не может разрешить такой конфликт, поэтому он сигнализирует об ошибке. Затем вы можете отредактировать определения классов, чтобы удалить некоторые из конфликтующих ограничений упорядочения. Вот пример классовой организации, в которой полный порядок невозможен. Мы пытаемся определить список приоритетов классов для класса ascii-disk-stream, учитывая следующие определения классов:</p>

<pre>
(defclass stream () ()) 
(defclass buffered-stream (stream) ()) 
(defclass disk-stream (buffered-stream) ()) 
(defclass char-stream (stream) ()) 
(defclass ascii-stream (char-stream) ()) 
(defclass ascii-disk-stream 
    (ascii-stream buffered-stream disk-stream) 
  ()) 
</pre>

<p>Два определения класса приводят к конфликту. Здесь мы приводим только противоречивые ограничения:</p>

<table>
<thead>
<tr>
  <th>Ограничение</th>
  <th>Правило</th>
  <th>Класс</th>
</tr>
</thead>
<tbody>
<tr>
  <td>disk-stream &gt;&gt; buffered-stream</td>
  <td>1</td>
  <td>disk-stream</td>
</tr>
<tr>
  <td>buffered-stream &gt;&gt; disk-stream</td>
  <td>2</td>
  <td>ascii-disk-stream</td>
</tr>
</tbody>
</table>

<p>В этом случае CLOS сигнализирует об ошибке, поскольку он не может создать список приоритетов классов, соответствующий ограничениям упорядочения.</p>

<p>Ясно, что эта классовая организация порочна. Класс ascii-disk-stream зависит от буферизованного потока, предшествующего disk-stream, но класс disk-stream зависит от disk-stream, предшествующего buffered-stream.</p>

<p>Эта конкретная проблема могла быть вызвана неправильным пониманием классовой организации. Представляется вероятным, что ограничение, установленное определением disk-stream, является семантическим ограничением, необходимым для правильной работы дисковых потоков, но что ограничение, установленное ascii-disk-stream, является просто ошибкой программиста. Вероятно, не было необходимости включать buffered-stream в качестве прямого суперкласса ascii-disk-stream.</p>

<p>Однако, если класс ascii-disk-stream действительно зависит от буферизованного потока, предшествующего disk-stream, то проблема кроется где-то в организации класса. Решение состоит в том, чтобы переосмыслить семантику организации классов.</p>

<h3>Возможны Противоположные Ограничения</h3>

<p>Можно определить два класса, которые содержат противоположные ограничения упорядочения, до тех пор, пока вы не попытаетесь определить класс, построенный на них обоих.</p>

<pre>
(defclass stream () ()) 
(defclass input-stream (stream) ()) 
(defclass buffered-stream (stream) ()) 
(defclass disk-stream (buffered-stream input-stream) ()) 
(defclass tape-stream (input-stream buffered-stream) ()) 
</pre>

<p>Обратите внимание, что класс disk-stream требует, чтобы буферизованный поток предшествовал входному потоку, но класс tape-stream требует, чтобы входной поток предшествовал буферизованному потоку.</p>

<p>Эти определения классов не конфликтуют, поскольку пока нет связи между классами disk-stream и tape-stream. Однако CLOS будет сигнализировать об ошибке, если вы попытаетесь определить класс, построенный как на disk-stream, так и на tape-stream:</p>

<pre>
(defclass disk-emulating-tape-stream (disk-stream tape-stream) ()) 
</pre>

<h2>6.3 РУКОВОДСТВО ПО ПРОЕКТИРОВАНИЮ ОРГАНИЗАЦИИ КЛАССОВ</h2>

<p>В этом разделе обсуждается, как правила приоритета классов влияют на практику программирования. Важным аспектом двух правил приоритета классов является то, что программист управляет ограничениями порядка локально, решая, какие прямые суперклассы включать и каким должен быть их порядок.
Если все ограничения локального порядка верны, результирующий список приоритетов классов будет соответствующим. При разработке организации классов вы должны сосредоточиться на влиянии двух правил на каждое определение класса, не заботясь об окончательном списке приоритетов классов.</p>

<table>
<thead>
<tr>
  <th>Правило 1 приоритета класса:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Класс всегда имеет приоритет над своими суперклассами.</td>
</tr>
</tbody>
</table>

<p>Правило 1 предполагает, что вы должны определить один или несколько базовых классов и создать на их основе более специализированные классы. Этот стиль программирования позволяет специализированным классам наследовать желаемое поведение и переопределять нежелательное.</p>

<table>
<thead>
<tr>
  <th>Правило 2 приоритета класса:</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Каждое определение класса устанавливает порядок приоритета своих</td>
</tr>
<tr>
  <td>прямых суперклассов.</td>
</tr>
</tbody>
</table>

<p>Правило 2 имеет последствия для классов, построенных более чем на одном прямом суперклассе. В некоторых случаях каждый прямой суперкласс вносит свой особый вклад, и между ними нет конфликта; тогда не имеет значения, как вы упорядочиваете их в списке суперклассов. Однако в других случаях два суперкласса обладают конкурирующими чертами. Например, у них обоих может быть основной метод для одной и той же обобщенной функции. В этом случае вам следует решить, какой из двух основных методов более подходит для нового класса, и соответствующим образом упорядочить два прямых суперкласса.</p>

<p>Правило 2 также поощряет стиль программирования, использующий mixin(смешанные) классы. В этом стиле каждый класс mixin поддерживает отдельный, четко определенный аспект поведения. Цели примесей(mixin) состоят в том, чтобы полностью поддерживать это поведение и не сталкиваться с другими классами. Например, mixin может предоставлять методы (before-)"до" и (after-)"после", которые изменяют поведение первичных методов, предоставляемых другими классами. Когда миксин не конкурирует с другими классами, порядок его приоритета не важен. Обычно миксин имеет корневой класс в качестве своего единственного суперкласса, поэтому его ограничения на порядок минимальны. Это позволяет создавать класс из набора многих миксинов.</p>

<p>Обратите внимание, что окончательный список приоритетов классов всегда удовлетворяет двум правилам — и, в большинстве случаев, он также следует руководству по сохранению непересекающихся генеалогических деревьев вместе. В большинстве случаев программа может рассматривать каждый из прямых суперклассов как черный ящик и может полагаться на все суперклассы первого прямого суперкласса, предшествующего второму прямому суперклассу, и на все его суперклассы. В случаях, когда CLOS не могут следовать руководству (из-за других ограничений упорядочения), результирующий список приоритетов классов позволяет суперклассу второго прямого суперкласса предшествовать суперклассу первого прямого суперкласса.</p>

<p>Как упоминалось ранее, если программа зависит от того, что один класс более специфичен, чем другой, вы должны сделать это ограничение упорядочения явным.</p>

<h2>6.4 НАСЛЕДОВАНИЕ СЛОТОВ И ОПЦИЙ СЛОТОВ</h2>

<p>Класс может определить слот, предоставив спецификатор слота, который включает в себя имя слота и, возможно, некоторые параметры слота. В дополнение к слотам, которые класс определяет локально в своей форме defclass, класс наследует слоты и параметры слотов, определенные его суперклассами.</p>

<h3>Изменение унаследованных аспектов слота</h3>

<p>Класс может изменять или переопределять аспекты слота, которые в противном случае были бы унаследованы, предоставляя локальный спецификатор слота для слота с тем же именем. Например:</p>

<pre>
(defclass basic-lock () 
  ((name :initarg :name))) 

(defclass simple-lock (basic-lock) 
  ((name :initform "Simple Lock"))) 
</pre>

<p>Класс basic-lock предоставляет спецификатор слота для слота с именем name и параметр слота :initarg :name</p>

<p>Класс simple-lock, который построен на basic-lock, наследует слот name и параметр слота :initarg :name. Он также предоставляет локальный спецификатор слота для слота name и опции слота :initform. Это не переопределяет ни один из унаследованных признаков, но добавляет в слот форму начального значения по умолчанию. Для класса часто бывает полезно предоставить форму начального значения по умолчанию для слота, который наследуется от суперкласса.</p>

<p>Каждый экземпляр simple-lock имеет только один слот с именем name. Характеристики этого слота берутся из всех классов в списке приоритета классов, которые предоставляют спецификатор слота для name. Экземпляры simple-lock получают следующие характеристики слотов от этих классов:</p>

<table>
<thead>
<tr>
  <th>Характеристики слота</th>
  <th>Из Класса</th>
</tr>
</thead>
<tbody>
<tr>
  <td>the name slot itself</td>
  <td>basic-lock</td>
</tr>
<tr>
  <td>:initarg :name</td>
  <td>basic-lock</td>
</tr>
<tr>
  <td>:initform "Simple Lock"</td>
  <td>simple-lock</td>
</tr>
</tbody>
</table>

<h3>Поведение наследования каждого параметра слота</h3>

<p>Здесь мы опишем, как наследуется каждая опция слота. Параметры слота имеют различное поведение наследования. Важно отметить, что каждая опция слота наследуется независимо от других опций слота.</p>

<p>Каждый класс в списке приоритетов классов может влиять на характеристики слота, предоставляя спецификатор слота для слота с таким именем. CLOS собирает воедино спецификаторы слотов и ранжирует их от наиболее специфичных до наименее специфичных на основе списка приоритетов классов. Другими словами, приоритет спецификатора слота определяется приоритетом класса, который его предоставляет.</p>

<p>Эти правила определяют окончательный набор характеристик слота:</p>

<pre><code>    &gt; :accessor, :reader, :writer                             Not inherited 
    &gt;           Эти параметры слота создают методы, но не влияют на сам слот. 
    &gt;           Хотя сами по себе эти параметры слота не наследуются, методы 
    &gt;           доступа наследуются таким же образом, как и любой другой метод.

       &gt; :allocation                                            Inherited by shadowing 
       &gt;              Выделение слота контролируется наиболее специфичным классом, который 
       &gt;              предоставляет спецификатор слота для слота, независимо от того, предусмотрена
       &gt;              ли опция :allocation слота.
</code></pre>

<p>Если наиболее конкретный спецификатор слота предоставляет :allocation :instance или вообще не предоставляет опцию слота :allocation, этот слот является локальным слотом. Если наиболее конкретный спецификатор слота предоставляет :allocation :class, это общий слот. (В этом случае для этого класса создается новый слот класса, который доступен для всех его экземпляров и для экземпляров любых подклассов, которые не предоставляют или не наследуют более конкретный спецификатор слота для слота.)</p>

<pre><code>     &gt; :documentation                                         Inherited by shadowing 
     &gt;            Документация слота контролируется наиболее специфичным спецификатором слота, 
     &gt;            который предоставляет опцию :documentation slot для этого слота. Любые менее 
     &gt;            специфические спецификаторы слотов, которые предоставляют параметр слота 
     &gt;            :documentation, игнорируются.

     &gt; :initarg                                               Inherited by union 
     &gt;         Слот может иметь более одного инициализирующего параметра :initarg. Если несколько классов
     &gt;         в списке приоритета классов предоставляют параметр слота :initarg для одного и того же слота,
     &gt;         слот может быть инициализирован с помощью любого из initarg.

    &gt; :initform                                              Inherited by shadowing 
    &gt;        Начальная форма(initform) слота управляется наиболее специфичным спецификатором слота,
    &gt;        который предоставляет опцию слота :initform для этого слота. Любые менее специфические
    &gt;        спецификаторы слотов, которые предоставляют :initform, игнорируются.

    &gt; :type                                                  Inherited by "and" 
    &gt;       Тип слота определяется всеми спецификаторами слота, которые предоставляют опцию слота
    &gt;       :type. Значение слота должно удовлетворять всем предусмотренным ограничениям типа. 
    &gt;       Например, если три класса в списке приоритета классов определяют тип как number, rational и
    &gt;       integer, то значение слота должно удовлетворять
    &gt;      (typep value ' (and number rational integer)) 
    &gt;       Это подразумевает, что класс не может ослабить какие-либо унаследованные ограничения типа
    &gt;       для слота, но это может сделать ограничение типа более строгим.

    &gt;              (typep value ' (and number rational integer))

    &gt;        Это подразумевает, что класс не может ослабить какие-либо унаследованные ограничения типа 
    &gt;        для слота, но это может сделать ограничение типа более строгим.
</code></pre>

<h2>6.5 РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ НАСЛЕДОВАНИЯ ПАРАМЕТРОВ СЛОТОВ</h2>

<p>Поведение наследования слотов и опций слотов, вероятно, звучит сложно. Каждый вариант слота наследуется независимо и по разным правилам. Поведение наследования каждого параметра слота предлагает функцию, которая может быть полезна в некоторых контекстах, но большинству программ не нужны все эти функции.</p>

<p>Почти все программы CLOS используют тот факт, что слоты наследуются. Базовый класс предоставляет небольшое количество слотов, подходящих для всех классов, построенных на его основе, а более специализированные классы могут включать дополнительные слоты.</p>

<p>Многие программы CLOS используют преимущества наследования опции слота :initform. В некоторых случаях целесообразно наследовать начальное значение по умолчанию от суперкласса. В других случаях полезно переопределить унаследованное начальное значение по умолчанию.</p>

<p>Многие программы CLOS также используют преимущества наследования опции слота :initarg. Обычно класс, предоставляющий слот, также предоставляет initarg, если слот предназначен для инициализации. Иногда подклассу полезно предоставить опцию слота :initarg, чтобы предоставить слоту другой инициализирующий параметр.</p>

<p>Когда используется :type, обычно класс, предоставляющий слот, также определяет тип слота. Подклассы обычно наследуют тип без необходимости его дальнейшего ограничения.</p>

<p>Как правило, подклассы не выбирают переопределение выделения слота. Для класса необычно изменять распределение слота с :class на :instance или наоборот, потому что семантика общего слота по сравнению с локальным слотом сильно отличается. Наиболее распространенный пример переопределения распределения возникает, когда один класс указывает слот :class, а его подкласс выбирает не использовать этот конкретный слот, а скорее создать новый слот :class, который будет использоваться совместно экземплярами подкласса (и экземплярами его подклассов, если они также не создают новый слот :class).</p>
</body> </html>
